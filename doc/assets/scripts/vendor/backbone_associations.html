<!DOCTYPE html><html lang="en"><head><title>assets/scripts/vendor/backbone_associations</title></head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0"><meta name="groc-relative-root" content="../../../"><meta name="groc-document-path" content="assets/scripts/vendor/backbone_associations"><meta name="groc-project-path" content="assets/scripts/vendor/backbone_associations.js"><link rel="stylesheet" type="text/css" media="all" href="../../../assets/style.css"><script type="text/javascript" src="../../../assets/behavior.js"></script><body><div id="meta"><div class="file-path">assets/scripts/vendor/backbone_associations.js</div></div><div id="document"><div class="segment"><div class="comments "><div class="wrapper"><p> Backbone-associations.js 0.5.4
 (c) 2013 Dhruva Ray, Jaynti Kanani, Persistent Systems Ltd.
 Backbone-associations may be freely distributed under the MIT license.
 For all details and documentation:
 <a href="https://github.com/dhruvaray/backbone-associations/">https://github.com/dhruvaray/backbone-associations/</a></p></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h2 id="initial-setup">Initial Setup</h2></div></div></div><div class="segment"><div class="code"><div class="wrapper">(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
<span class="hljs-pi">    "use strict"</span>;</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Save a reference to the global object (<code>window</code> in the browser, <code>exports</code>
on the server).</p></div></div><div class="code"><div class="wrapper">    <span class="hljs-keyword">var</span> root = <span class="hljs-keyword">this</span>;</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>The top-level namespace. All public Backbone classes and modules will be attached to this.
Exported for the browser and CommonJS.</p></div></div><div class="code"><div class="wrapper">    <span class="hljs-keyword">var</span> _, Backbone, BackboneModel, BackboneCollection, ModelProto,
        CollectionProto, defaultEvents, AssociatedModel, pathChecker,
        collectionEvents, delimiters, pathSeparator;

    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> exports !== <span class="hljs-string">'undefined'</span>) {
        _ = <span class="hljs-built_in">require</span>(<span class="hljs-string">'underscore'</span>);
        Backbone = <span class="hljs-built_in">require</span>(<span class="hljs-string">'backbone'</span>);
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> module !== <span class="hljs-string">'undefined'</span> &amp;&amp; module.exports) {
            module.exports = Backbone;
        }
        exports = Backbone;
    } <span class="hljs-keyword">else</span> {
        _ = root._;
        Backbone = root.Backbone;
    }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Create local reference <code>Model</code> prototype.</p></div></div><div class="code"><div class="wrapper">    BackboneModel = Backbone.Model;
    BackboneCollection = Backbone.Collection;
    ModelProto = BackboneModel.prototype;
    CollectionProto = BackboneCollection.prototype;</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Built-in Backbone <code>events</code>.</p></div></div><div class="code"><div class="wrapper">    defaultEvents = [<span class="hljs-string">"change"</span>, <span class="hljs-string">"add"</span>, <span class="hljs-string">"remove"</span>, <span class="hljs-string">"reset"</span>, <span class="hljs-string">"sort"</span>, <span class="hljs-string">"destroy"</span>];
    collectionEvents = [<span class="hljs-string">"reset"</span>, <span class="hljs-string">"sort"</span>];

    Backbone.Associations = {
        VERSION: <span class="hljs-string">"0.5.4"</span>
    };</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Define <code>getter</code> and <code>setter</code> for <code>separator</code></p></div></div><div class="code"><div class="wrapper">    <span class="hljs-keyword">var</span> getSeparator = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>
        <span class="hljs-keyword">return</span> pathSeparator;
    };</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Define <code>setSeperator</code></p></div></div><div class="code"><div class="wrapper">    <span class="hljs-keyword">var</span> setSeparator = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(value)</span> {</span>
        <span class="hljs-keyword">if</span> (!_.isString(value) || _.size(value) &lt; <span class="hljs-number">1</span>) {
            value = <span class="hljs-string">"."</span>;
        }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>set private properties</p></div></div><div class="code"><div class="wrapper">        pathSeparator = value;
        pathChecker = <span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>(<span class="hljs-string">"[\\"</span> + pathSeparator + <span class="hljs-string">"\\[\\]]+"</span>, <span class="hljs-string">"g"</span>);
        delimiters = <span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>(<span class="hljs-string">"[^\\"</span> + pathSeparator + <span class="hljs-string">"\\[\\]]+"</span>, <span class="hljs-string">"g"</span>);
    };

    <span class="hljs-keyword">try</span> {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Define <code>SEPERATOR</code> property to Backbone.Associations</p></div></div><div class="code"><div class="wrapper">        <span class="hljs-built_in">Object</span>.defineProperty(Backbone.Associations, <span class="hljs-string">'SEPARATOR'</span>, {
            enumerable: <span class="hljs-literal">true</span>,
            get: getSeparator,
            set: setSeparator
        });
    } <span class="hljs-keyword">catch</span> (e) {}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h2 id="backboneassociatedmodel">Backbone.AssociatedModel</h2></div></div></div><div class="segment"><div class="code"><div class="wrapper">    <span class="hljs-comment">//Add `Many` and `One` relations to Backbone Object.</span>
    Backbone.Associations.Many = Backbone.Many = <span class="hljs-string">"Many"</span>;
    Backbone.Associations.One = Backbone.One = <span class="hljs-string">"One"</span>;
    Backbone.Associations.Self = Backbone.Self = <span class="hljs-string">"Self"</span>;</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Set default separator</p></div></div><div class="code"><div class="wrapper">    Backbone.Associations.SEPARATOR = <span class="hljs-string">"."</span>;
    Backbone.Associations.getSeparator = getSeparator;
    Backbone.Associations.setSeparator = setSeparator;
    setSeparator();</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Define <code>AssociatedModel</code> (Extends Backbone.Model).</p></div></div><div class="code"><div class="wrapper">    AssociatedModel = Backbone.AssociatedModel = Backbone.Associations.AssociatedModel = BackboneModel.extend({</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Define relations with Associated Model.</p></div></div><div class="code"><div class="wrapper">        relations:<span class="hljs-literal">undefined</span>,</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Define <code>Model</code> property which can keep track of already fired <code>events</code>,
and prevent redundant event to be triggered in case of cyclic model graphs.</p></div></div><div class="code"><div class="wrapper">        _proxyCalls:<span class="hljs-literal">undefined</span>,</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Get the value of an attribute.</p></div></div><div class="code"><div class="wrapper">        get:<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(attr)</span> {</span>
            <span class="hljs-keyword">var</span> obj = ModelProto.get.call(<span class="hljs-keyword">this</span>, attr);
            <span class="hljs-keyword">return</span> obj ? obj : <span class="hljs-keyword">this</span>._getAttr.apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>);
        },</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Set a hash of model attributes on the Backbone Model.</p></div></div><div class="code"><div class="wrapper">        set:<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(key, value, options)</span> {</span>
            <span class="hljs-keyword">var</span> attributes, result;</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Duplicate backbone&#39;s behavior to allow separate key/value parameters,
instead of a single &#39;attributes&#39; object.</p></div></div><div class="code"><div class="wrapper">            <span class="hljs-keyword">if</span> (_.isObject(key) || key == <span class="hljs-literal">null</span>) {
                attributes = key;
                options = value;
            } <span class="hljs-keyword">else</span> {
                attributes = {};
                attributes[key] = value;
            }
            result = <span class="hljs-keyword">this</span>._set(attributes, options);</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Trigger events which have been blocked until the entire object graph is updated.</p></div></div><div class="code"><div class="wrapper">            <span class="hljs-keyword">this</span>._processPendingEvents();
            <span class="hljs-keyword">return</span> result;

        },</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Works with an attribute hash and options + fully qualified paths</p></div></div><div class="code"><div class="wrapper">        _set:<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(attributes, options)</span> {</span>
            <span class="hljs-keyword">var</span> attr, modelMap, modelId, obj, result = <span class="hljs-keyword">this</span>;
            <span class="hljs-keyword">if</span> (!attributes) <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
            <span class="hljs-keyword">for</span> (attr <span class="hljs-keyword">in</span> attributes) {
                <span class="hljs-comment">//Create a map for each unique object whose attributes we want to set</span>
                modelMap || (modelMap = {});
                <span class="hljs-keyword">if</span> (attr.match(pathChecker)) {
                    <span class="hljs-keyword">var</span> pathTokens = getPathArray(attr), initials = _.initial(pathTokens),
                        last = pathTokens[pathTokens.length - <span class="hljs-number">1</span>],
                        parentModel = <span class="hljs-keyword">this</span>.get(initials);
                    <span class="hljs-keyword">if</span> (parentModel <span class="hljs-keyword">instanceof</span> AssociatedModel) {
                        obj = modelMap[parentModel.cid] || (modelMap[parentModel.cid] = {<span class="hljs-string">'model'</span>:parentModel, <span class="hljs-string">'data'</span>:{}});
                        obj.data[last] = attributes[attr];
                    }
                } <span class="hljs-keyword">else</span> {
                    obj = modelMap[<span class="hljs-keyword">this</span>.cid] || (modelMap[<span class="hljs-keyword">this</span>.cid] = {<span class="hljs-string">'model'</span>:<span class="hljs-keyword">this</span>, <span class="hljs-string">'data'</span>:{}});
                    obj.data[attr] = attributes[attr];
                }
            }

            <span class="hljs-keyword">if</span> (modelMap) {
                <span class="hljs-keyword">for</span> (modelId <span class="hljs-keyword">in</span> modelMap) {
                    obj = modelMap[modelId];
                    <span class="hljs-keyword">this</span>._setAttr.call(obj.model, obj.data, options) || (result = <span class="hljs-literal">false</span>);

                }
            } <span class="hljs-keyword">else</span> {
                result = <span class="hljs-keyword">this</span>._setAttr.call(<span class="hljs-keyword">this</span>, attributes, options);
            }
            <span class="hljs-keyword">return</span> result;

        },</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Set a hash of model attributes on the object,
fire Backbone <code>event</code> with options.
It maintains relations between models during the set operation.
It also bubbles up child events to the parent.</p></div></div><div class="code"><div class="wrapper">        _setAttr:<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(attributes, options)</span> {</span>
            <span class="hljs-keyword">var</span> attr;</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Extract attributes and options.</p></div></div><div class="code"><div class="wrapper">            options || (options = {});
            <span class="hljs-keyword">if</span> (options.unset) <span class="hljs-keyword">for</span> (attr <span class="hljs-keyword">in</span> attributes) attributes[attr] = <span class="hljs-keyword">void</span> <span class="hljs-number">0</span>;
            <span class="hljs-keyword">this</span>.parents = <span class="hljs-keyword">this</span>.parents || [];

            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.relations) {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Iterate over <code>this.relations</code> and <code>set</code> model and collection values
if <code>relations</code> are available.</p></div></div><div class="code"><div class="wrapper">                _.each(<span class="hljs-keyword">this</span>.relations, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(relation)</span> {</span>
                    <span class="hljs-keyword">var</span> relationKey = relation.key,
                        relatedModel = relation.relatedModel,
                        collectionType = relation.collectionType,
                        map = relation.map,
                        currVal = <span class="hljs-keyword">this</span>.attributes[relationKey],
                        idKey = currVal &amp;&amp; currVal.idAttribute,
                        val, relationOptions, data, relationValue, newCtx = <span class="hljs-literal">false</span>;</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Call function if relatedModel is implemented as a function</p></div></div><div class="code"><div class="wrapper">                    <span class="hljs-keyword">if</span> (relatedModel &amp;&amp; !(relatedModel.prototype <span class="hljs-keyword">instanceof</span> BackboneModel))
                        relatedModel = _.isFunction(relatedModel) ?
                            relatedModel.call(<span class="hljs-keyword">this</span>, relation, attributes) :
                            relatedModel;</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Get class if relation and map is stored as a string.</p></div></div><div class="code"><div class="wrapper">                    <span class="hljs-keyword">if</span> (relatedModel &amp;&amp; _.isString(relatedModel)) {
                        relatedModel = (relatedModel === Backbone.Self) ? <span class="hljs-keyword">this</span>.constructor : map2Scope(relatedModel);
                    }
                    collectionType &amp;&amp; _.isString(collectionType) &amp;&amp; (collectionType = map2Scope(collectionType));
                    map &amp;&amp; _.isString(map) &amp;&amp; (map = map2Scope(map));</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Merge in <code>options</code> specific to this relation.</p></div></div><div class="code"><div class="wrapper">                    relationOptions = relation.options ? _.extend({}, relation.options, options) : options;

                    <span class="hljs-keyword">if</span> ((!relatedModel) &amp;&amp; (!collectionType))
                        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'specify either a relatedModel or collectionType'</span>);

                    <span class="hljs-keyword">if</span> (attributes[relationKey]) {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Get value of attribute with relation key in <code>val</code>.</p></div></div><div class="code"><div class="wrapper">                        val = _.result(attributes, relationKey);</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Map <code>val</code> if a transformation function is provided.</p></div></div><div class="code"><div class="wrapper">                        val = map ? map.call(<span class="hljs-keyword">this</span>, val, collectionType ? collectionType : relatedModel) : val;</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>If <code>relation.type</code> is <code>Backbone.Many</code>,
Create <code>Backbone.Collection</code> with passed data and perform Backbone <code>set</code>.</p></div></div><div class="code"><div class="wrapper">                        <span class="hljs-keyword">if</span> (relation.type === Backbone.Many) {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p><code>collectionType</code> of defined <code>relation</code> should be instance of <code>Backbone.Collection</code>.</p></div></div><div class="code"><div class="wrapper">                            <span class="hljs-keyword">if</span> (collectionType &amp;&amp; !collectionType.prototype <span class="hljs-keyword">instanceof</span> BackboneCollection) {
                                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'collectionType must inherit from Backbone.Collection'</span>);
                            }

                            <span class="hljs-keyword">if</span> (currVal) {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Setting this flag will prevent events from firing immediately. That way clients
will not get events until the entire object graph is updated.</p></div></div><div class="code"><div class="wrapper">                                currVal._deferEvents = <span class="hljs-literal">true</span>;</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Use Backbone.Collection&#39;s <code>reset</code> or smart <code>set</code> method</p></div></div><div class="code"><div class="wrapper">                                currVal[relationOptions.reset ? <span class="hljs-string">'reset'</span> : <span class="hljs-string">'set'</span>](
                                    val <span class="hljs-keyword">instanceof</span> BackboneCollection ? val.models : val, relationOptions);

                                data = currVal;

                            } <span class="hljs-keyword">else</span> {
                                newCtx = <span class="hljs-literal">true</span>;

                                <span class="hljs-keyword">if</span> (val <span class="hljs-keyword">instanceof</span> BackboneCollection) {
                                    data = val;
                                } <span class="hljs-keyword">else</span> {
                                    data = collectionType ? <span class="hljs-keyword">new</span> collectionType() : <span class="hljs-keyword">this</span>._createCollection(relatedModel);
                                    data[relationOptions.reset ? <span class="hljs-string">'reset'</span> : <span class="hljs-string">'set'</span>](val, relationOptions);
                                }
                            }

                        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (relation.type === Backbone.One) {

                            <span class="hljs-keyword">if</span> (!relatedModel)
                                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'specify a relatedModel for Backbone.One type'</span>);

                            <span class="hljs-keyword">if</span> (!(relatedModel.prototype <span class="hljs-keyword">instanceof</span> Backbone.AssociatedModel))
                                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'specify an AssociatedModel for Backbone.One type'</span>);

                            data = val <span class="hljs-keyword">instanceof</span> AssociatedModel ? val : <span class="hljs-keyword">new</span> relatedModel(val, relationOptions);
                            <span class="hljs-comment">//Is the passed in data for the same key?</span>
                            <span class="hljs-keyword">if</span> (currVal &amp;&amp; data.attributes[idKey] &amp;&amp;
                                currVal.attributes[idKey] === data.attributes[idKey]) {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Setting this flag will prevent events from firing immediately. That way clients
will not get events until the entire object graph is updated.</p></div></div><div class="code"><div class="wrapper">                                currVal._deferEvents = <span class="hljs-literal">true</span>;</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Perform the traditional <code>set</code> operation</p></div></div><div class="code"><div class="wrapper">                                currVal._set(val <span class="hljs-keyword">instanceof</span> AssociatedModel ? val.attributes : val, relationOptions);
                                data = currVal;
                            } <span class="hljs-keyword">else</span> {
                                newCtx = <span class="hljs-literal">true</span>;
                            }

                        } <span class="hljs-keyword">else</span> {
                            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'type attribute must be specified and have the values Backbone.One or Backbone.Many'</span>);
                        }


                        attributes[relationKey] = data;
                        relationValue = data;</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Add proxy events to respective parents.
Only add callback if not defined or new Ctx has been identified.</p></div></div><div class="code"><div class="wrapper">                        <span class="hljs-keyword">if</span> (newCtx || (relationValue &amp;&amp; !relationValue._proxyCallback)) {
                            relationValue._proxyCallback = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
                                <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._bubbleEvent.call(<span class="hljs-keyword">this</span>, relationKey, relationValue, <span class="hljs-built_in">arguments</span>);
                            };
                            relationValue.on(<span class="hljs-string">"all"</span>, relationValue._proxyCallback, <span class="hljs-keyword">this</span>);
                        }

                    }
                    <span class="hljs-comment">//Distinguish between the value of undefined versus a set no-op</span>
                    <span class="hljs-keyword">if</span> (attributes.hasOwnProperty(relationKey)) {
                        <span class="hljs-comment">//Maintain reverse pointers - a.k.a parents</span>
                        <span class="hljs-keyword">var</span> updated = attributes[relationKey];
                        <span class="hljs-keyword">var</span> original = <span class="hljs-keyword">this</span>.attributes[relationKey];
                        <span class="hljs-keyword">if</span> (updated) {
                            updated.parents = updated.parents || [];
                            (_.indexOf(updated.parents, <span class="hljs-keyword">this</span>) == -<span class="hljs-number">1</span>) &amp;&amp; updated.parents.push(<span class="hljs-keyword">this</span>);
                        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (original &amp;&amp; original.parents.length &gt; <span class="hljs-number">0</span>) { <span class="hljs-comment">// New value is undefined</span>
                            original.parents = _.difference(original.parents, [<span class="hljs-keyword">this</span>]);</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Don&#39;t bubble to this parent anymore</p></div></div><div class="code"><div class="wrapper">                            original._proxyCallback &amp;&amp; original.off(<span class="hljs-string">"all"</span>, original._proxyCallback, <span class="hljs-keyword">this</span>);
                        }
                    }
                }, <span class="hljs-keyword">this</span>);
            }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Return results for <code>BackboneModel.set</code>.</p></div></div><div class="code"><div class="wrapper">            <span class="hljs-keyword">return</span>  ModelProto.set.call(<span class="hljs-keyword">this</span>, attributes, options);
        },</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Bubble-up event to <code>parent</code> Model</p></div></div><div class="code"><div class="wrapper">        _bubbleEvent:<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(relationKey, relationValue, eventArguments)</span> {</span>
            <span class="hljs-keyword">var</span> args = eventArguments,
                opt = args[<span class="hljs-number">0</span>].split(<span class="hljs-string">":"</span>),
                eventType = opt[<span class="hljs-number">0</span>],
                catch_all = args[<span class="hljs-number">0</span>] == <span class="hljs-string">"nested-change"</span>,
                eventObject = args[<span class="hljs-number">1</span>],
                colObject = args[<span class="hljs-number">2</span>],
                indexEventObject = -<span class="hljs-number">1</span>,
                _proxyCalls = relationValue._proxyCalls,
                cargs,
                eventPath,
                basecolEventPath,
                isDefaultEvent = _.indexOf(defaultEvents, eventType) !== -<span class="hljs-number">1</span>;

            <span class="hljs-comment">//Short circuit the listen in to the nested-graph event</span>
            <span class="hljs-keyword">if</span> (catch_all) <span class="hljs-keyword">return</span>;</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Change the event name to a fully qualified path.</p></div></div><div class="code"><div class="wrapper">            _.size(opt) &gt; <span class="hljs-number">1</span> &amp;&amp; (eventPath = opt[<span class="hljs-number">1</span>]);

            <span class="hljs-keyword">if</span> (_.indexOf(collectionEvents, eventType) !== -<span class="hljs-number">1</span>) {
                colObject = eventObject;
            }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Find the specific object in the collection which has changed.</p></div></div><div class="code"><div class="wrapper">            <span class="hljs-keyword">if</span> (relationValue <span class="hljs-keyword">instanceof</span> BackboneCollection &amp;&amp; isDefaultEvent &amp;&amp; eventObject) {
                <span class="hljs-keyword">var</span> pathTokens = getPathArray(eventPath),
                    initialTokens = _.initial(pathTokens), colModel;

                colModel = relationValue.find(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(model)</span> {</span>
                    <span class="hljs-keyword">if</span> (eventObject === model) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
                    <span class="hljs-keyword">if</span> (!model) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
                    <span class="hljs-keyword">var</span> changedModel = model.get(initialTokens);

                    <span class="hljs-keyword">if</span> ((changedModel <span class="hljs-keyword">instanceof</span> AssociatedModel || changedModel <span class="hljs-keyword">instanceof</span> BackboneCollection)
                        &amp;&amp; eventObject === changedModel)
                        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;

                    changedModel = model.get(pathTokens);

                    <span class="hljs-keyword">if</span> ((changedModel <span class="hljs-keyword">instanceof</span> AssociatedModel || changedModel <span class="hljs-keyword">instanceof</span> BackboneCollection)
                        &amp;&amp; eventObject === changedModel)
                        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;

                    <span class="hljs-keyword">if</span> (changedModel <span class="hljs-keyword">instanceof</span> BackboneCollection &amp;&amp; colObject
                        &amp;&amp; colObject === changedModel)
                        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
                });
                colModel &amp;&amp; (indexEventObject = relationValue.indexOf(colModel));
            }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Manipulate <code>eventPath</code>.</p></div></div><div class="code"><div class="wrapper">            eventPath = relationKey + ((indexEventObject !== -<span class="hljs-number">1</span> &amp;&amp; (eventType === <span class="hljs-string">"change"</span> || eventPath)) ?
                <span class="hljs-string">"["</span> + indexEventObject + <span class="hljs-string">"]"</span> : <span class="hljs-string">""</span>) + (eventPath ? pathSeparator + eventPath : <span class="hljs-string">""</span>);</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Short circuit collection * events</p></div></div><div class="code"><div class="wrapper">            <span class="hljs-keyword">if</span> (<span class="hljs-regexp">/\[\*\]/g</span>.test(eventPath)) <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
            basecolEventPath = eventPath.replace(<span class="hljs-regexp">/\[\d+\]/g</span>, <span class="hljs-string">'[*]'</span>);

            cargs = [];
            cargs.push.apply(cargs, args);
            cargs[<span class="hljs-number">0</span>] = eventType + <span class="hljs-string">":"</span> + eventPath;</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>If event has been already triggered as result of same source <code>eventPath</code>,
no need to re-trigger event to prevent cycle.</p></div></div><div class="code"><div class="wrapper">            _proxyCalls = relationValue._proxyCalls = (_proxyCalls || {});
            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>._isEventAvailable.call(<span class="hljs-keyword">this</span>, _proxyCalls, eventPath)) <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Add <code>eventPath</code> in <code>_proxyCalls</code> to keep track of already triggered <code>event</code>.</p></div></div><div class="code"><div class="wrapper">            _proxyCalls[eventPath] = <span class="hljs-literal">true</span>;</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Set up previous attributes correctly.</p></div></div><div class="code"><div class="wrapper">            <span class="hljs-keyword">if</span> (<span class="hljs-string">"change"</span> === eventType) {
                <span class="hljs-keyword">this</span>._previousAttributes[relationKey] = relationValue._previousAttributes;
                <span class="hljs-keyword">this</span>.changed[relationKey] = relationValue;
            }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Bubble up event to parent <code>model</code> with new changed arguments.</p></div></div><div class="code"><div class="wrapper">            <span class="hljs-keyword">this</span>.trigger.apply(<span class="hljs-keyword">this</span>, cargs);

            <span class="hljs-comment">//Only fire for change. Not change:attribute</span>
            <span class="hljs-keyword">if</span> (<span class="hljs-string">"change"</span> === eventType &amp;&amp; <span class="hljs-keyword">this</span>.get(eventPath) != args[<span class="hljs-number">2</span>]) {
                <span class="hljs-keyword">var</span> ncargs = [<span class="hljs-string">"nested-change"</span>, eventPath, args[<span class="hljs-number">1</span>]];
                args[<span class="hljs-number">2</span>] &amp;&amp; ncargs.push(args[<span class="hljs-number">2</span>]); <span class="hljs-comment">//args[2] will be options if present</span>
                <span class="hljs-keyword">this</span>.trigger.apply(<span class="hljs-keyword">this</span>, ncargs);
            }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Remove <code>eventPath</code> from <code>_proxyCalls</code>,
if <code>eventPath</code> and <code>_proxyCalls</code> are available,
which allow event to be triggered on for next operation of <code>set</code>.</p></div></div><div class="code"><div class="wrapper">            <span class="hljs-keyword">if</span> (_proxyCalls &amp;&amp; eventPath) <span class="hljs-keyword">delete</span> _proxyCalls[eventPath];</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Create a collection modified event with wild-card</p></div></div><div class="code"><div class="wrapper">            <span class="hljs-keyword">if</span> (eventPath !== basecolEventPath) {
                cargs[<span class="hljs-number">0</span>] = eventType + <span class="hljs-string">":"</span> + basecolEventPath;
                <span class="hljs-keyword">this</span>.trigger.apply(<span class="hljs-keyword">this</span>, cargs);
            }

            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
        },</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Has event been fired from this source. Used to prevent event recursion in cyclic graphs</p></div></div><div class="code"><div class="wrapper">        _isEventAvailable:<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(_proxyCalls, path)</span> {</span>
            <span class="hljs-keyword">return</span> _.find(_proxyCalls, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(value, eventKey)</span> {</span>
                <span class="hljs-keyword">return</span> path.indexOf(eventKey, path.length - eventKey.length) !== -<span class="hljs-number">1</span>;
            });
        },</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Returns New <code>collection</code> of type <code>relation.relatedModel</code>.</p></div></div><div class="code"><div class="wrapper">        _createCollection:<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(type)</span> {</span>
            <span class="hljs-keyword">var</span> collection, relatedModel = type;
            _.isString(relatedModel) &amp;&amp; (relatedModel = map2Scope(relatedModel));</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Creates new <code>Backbone.Collection</code> and defines model class.</p></div></div><div class="code"><div class="wrapper">            <span class="hljs-keyword">if</span> (relatedModel &amp;&amp; (relatedModel.prototype <span class="hljs-keyword">instanceof</span> AssociatedModel) || _.isFunction(relatedModel)) {
                collection = <span class="hljs-keyword">new</span> BackboneCollection();
                collection.model = relatedModel;
            } <span class="hljs-keyword">else</span> {
                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'type must inherit from Backbone.AssociatedModel'</span>);
            }
            <span class="hljs-keyword">return</span> collection;
        },</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Process all pending events after the entire object graph has been updated</p></div></div><div class="code"><div class="wrapper">        _processPendingEvents:<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
            <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>._processedEvents) {
                <span class="hljs-keyword">this</span>._processedEvents = <span class="hljs-literal">true</span>;

                <span class="hljs-keyword">this</span>._deferEvents = <span class="hljs-literal">false</span>;</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Trigger all pending events</p></div></div><div class="code"><div class="wrapper">                _.each(<span class="hljs-keyword">this</span>._pendingEvents, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(e)</span> {</span>
                    e.c.trigger.apply(e.c, e.a);
                });

                <span class="hljs-keyword">this</span>._pendingEvents = [];</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Traverse down the object graph and call process pending events on sub-trees</p></div></div><div class="code"><div class="wrapper">                _.each(<span class="hljs-keyword">this</span>.relations, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(relation)</span> {</span>
                    <span class="hljs-keyword">var</span> val = <span class="hljs-keyword">this</span>.attributes[relation.key];
                    val &amp;&amp; val._processPendingEvents();
                }, <span class="hljs-keyword">this</span>);

                <span class="hljs-keyword">delete</span> <span class="hljs-keyword">this</span>._processedEvents;
            }
        },</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Override trigger to defer events in the object graph.</p></div></div><div class="code"><div class="wrapper">        trigger:<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(name)</span> {</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Defer event processing</p></div></div><div class="code"><div class="wrapper">            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>._deferEvents) {
                <span class="hljs-keyword">this</span>._pendingEvents = <span class="hljs-keyword">this</span>._pendingEvents || [];</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Maintain a queue of pending events to trigger after the entire object graph is updated.</p></div></div><div class="code"><div class="wrapper">                <span class="hljs-keyword">this</span>._pendingEvents.push({c:<span class="hljs-keyword">this</span>, a:<span class="hljs-built_in">arguments</span>});
            } <span class="hljs-keyword">else</span> {
                ModelProto.trigger.apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>);
            }
        },</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>The JSON representation of the model.</p></div></div><div class="code"><div class="wrapper">        toJSON:<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(options)</span> {</span>
            <span class="hljs-keyword">var</span> json = {}, aJson;
            json[<span class="hljs-keyword">this</span>.idAttribute] = <span class="hljs-keyword">this</span>.id;
            <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.visited) {
                <span class="hljs-keyword">this</span>.visited = <span class="hljs-literal">true</span>;</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Get json representation from <code>BackboneModel.toJSON</code>.</p></div></div><div class="code"><div class="wrapper">                json = ModelProto.toJSON.apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>);</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>If <code>this.relations</code> is defined, iterate through each <code>relation</code>
and added it&#39;s json representation to parents&#39; json representation.</p></div></div><div class="code"><div class="wrapper">                <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.relations) {
                    _.each(<span class="hljs-keyword">this</span>.relations, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(relation)</span> {</span>
                        <span class="hljs-keyword">var</span> attr = <span class="hljs-keyword">this</span>.attributes[relation.key];
                        <span class="hljs-keyword">if</span> (attr) {
                            aJson = attr.toJSON ? attr.toJSON(options) : attr;
                            json[relation.key] = _.isArray(aJson) ? _.compact(aJson) : aJson;
                        }
                    }, <span class="hljs-keyword">this</span>);
                }
                <span class="hljs-keyword">delete</span> <span class="hljs-keyword">this</span>.visited;
            }
            <span class="hljs-keyword">return</span> json;
        },</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Create a new model with identical attributes to this one.</p></div></div><div class="code"><div class="wrapper">        clone:<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">this</span>.constructor(<span class="hljs-keyword">this</span>.toJSON());
        },</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Call this if you want to set an <code>AssociatedModel</code> to a falsy value like undefined/null directly.
Not calling this will leak memory and have wrong parents.
See test case &quot;parent relations&quot;</p></div></div><div class="code"><div class="wrapper">        cleanup:<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
            _.each(<span class="hljs-keyword">this</span>.relations, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(relation)</span> {</span>
                <span class="hljs-keyword">var</span> val = <span class="hljs-keyword">this</span>.attributes[relation.key];
                val &amp;&amp; (val.parents = _.difference(val.parents, [<span class="hljs-keyword">this</span>]));
            }, <span class="hljs-keyword">this</span>);
            <span class="hljs-keyword">this</span>.off();
        },</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Navigate the path to the leaf object in the path to query for the attribute value</p></div></div><div class="code"><div class="wrapper">        _getAttr:<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(path)</span> {</span>

            <span class="hljs-keyword">var</span> result = <span class="hljs-keyword">this</span>,
            <span class="hljs-comment">//Tokenize the path</span>
                attrs = getPathArray(path),
                key,
                i;
            <span class="hljs-keyword">if</span> (_.size(attrs) &lt; <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span>;
            <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; attrs.length; i++) {
                key = attrs[i];
                <span class="hljs-keyword">if</span> (!result) <span class="hljs-keyword">break</span>;
                <span class="hljs-comment">//Navigate the path to get to the result</span>
                result = result <span class="hljs-keyword">instanceof</span> BackboneCollection
                    ? (<span class="hljs-built_in">isNaN</span>(key) ? <span class="hljs-literal">undefined</span> : result.at(key))
                    : result.attributes[key];
            }
            <span class="hljs-keyword">return</span> result;
        }
    });</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Tokenize the fully qualified event path</p></div></div><div class="code"><div class="wrapper">    <span class="hljs-keyword">var</span> getPathArray = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(path)</span> {</span>
        <span class="hljs-keyword">if</span> (path === <span class="hljs-string">''</span>) <span class="hljs-keyword">return</span> [<span class="hljs-string">''</span>];
        <span class="hljs-keyword">return</span> _.isString(path) ? (path.match(delimiters)) : path || [];
    };

    <span class="hljs-keyword">var</span> map2Scope = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(path)</span> {</span>
        <span class="hljs-keyword">return</span> _.reduce(path.split(pathSeparator), <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(memo, elem)</span> {</span>
            <span class="hljs-keyword">return</span> memo[elem];
        }, root);
    };

    <span class="hljs-comment">//Infer the relation from the collection's parents and find the appropriate map for the passed in `models`</span>
    <span class="hljs-keyword">var</span> map2models = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(parents, target, models)</span> {</span>
        <span class="hljs-keyword">var</span> relation, surrogate;
        <span class="hljs-comment">//Iterate over collection's parents</span>
        _.find(parents, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(parent)</span> {</span>
            <span class="hljs-comment">//Iterate over relations</span>
            relation = _.find(parent.relations, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(rel)</span> {</span>
                <span class="hljs-keyword">return</span> parent.get(rel.key) === target;
            }, <span class="hljs-keyword">this</span>);
            <span class="hljs-keyword">if</span> (relation) {
                surrogate = parent;<span class="hljs-comment">//surrogate for transformation</span>
                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<span class="hljs-comment">//break;</span>
            }
        }, <span class="hljs-keyword">this</span>);

        <span class="hljs-comment">//If we found a relation and it has a mapping function</span>
        <span class="hljs-keyword">if</span> (relation &amp;&amp; relation.map) {
            <span class="hljs-keyword">return</span> relation.map.call(surrogate, models, target);
        }
        <span class="hljs-keyword">return</span> models;
    };

    <span class="hljs-keyword">var</span> proxies = {};</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Proxy Backbone collection methods</p></div></div><div class="code"><div class="wrapper">    _.each([<span class="hljs-string">'set'</span>, <span class="hljs-string">'remove'</span>, <span class="hljs-string">'reset'</span>], <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(method)</span> {</span>
        proxies[method] = BackboneCollection.prototype[method];

        CollectionProto[method] = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(models, options)</span> {</span>
            <span class="hljs-comment">//Short-circuit if this collection doesn't hold `AssociatedModels`</span>
            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.model.prototype <span class="hljs-keyword">instanceof</span> AssociatedModel &amp;&amp; <span class="hljs-keyword">this</span>.parents) {
                <span class="hljs-comment">//Find a map function if available and perform a transformation</span>
                <span class="hljs-built_in">arguments</span>[<span class="hljs-number">0</span>] = map2models(<span class="hljs-keyword">this</span>.parents, <span class="hljs-keyword">this</span>, models);
            }
            <span class="hljs-keyword">return</span> proxies[method].apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>);
        }
    });</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Override trigger to defer events in the object graph.</p></div></div><div class="code"><div class="wrapper">    proxies[<span class="hljs-string">'trigger'</span>] = CollectionProto[<span class="hljs-string">'trigger'</span>];
    CollectionProto[<span class="hljs-string">'trigger'</span>] = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(name)</span> {</span>
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>._deferEvents) {
            <span class="hljs-keyword">this</span>._pendingEvents = <span class="hljs-keyword">this</span>._pendingEvents || [];</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Maintain a queue of pending events to trigger after the entire object graph is updated.</p></div></div><div class="code"><div class="wrapper">            <span class="hljs-keyword">this</span>._pendingEvents.push({c:<span class="hljs-keyword">this</span>, a:<span class="hljs-built_in">arguments</span>});
        } <span class="hljs-keyword">else</span> {
            proxies[<span class="hljs-string">'trigger'</span>].apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>);
        }
    };</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Attach process pending event functionality on collections as well. Re-use from <code>AssociatedModel</code></p></div></div><div class="code"><div class="wrapper">    CollectionProto._processPendingEvents = AssociatedModel.prototype._processPendingEvents;


}).call(<span class="hljs-keyword">this</span>);</div></div></div></div></body></html>