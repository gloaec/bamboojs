<!DOCTYPE html><html lang="en"><head><title>assets/scripts/vendor/jquery_dataTables</title></head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0"><meta name="groc-relative-root" content="../../../"><meta name="groc-document-path" content="assets/scripts/vendor/jquery_dataTables"><meta name="groc-project-path" content="assets/scripts/vendor/jquery_dataTables.js"><link rel="stylesheet" type="text/css" media="all" href="../../../assets/style.css"><script type="text/javascript" src="../../../assets/behavior.js"></script><body><div id="meta"><div class="file-path">assets/scripts/vendor/jquery_dataTables.js</div></div><div id="document"><div class="segment"><div class="code"><div class="wrapper"><span class="hljs-comment">/*! DataTables 1.10.1
 * Â©2008-2014 SpryMedia Ltd - datatables.net/license
 */</span></div></div></div><div class="segment"><div class="comments doc-section"><div class="wrapper"><p><span class='doc-section-header'> summary DataTables, version 1.10.1, file jquery.dataTables.js, author SpryMedia Ltd (www.sprymedia.co.uk), contact www.sprymedia.co.uk/contact, and copyright Copyright 2008-2014 SpryMedia Ltd.</p>
<p>This source file is free software, available under the following license:
  MIT license - <a href="http://datatables.net/license">http://datatables.net/license</a></p>
<p>This source file is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
or FITNESS FOR A PARTICULAR PURPOSE. See the license files for details.</p>
<p>For details please refer to: <a href="http://www.datatables.net">http://www.datatables.net</a></span></p>
<p>Paginate, search and order HTML tables</p></div></div><div class="code"><div class="wrapper"><span class="hljs-comment">/*jslint evil: true, undef: true, browser: true */</span>
<span class="hljs-comment">/*globals $,require,jQuery,define,_selector_run,_selector_opts,_selector_first,_selector_row_indexes,_ext,_Api,_api_register,_api_registerPlural,_re_new_lines,_re_html,_re_formatted_numeric,_re_escape_regex,_empty,_intVal,_numToDecimal,_isNumber,_isHtml,_htmlNumeric,_pluck,_pluck_order,_range,_stripHtml,_unique,_fnBuildAjax,_fnAjaxUpdate,_fnAjaxParameters,_fnAjaxUpdateDraw,_fnAjaxDataSrc,_fnAddColumn,_fnColumnOptions,_fnAdjustColumnSizing,_fnVisibleToColumnIndex,_fnColumnIndexToVisible,_fnVisbleColumns,_fnGetColumns,_fnColumnTypes,_fnApplyColumnDefs,_fnHungarianMap,_fnCamelToHungarian,_fnLanguageCompat,_fnBrowserDetect,_fnAddData,_fnAddTr,_fnNodeToDataIndex,_fnNodeToColumnIndex,_fnGetCellData,_fnSetCellData,_fnSplitObjNotation,_fnGetObjectDataFn,_fnSetObjectDataFn,_fnGetDataMaster,_fnClearTable,_fnDeleteIndex,_fnInvalidateRow,_fnGetRowElements,_fnCreateTr,_fnBuildHead,_fnDrawHead,_fnDraw,_fnReDraw,_fnAddOptionsHtml,_fnDetectHeader,_fnGetUniqueThs,_fnFeatureHtmlFilter,_fnFilterComplete,_fnFilterCustom,_fnFilterColumn,_fnFilter,_fnFilterCreateSearch,_fnEscapeRegex,_fnFilterData,_fnFeatureHtmlInfo,_fnUpdateInfo,_fnInfoMacros,_fnInitialise,_fnInitComplete,_fnLengthChange,_fnFeatureHtmlLength,_fnFeatureHtmlPaginate,_fnPageChange,_fnFeatureHtmlProcessing,_fnProcessingDisplay,_fnFeatureHtmlTable,_fnScrollDraw,_fnApplyToChildren,_fnCalculateColumnWidths,_fnThrottle,_fnConvertToWidth,_fnScrollingWidthAdjust,_fnGetWidestNode,_fnGetMaxLenString,_fnStringToCss,_fnScrollBarWidth,_fnSortFlatten,_fnSort,_fnSortAria,_fnSortListener,_fnSortAttachListener,_fnSortingClasses,_fnSortData,_fnSaveState,_fnLoadState,_fnSettingsFromNode,_fnLog,_fnMap,_fnBindAction,_fnCallbackReg,_fnCallbackFire,_fnLengthOverflow,_fnRenderer,_fnDataSource,_fnRowAttributes*/</span>

(<span class="hljs-comment">/** @lends &lt;global&gt; */</span><span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( window, document, undefined )</span> {</span>

(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( factory )</span> {</span>
<span class="hljs-pi">	"use strict"</span>;

	<span class="hljs-keyword">if</span> ( <span class="hljs-keyword">typeof</span> define === <span class="hljs-string">'function'</span> &amp;&amp; define.amd ) {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Define as an AMD module if possible</p></div></div><div class="code"><div class="wrapper">		define( <span class="hljs-string">'datatables'</span>, [<span class="hljs-string">'jquery'</span>], factory );
	}
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( <span class="hljs-keyword">typeof</span> exports === <span class="hljs-string">'object'</span> ) {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Node/CommonJS</p></div></div><div class="code"><div class="wrapper">        factory( <span class="hljs-built_in">require</span>( <span class="hljs-string">'jquery'</span> ) );
    }
	<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( jQuery &amp;&amp; !jQuery.fn.dataTable ) {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Define using browser globals otherwise
Prevent multiple instantiations if the script is loaded twice</p></div></div><div class="code"><div class="wrapper">		factory( jQuery );
	}
}
(<span class="hljs-comment">/** @lends &lt;global&gt; */</span><span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( $ )</span> {</span>
<span class="hljs-pi">	"use strict"</span>;</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>DataTables is a plug-in for the jQuery Javascript library. It is a highly
flexible tool, based upon the foundations of progressive enhancement,
which will add advanced interaction controls to any HTML table. For a
full list of features please refer to
<a href="href=&quot;http://datatables.net">DataTables.net</a>.</p>
<p>Note that the <code>DataTable</code> object is not a global variable but is aliased
to <code>jQuery.fn.DataTable</code> and <code>jQuery.fn.dataTable</code> through which it may
be  accessed.</p>
<p> @class
 @param {object} [init={}] Configuration object for DataTables. Options
   are defined by {@link DataTable.defaults}
 @requires jQuery 1.7+</p>
<p> @example
   // Basic initialisation
   $(document).ready( function {
     $(&#39;#example&#39;).dataTable();
   } );</p>
<p> @example
   // Initialisation with configuration options - in this case, disable
   // pagination and sorting.
   $(document).ready( function {
     $(&#39;#example&#39;).dataTable( {
       &quot;paginate&quot;: false,
       &quot;sort&quot;: false
     } );
   } );</p></div></div><div class="code"><div class="wrapper">	<span class="hljs-keyword">var</span> DataTable;

	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>It is useful to have variables which are scoped locally so only the
DataTables functions can access them and they don&#39;t leak into global space.
At the same time these functions are often useful over multiple files in the
core and API, so we list, or at least document, all variables which are used
by DataTables as private variables here. This also ensures that there is no
clashing of variable names and that they can easily referenced for reuse.</p></div></div><div class="code"><div class="wrapper">	
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Defined else where
 _selector_run
 _selector_opts
 _selector_first
 _selector_row_indexes</p></div></div><div class="code"><div class="wrapper">	
	<span class="hljs-keyword">var</span> _ext; <span class="hljs-comment">// DataTable.ext</span>
	<span class="hljs-keyword">var</span> _Api; <span class="hljs-comment">// DataTable.Api</span>
	<span class="hljs-keyword">var</span> _api_register; <span class="hljs-comment">// DataTable.Api.register</span>
	<span class="hljs-keyword">var</span> _api_registerPlural; <span class="hljs-comment">// DataTable.Api.registerPlural</span>
	
	<span class="hljs-keyword">var</span> _re_dic = {};
	<span class="hljs-keyword">var</span> _re_new_lines = <span class="hljs-regexp">/[\r\n]/g</span>;
	<span class="hljs-keyword">var</span> _re_html = <span class="hljs-regexp">/&lt;.*?&gt;/g</span>;
	<span class="hljs-keyword">var</span> _re_date_start = <span class="hljs-regexp">/^[\w\+\-]/</span>;
	<span class="hljs-keyword">var</span> _re_date_end = <span class="hljs-regexp">/[\w\+\-]$/</span>;
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Escape regular expression special characters</p></div></div><div class="code"><div class="wrapper">	<span class="hljs-keyword">var</span> _re_escape_regex = <span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>( <span class="hljs-string">'(\\'</span> + [ <span class="hljs-string">'/'</span>, <span class="hljs-string">'.'</span>, <span class="hljs-string">'*'</span>, <span class="hljs-string">'+'</span>, <span class="hljs-string">'?'</span>, <span class="hljs-string">'|'</span>, <span class="hljs-string">'('</span>, <span class="hljs-string">')'</span>, <span class="hljs-string">'['</span>, <span class="hljs-string">']'</span>, <span class="hljs-string">'{'</span>, <span class="hljs-string">'}'</span>, <span class="hljs-string">'\\'</span>, <span class="hljs-string">'$'</span>, <span class="hljs-string">'^'</span>, <span class="hljs-string">'-'</span> ].join(<span class="hljs-string">'|\\'</span>) + <span class="hljs-string">')'</span>, <span class="hljs-string">'g'</span> );
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>U+2009 is thin space and U+202F is narrow no-break space, both used in many
standards as thousands separators</p></div></div><div class="code"><div class="wrapper">	<span class="hljs-keyword">var</span> _re_formatted_numeric = <span class="hljs-regexp">/[',$Â£â¬Â¥%\u2009\u202F]/g</span>;
	
	
	<span class="hljs-keyword">var</span> _empty = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">( d )</span> {</span>
		<span class="hljs-keyword">return</span> !d || d === <span class="hljs-literal">true</span> || d === <span class="hljs-string">'-'</span> ? <span class="hljs-literal">true</span> : <span class="hljs-literal">false</span>;
	};
	
	
	<span class="hljs-keyword">var</span> _intVal = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">( s )</span> {</span>
		<span class="hljs-keyword">var</span> integer = <span class="hljs-built_in">parseInt</span>( s, <span class="hljs-number">10</span> );
		<span class="hljs-keyword">return</span> !<span class="hljs-built_in">isNaN</span>(integer) &amp;&amp; <span class="hljs-built_in">isFinite</span>(s) ? integer : <span class="hljs-literal">null</span>;
	};
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Convert from a formatted number with characters other than <code>.</code> as the
decimal place, to a Javascript number</p></div></div><div class="code"><div class="wrapper">	<span class="hljs-keyword">var</span> _numToDecimal = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">( num, decimalPoint )</span> {</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Cache created regular expressions for speed as this function is called often</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-keyword">if</span> ( ! _re_dic[ decimalPoint ] ) {
			_re_dic[ decimalPoint ] = <span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>( _fnEscapeRegex( decimalPoint ), <span class="hljs-string">'g'</span> );
		}
		<span class="hljs-keyword">return</span> <span class="hljs-keyword">typeof</span> num === <span class="hljs-string">'string'</span> ?
			num.replace( <span class="hljs-regexp">/\./g</span>, <span class="hljs-string">''</span> ).replace( _re_dic[ decimalPoint ], <span class="hljs-string">'.'</span> ) :
			num;
	};
	
	
	<span class="hljs-keyword">var</span> _isNumber = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">( d, decimalPoint, formatted )</span> {</span>
		<span class="hljs-keyword">var</span> strType = <span class="hljs-keyword">typeof</span> d === <span class="hljs-string">'string'</span>;
	
		<span class="hljs-keyword">if</span> ( decimalPoint &amp;&amp; strType ) {
			d = _numToDecimal( d, decimalPoint );
		}
	
		<span class="hljs-keyword">if</span> ( formatted &amp;&amp; strType ) {
			d = d.replace( _re_formatted_numeric, <span class="hljs-string">''</span> );
		}
	
		<span class="hljs-keyword">return</span> _empty( d ) || (!<span class="hljs-built_in">isNaN</span>( <span class="hljs-built_in">parseFloat</span>(d) ) &amp;&amp; <span class="hljs-built_in">isFinite</span>( d ));
	};
	
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>A string without HTML in it can be considered to be HTML still</p></div></div><div class="code"><div class="wrapper">	<span class="hljs-keyword">var</span> _isHtml = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">( d )</span> {</span>
		<span class="hljs-keyword">return</span> _empty( d ) || <span class="hljs-keyword">typeof</span> d === <span class="hljs-string">'string'</span>;
	};
	
	
	<span class="hljs-keyword">var</span> _htmlNumeric = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">( d, decimalPoint, formatted )</span> {</span>
		<span class="hljs-keyword">if</span> ( _empty( d ) ) {
			<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
		}
	
		<span class="hljs-keyword">var</span> html = _isHtml( d );
		<span class="hljs-keyword">return</span> ! html ?
			<span class="hljs-literal">null</span> :
			_isNumber( _stripHtml( d ), decimalPoint, formatted ) ?
				<span class="hljs-literal">true</span> :
				<span class="hljs-literal">null</span>;
	};
	
	
	<span class="hljs-keyword">var</span> _pluck = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">( a, prop, prop2 )</span> {</span>
		<span class="hljs-keyword">var</span> out = [];
		<span class="hljs-keyword">var</span> i=<span class="hljs-number">0</span>, ien=a.length;
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Could have the test in the loop for slightly smaller code, but speed
is essential here</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-keyword">if</span> ( prop2 !== <span class="hljs-literal">undefined</span> ) {
			<span class="hljs-keyword">for</span> ( ; i&lt;ien ; i++ ) {
				<span class="hljs-keyword">if</span> ( a[i] &amp;&amp; a[i][ prop ] ) {
					out.push( a[i][ prop ][ prop2 ] );
				}
			}
		}
		<span class="hljs-keyword">else</span> {
			<span class="hljs-keyword">for</span> ( ; i&lt;ien ; i++ ) {
				<span class="hljs-keyword">if</span> ( a[i] ) {
					out.push( a[i][ prop ] );
				}
			}
		}
	
		<span class="hljs-keyword">return</span> out;
	};
	
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Basically the same as _pluck, but rather than looping over <code>a</code> we use <code>order</code>
as the indexes to pick from <code>a</code></p></div></div><div class="code"><div class="wrapper">	<span class="hljs-keyword">var</span> _pluck_order = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">( a, order, prop, prop2 )</span>
	{</span>
		<span class="hljs-keyword">var</span> out = [];
		<span class="hljs-keyword">var</span> i=<span class="hljs-number">0</span>, ien=order.length;
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Could have the test in the loop for slightly smaller code, but speed
is essential here</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-keyword">if</span> ( prop2 !== <span class="hljs-literal">undefined</span> ) {
			<span class="hljs-keyword">for</span> ( ; i&lt;ien ; i++ ) {
				out.push( a[ order[i] ][ prop ][ prop2 ] );
			}
		}
		<span class="hljs-keyword">else</span> {
			<span class="hljs-keyword">for</span> ( ; i&lt;ien ; i++ ) {
				out.push( a[ order[i] ][ prop ] );
			}
		}
	
		<span class="hljs-keyword">return</span> out;
	};
	
	
	<span class="hljs-keyword">var</span> _range = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">( len, start )</span>
	{</span>
		<span class="hljs-keyword">var</span> out = [];
		<span class="hljs-keyword">var</span> end;
	
		<span class="hljs-keyword">if</span> ( start === <span class="hljs-literal">undefined</span> ) {
			start = <span class="hljs-number">0</span>;
			end = len;
		}
		<span class="hljs-keyword">else</span> {
			end = start;
			start = len;
		}
	
		<span class="hljs-keyword">for</span> ( <span class="hljs-keyword">var</span> i=start ; i&lt;end ; i++ ) {
			out.push( i );
		}
	
		<span class="hljs-keyword">return</span> out;
	};
	
	
	<span class="hljs-keyword">var</span> _stripHtml = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">( d )</span> {</span>
		<span class="hljs-keyword">return</span> d.replace( _re_html, <span class="hljs-string">''</span> );
	};
	
	</div></div></div><div class="segment"><div class="comments doc-section"><div class="wrapper"><p><span class='doc-section-header'> ignore</span></p>
<p>Find the unique elements in a source array.</p>
<p>Parameters:</p>
<ul>
<li><strong>src must be an array.</strong><br/>(Source array)</li>
</ul>
<p><strong>Returns an array</strong><br/>(Array of unique items)</p></div></div><div class="code"><div class="wrapper">	<span class="hljs-keyword">var</span> _unique = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">( src )</span>
	{</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>A faster unique method is to use object keys to identify used values,
but this doesn&#39;t work with arrays or objects, which we must also
consider. See jsperf.com/compare-array-unique-versions/4 for more
information.</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-keyword">var</span>
			out = [],
			val,
			i, ien=src.length,
			j, k=<span class="hljs-number">0</span>;
	
		again: <span class="hljs-keyword">for</span> ( i=<span class="hljs-number">0</span> ; i&lt;ien ; i++ ) {
			val = src[i];
	
			<span class="hljs-keyword">for</span> ( j=<span class="hljs-number">0</span> ; j&lt;k ; j++ ) {
				<span class="hljs-keyword">if</span> ( out[j] === val ) {
					<span class="hljs-keyword">continue</span> again;
				}
			}
	
			out.push( val );
			k++;
		}
	
		<span class="hljs-keyword">return</span> out;
	};
	
	
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Create a mapping object that allows camel case parameters to be looked up
for their Hungarian counterparts. The mapping is stored in a private
parameter called <code>_hungarianMap</code> which can be accessed on the source object.
 @param {object} o
 @memberof DataTable#oApi</p></div></div><div class="code"><div class="wrapper">	<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_fnHungarianMap</span> <span class="hljs-params">( o )</span>
	{</span>
		<span class="hljs-keyword">var</span>
			hungarian = <span class="hljs-string">'a aa ai ao as b fn i m o s '</span>,
			match,
			newKey,
			map = {};
	
		$.each( o, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(key, val)</span> {</span>
			match = key.match(<span class="hljs-regexp">/^([^A-Z]+?)([A-Z])/</span>);
	
			<span class="hljs-keyword">if</span> ( match &amp;&amp; hungarian.indexOf(match[<span class="hljs-number">1</span>]+<span class="hljs-string">' '</span>) !== -<span class="hljs-number">1</span> )
			{
				newKey = key.replace( match[<span class="hljs-number">0</span>], match[<span class="hljs-number">2</span>].toLowerCase() );
				map[ newKey ] = key;
	
				<span class="hljs-comment">//console.log( key, match );</span>
				<span class="hljs-keyword">if</span> ( match[<span class="hljs-number">1</span>] === <span class="hljs-string">'o'</span> )
				{
					_fnHungarianMap( o[key] );
				}
			}
		} );
	
		o._hungarianMap = map;
	}
	
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Convert from camel case parameters to Hungarian, based on a Hungarian map
created by _fnHungarianMap.
 @param {object} src The model object which holds all parameters that can be
   mapped.
 @param {object} user The object to convert from camel case to Hungarian.
 @param {boolean} force When set to <code>true</code>, properties which already have a
   Hungarian value in the <code>user</code> object will be overwritten. Otherwise they
   won&#39;t be.
 @memberof DataTable#oApi</p></div></div><div class="code"><div class="wrapper">	<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_fnCamelToHungarian</span> <span class="hljs-params">( src, user, force )</span>
	{</span>
		<span class="hljs-keyword">if</span> ( ! src._hungarianMap ) {
			_fnHungarianMap( src );
		}
	
		<span class="hljs-keyword">var</span> hungarianKey;
	
		$.each( user, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(key, val)</span> {</span>
			hungarianKey = src._hungarianMap[ key ];
	
			<span class="hljs-keyword">if</span> ( hungarianKey !== <span class="hljs-literal">undefined</span> &amp;&amp; (force || user[hungarianKey] === <span class="hljs-literal">undefined</span>) )
			{</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>For objects, we need to buzz down into the object to copy parameters</p></div></div><div class="code"><div class="wrapper">				<span class="hljs-keyword">if</span> ( hungarianKey.charAt(<span class="hljs-number">0</span>) === <span class="hljs-string">'o'</span> )
				{</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Copy the camelCase options over to the hungarian</p></div></div><div class="code"><div class="wrapper">					<span class="hljs-keyword">if</span> ( ! user[ hungarianKey ] ) {
						user[ hungarianKey ] = {};
					}
					$.extend( <span class="hljs-literal">true</span>, user[hungarianKey], user[key] );
	
					_fnCamelToHungarian( src[hungarianKey], user[hungarianKey], force );
				}
				<span class="hljs-keyword">else</span> {
					user[hungarianKey] = user[ key ];
				}
			}
		} );
	}
	
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Language compatibility - when certain options are given, and others aren&#39;t, we
need to duplicate the values over, in order to provide backwards compatibility
with older language files.
 @param {object} oSettings dataTables settings object
 @memberof DataTable#oApi</p></div></div><div class="code"><div class="wrapper">	<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_fnLanguageCompat</span><span class="hljs-params">( lang )</span>
	{</span>
		<span class="hljs-keyword">var</span> defaults = DataTable.defaults.oLanguage;
		<span class="hljs-keyword">var</span> zeroRecords = lang.sZeroRecords;
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Backwards compatibility - if there is no sEmptyTable given, then use the same as
sZeroRecords - assuming that is given.</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-keyword">if</span> ( ! lang.sEmptyTable &amp;&amp; zeroRecords &amp;&amp;
			defaults.sEmptyTable === <span class="hljs-string">"No data available in table"</span> )
		{
			_fnMap( lang, lang, <span class="hljs-string">'sZeroRecords'</span>, <span class="hljs-string">'sEmptyTable'</span> );
		}
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Likewise with loading records </p></div></div><div class="code"><div class="wrapper">		<span class="hljs-keyword">if</span> ( ! lang.sLoadingRecords &amp;&amp; zeroRecords &amp;&amp;
			defaults.sLoadingRecords === <span class="hljs-string">"Loading..."</span> )
		{
			_fnMap( lang, lang, <span class="hljs-string">'sZeroRecords'</span>, <span class="hljs-string">'sLoadingRecords'</span> );
		}
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Old parameter name of the thousands separator mapped onto the new</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-keyword">if</span> ( lang.sInfoThousands ) {
			lang.sThousands = lang.sInfoThousands;
		}
	
		<span class="hljs-keyword">var</span> decimal = lang.sDecimal;
		<span class="hljs-keyword">if</span> ( decimal ) {
			_addNumericSort( decimal );
		}
	}
	
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Map one parameter onto another
 @param {object} o Object to map
 @param {<em>} knew The new parameter name
 @param {</em>} old The old parameter name</p></div></div><div class="code"><div class="wrapper">	<span class="hljs-keyword">var</span> _fnCompatMap = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">( o, knew, old )</span> {</span>
		<span class="hljs-keyword">if</span> ( o[ knew ] !== <span class="hljs-literal">undefined</span> ) {
			o[ old ] = o[ knew ];
		}
	};
	
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Provide backwards compatibility for the main DT options. Note that the new
options are mapped onto the old parameters, so this is an external interface
change only.
 @param {object} init Object to map</p></div></div><div class="code"><div class="wrapper">	<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_fnCompatOpts</span> <span class="hljs-params">( init )</span>
	{</span>
		_fnCompatMap( init, <span class="hljs-string">'ordering'</span>,      <span class="hljs-string">'bSort'</span> );
		_fnCompatMap( init, <span class="hljs-string">'orderMulti'</span>,    <span class="hljs-string">'bSortMulti'</span> );
		_fnCompatMap( init, <span class="hljs-string">'orderClasses'</span>,  <span class="hljs-string">'bSortClasses'</span> );
		_fnCompatMap( init, <span class="hljs-string">'orderCellsTop'</span>, <span class="hljs-string">'bSortCellsTop'</span> );
		_fnCompatMap( init, <span class="hljs-string">'order'</span>,         <span class="hljs-string">'aaSorting'</span> );
		_fnCompatMap( init, <span class="hljs-string">'orderFixed'</span>,    <span class="hljs-string">'aaSortingFixed'</span> );
		_fnCompatMap( init, <span class="hljs-string">'paging'</span>,        <span class="hljs-string">'bPaginate'</span> );
		_fnCompatMap( init, <span class="hljs-string">'pagingType'</span>,    <span class="hljs-string">'sPaginationType'</span> );
		_fnCompatMap( init, <span class="hljs-string">'pageLength'</span>,    <span class="hljs-string">'iDisplayLength'</span> );
		_fnCompatMap( init, <span class="hljs-string">'searching'</span>,     <span class="hljs-string">'bFilter'</span> );
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Column search objects are in an array, so it needs to be converted
element by element</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-keyword">var</span> searchCols = init.aoSearchCols;
	
		<span class="hljs-keyword">if</span> ( searchCols ) {
			<span class="hljs-keyword">for</span> ( <span class="hljs-keyword">var</span> i=<span class="hljs-number">0</span>, ien=searchCols.length ; i&lt;ien ; i++ ) {
				<span class="hljs-keyword">if</span> ( searchCols[i] ) {
					_fnCamelToHungarian( DataTable.models.oSearch, searchCols[i] );
				}
			}
		}
	}
	
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Provide backwards compatibility for column options. Note that the new options
are mapped onto the old parameters, so this is an external interface change
only.
 @param {object} init Object to map</p></div></div><div class="code"><div class="wrapper">	<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_fnCompatCols</span> <span class="hljs-params">( init )</span>
	{</span>
		_fnCompatMap( init, <span class="hljs-string">'orderable'</span>,     <span class="hljs-string">'bSortable'</span> );
		_fnCompatMap( init, <span class="hljs-string">'orderData'</span>,     <span class="hljs-string">'aDataSort'</span> );
		_fnCompatMap( init, <span class="hljs-string">'orderSequence'</span>, <span class="hljs-string">'asSorting'</span> );
		_fnCompatMap( init, <span class="hljs-string">'orderDataType'</span>, <span class="hljs-string">'sortDataType'</span> );
	}
	
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Browser feature detection for capabilities, quirks
 @param {object} settings dataTables settings object
 @memberof DataTable#oApi</p></div></div><div class="code"><div class="wrapper">	<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_fnBrowserDetect</span><span class="hljs-params">( settings )</span>
	{</span>
		<span class="hljs-keyword">var</span> browser = settings.oBrowser;
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Scrolling feature / quirks detection</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-keyword">var</span> n = $(<span class="hljs-string">'&lt;div/&gt;'</span>)
			.css( {
				position: <span class="hljs-string">'absolute'</span>,
				top: <span class="hljs-number">0</span>,
				left: <span class="hljs-number">0</span>,
				height: <span class="hljs-number">1</span>,
				width: <span class="hljs-number">1</span>,
				overflow: <span class="hljs-string">'hidden'</span>
			} )
			.append(
				$(<span class="hljs-string">'&lt;div/&gt;'</span>)
					.css( {
						position: <span class="hljs-string">'absolute'</span>,
						top: <span class="hljs-number">1</span>,
						left: <span class="hljs-number">1</span>,
						width: <span class="hljs-number">100</span>,
						overflow: <span class="hljs-string">'scroll'</span>
					} )
					.append(
						$(<span class="hljs-string">'&lt;div class="test"/&gt;'</span>)
							.css( {
								width: <span class="hljs-string">'100%'</span>,
								height: <span class="hljs-number">10</span>
							} )
					)
			)
			.appendTo( <span class="hljs-string">'body'</span> );
	
		<span class="hljs-keyword">var</span> test = n.find(<span class="hljs-string">'.test'</span>);
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>IE6/7 will oversize a width 100% element inside a scrolling element, to
include the width of the scrollbar, while other browsers ensure the inner
element is contained without forcing scrolling</p></div></div><div class="code"><div class="wrapper">		browser.bScrollOversize = test[<span class="hljs-number">0</span>].offsetWidth === <span class="hljs-number">100</span>;
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>In rtl text layout, some browsers (most, but not all) will place the
scrollbar on the left, rather than the right.</p></div></div><div class="code"><div class="wrapper">		browser.bScrollbarLeft = test.offset().left !== <span class="hljs-number">1</span>;
	
		n.remove();
	}
	
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Array.prototype reduce[Right] method, used for browsers which don&#39;t support
JS 1.6. Done this way to reduce code size, since we iterate either way
 @param {object} settings dataTables settings object
 @memberof DataTable#oApi</p></div></div><div class="code"><div class="wrapper">	<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_fnReduce</span> <span class="hljs-params">( that, fn, init, start, end, inc )</span>
	{</span>
		<span class="hljs-keyword">var</span>
			i = start,
			value,
			isSet = <span class="hljs-literal">false</span>;
	
		<span class="hljs-keyword">if</span> ( init !== <span class="hljs-literal">undefined</span> ) {
			value = init;
			isSet = <span class="hljs-literal">true</span>;
		}
	
		<span class="hljs-keyword">while</span> ( i !== end ) {
			<span class="hljs-keyword">if</span> ( ! that.hasOwnProperty(i) ) {
				<span class="hljs-keyword">continue</span>;
			}
	
			value = isSet ?
				fn( value, that[i], i, that ) :
				that[i];
	
			isSet = <span class="hljs-literal">true</span>;
			i += inc;
		}
	
		<span class="hljs-keyword">return</span> value;
	}
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Add a column to the list used for the table with default values
 @param {object} oSettings dataTables settings object
 @param {node} nTh The th element for this column
 @memberof DataTable#oApi</p></div></div><div class="code"><div class="wrapper">	<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_fnAddColumn</span><span class="hljs-params">( oSettings, nTh )</span>
	{</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Add column to aoColumns array</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-keyword">var</span> oDefaults = DataTable.defaults.column;
		<span class="hljs-keyword">var</span> iCol = oSettings.aoColumns.length;
		<span class="hljs-keyword">var</span> oCol = $.extend( {}, DataTable.models.oColumn, oDefaults, {
			<span class="hljs-string">"nTh"</span>: nTh ? nTh : document.createElement(<span class="hljs-string">'th'</span>),
			<span class="hljs-string">"sTitle"</span>:    oDefaults.sTitle    ? oDefaults.sTitle    : nTh ? nTh.innerHTML : <span class="hljs-string">''</span>,
			<span class="hljs-string">"aDataSort"</span>: oDefaults.aDataSort ? oDefaults.aDataSort : [iCol],
			<span class="hljs-string">"mData"</span>: oDefaults.mData ? oDefaults.mData : iCol,
			idx: iCol
		} );
		oSettings.aoColumns.push( oCol );
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Add search object for column specific search. Note that the <code>searchCols[ iCol ]</code>
passed into extend can be undefined. This allows the user to give a default
with only some of the parameters defined, and also not give a default</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-keyword">var</span> searchCols = oSettings.aoPreSearchCols;
		searchCols[ iCol ] = $.extend( {}, DataTable.models.oSearch, searchCols[ iCol ] );
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Use the default column options function to initialise classes etc</p></div></div><div class="code"><div class="wrapper">		_fnColumnOptions( oSettings, iCol, <span class="hljs-literal">null</span> );
	}
	
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Apply options for a column
 @param {object} oSettings dataTables settings object
 @param {int} iCol column index to consider
 @param {object} oOptions object with sType, bVisible and bSearchable etc
 @memberof DataTable#oApi</p></div></div><div class="code"><div class="wrapper">	<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_fnColumnOptions</span><span class="hljs-params">( oSettings, iCol, oOptions )</span>
	{</span>
		<span class="hljs-keyword">var</span> oCol = oSettings.aoColumns[ iCol ];
		<span class="hljs-keyword">var</span> oClasses = oSettings.oClasses;
		<span class="hljs-keyword">var</span> th = $(oCol.nTh);
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Try to get width information from the DOM. We can&#39;t get it from CSS
as we&#39;d need to parse the CSS stylesheet. <code>width</code> option can override</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-keyword">if</span> ( ! oCol.sWidthOrig ) {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Width attribute</p></div></div><div class="code"><div class="wrapper">			oCol.sWidthOrig = th.attr(<span class="hljs-string">'width'</span>) || <span class="hljs-literal">null</span>;
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Style attribute</p></div></div><div class="code"><div class="wrapper">			<span class="hljs-keyword">var</span> t = (th.attr(<span class="hljs-string">'style'</span>) || <span class="hljs-string">''</span>).match(<span class="hljs-regexp">/width:\s*(\d+[pxem%]+)/</span>);
			<span class="hljs-keyword">if</span> ( t ) {
				oCol.sWidthOrig = t[<span class="hljs-number">1</span>];
			}
		}
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>User specified column options </p></div></div><div class="code"><div class="wrapper">		<span class="hljs-keyword">if</span> ( oOptions !== <span class="hljs-literal">undefined</span> &amp;&amp; oOptions !== <span class="hljs-literal">null</span> )
		{</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Backwards compatibility</p></div></div><div class="code"><div class="wrapper">			_fnCompatCols( oOptions );
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Map camel case parameters to their Hungarian counterparts</p></div></div><div class="code"><div class="wrapper">			_fnCamelToHungarian( DataTable.defaults.column, oOptions );
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Backwards compatibility for mDataProp </p></div></div><div class="code"><div class="wrapper">			<span class="hljs-keyword">if</span> ( oOptions.mDataProp !== <span class="hljs-literal">undefined</span> &amp;&amp; !oOptions.mData )
			{
				oOptions.mData = oOptions.mDataProp;
			}
	
			<span class="hljs-keyword">if</span> ( oOptions.sType )
			{
				oCol._sManualType = oOptions.sType;
			}
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p><code>class</code> is a reserved word in Javascript, so we need to provide
the ability to use a valid name for the camel case input</p></div></div><div class="code"><div class="wrapper">			<span class="hljs-keyword">if</span> ( oOptions.className &amp;&amp; ! oOptions.sClass )
			{
				oOptions.sClass = oOptions.className;
			}
	
			$.extend( oCol, oOptions );
			_fnMap( oCol, oOptions, <span class="hljs-string">"sWidth"</span>, <span class="hljs-string">"sWidthOrig"</span> );
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>iDataSort to be applied (backwards compatibility), but aDataSort will take
priority if defined</p></div></div><div class="code"><div class="wrapper">			<span class="hljs-keyword">if</span> ( <span class="hljs-keyword">typeof</span> oOptions.iDataSort === <span class="hljs-string">'number'</span> )
			{
				oCol.aDataSort = [ oOptions.iDataSort ];
			}
			_fnMap( oCol, oOptions, <span class="hljs-string">"aDataSort"</span> );
		}
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Cache the data get and set functions for speed </p></div></div><div class="code"><div class="wrapper">		<span class="hljs-keyword">var</span> mDataSrc = oCol.mData;
		<span class="hljs-keyword">var</span> mData = _fnGetObjectDataFn( mDataSrc );
		<span class="hljs-keyword">var</span> mRender = oCol.mRender ? _fnGetObjectDataFn( oCol.mRender ) : <span class="hljs-literal">null</span>;
	
		<span class="hljs-keyword">var</span> attrTest = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( src )</span> {</span>
			<span class="hljs-keyword">return</span> <span class="hljs-keyword">typeof</span> src === <span class="hljs-string">'string'</span> &amp;&amp; src.indexOf(<span class="hljs-string">'@'</span>) !== -<span class="hljs-number">1</span>;
		};
		oCol._bAttrSrc = $.isPlainObject( mDataSrc ) &amp;&amp; (
			attrTest(mDataSrc.sort) || attrTest(mDataSrc.type) || attrTest(mDataSrc.filter)
		);
	
		oCol.fnGetData = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(rowData, type, meta)</span> {</span>
			<span class="hljs-keyword">var</span> innerData = mData( rowData, type, <span class="hljs-literal">undefined</span>, meta );
	
			<span class="hljs-keyword">return</span> mRender &amp;&amp; type ?
				mRender( innerData, type, rowData, meta ) :
				innerData;
		};
		oCol.fnSetData = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">( rowData, val, meta )</span> {</span>
			<span class="hljs-keyword">return</span> _fnSetObjectDataFn( mDataSrc )( rowData, val, meta );
		};
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Feature sorting overrides column specific when off </p></div></div><div class="code"><div class="wrapper">		<span class="hljs-keyword">if</span> ( !oSettings.oFeatures.bSort )
		{
			oCol.bSortable = <span class="hljs-literal">false</span>;
			th.addClass( oClasses.sSortableNone ); <span class="hljs-comment">// Have to add class here as order event isn't called</span>
		}
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Check that the class assignment is correct for sorting </p></div></div><div class="code"><div class="wrapper">		<span class="hljs-keyword">var</span> bAsc = $.inArray(<span class="hljs-string">'asc'</span>, oCol.asSorting) !== -<span class="hljs-number">1</span>;
		<span class="hljs-keyword">var</span> bDesc = $.inArray(<span class="hljs-string">'desc'</span>, oCol.asSorting) !== -<span class="hljs-number">1</span>;
		<span class="hljs-keyword">if</span> ( !oCol.bSortable || (!bAsc &amp;&amp; !bDesc) )
		{
			oCol.sSortingClass = oClasses.sSortableNone;
			oCol.sSortingClassJUI = <span class="hljs-string">""</span>;
		}
		<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( bAsc &amp;&amp; !bDesc )
		{
			oCol.sSortingClass = oClasses.sSortableAsc;
			oCol.sSortingClassJUI = oClasses.sSortJUIAscAllowed;
		}
		<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( !bAsc &amp;&amp; bDesc )
		{
			oCol.sSortingClass = oClasses.sSortableDesc;
			oCol.sSortingClassJUI = oClasses.sSortJUIDescAllowed;
		}
		<span class="hljs-keyword">else</span>
		{
			oCol.sSortingClass = oClasses.sSortable;
			oCol.sSortingClassJUI = oClasses.sSortJUI;
		}
	}
	
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Adjust the table column widths for new data. Note: you would probably want to
do a redraw after calling this function!
 @param {object} settings dataTables settings object
 @memberof DataTable#oApi</p></div></div><div class="code"><div class="wrapper">	<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_fnAdjustColumnSizing</span> <span class="hljs-params">( settings )</span>
	{</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Not interested in doing column width calculation if auto-width is disabled </p></div></div><div class="code"><div class="wrapper">		<span class="hljs-keyword">if</span> ( settings.oFeatures.bAutoWidth !== <span class="hljs-literal">false</span> )
		{
			<span class="hljs-keyword">var</span> columns = settings.aoColumns;
	
			_fnCalculateColumnWidths( settings );
			<span class="hljs-keyword">for</span> ( <span class="hljs-keyword">var</span> i=<span class="hljs-number">0</span> , iLen=columns.length ; i&lt;iLen ; i++ )
			{
				columns[i].nTh.style.width = columns[i].sWidth;
			}
		}
	
		<span class="hljs-keyword">var</span> scroll = settings.oScroll;
		<span class="hljs-keyword">if</span> ( scroll.sY !== <span class="hljs-string">''</span> || scroll.sX !== <span class="hljs-string">''</span>)
		{
			_fnScrollDraw( settings );
		}
	
		_fnCallbackFire( settings, <span class="hljs-literal">null</span>, <span class="hljs-string">'column-sizing'</span>, [settings] );
	}
	
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Covert the index of a visible column to the index in the data array (take account
of hidden columns)
 @param {object} oSettings dataTables settings object
 @param {int} iMatch Visible column index to lookup
 @returns {int} i the data index
 @memberof DataTable#oApi</p></div></div><div class="code"><div class="wrapper">	<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_fnVisibleToColumnIndex</span><span class="hljs-params">( oSettings, iMatch )</span>
	{</span>
		<span class="hljs-keyword">var</span> aiVis = _fnGetColumns( oSettings, <span class="hljs-string">'bVisible'</span> );
	
		<span class="hljs-keyword">return</span> <span class="hljs-keyword">typeof</span> aiVis[iMatch] === <span class="hljs-string">'number'</span> ?
			aiVis[iMatch] :
			<span class="hljs-literal">null</span>;
	}
	
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Covert the index of an index in the data array and convert it to the visible
  column index (take account of hidden columns)
 @param {int} iMatch Column index to lookup
 @param {object} oSettings dataTables settings object
 @returns {int} i the data index
 @memberof DataTable#oApi</p></div></div><div class="code"><div class="wrapper">	<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_fnColumnIndexToVisible</span><span class="hljs-params">( oSettings, iMatch )</span>
	{</span>
		<span class="hljs-keyword">var</span> aiVis = _fnGetColumns( oSettings, <span class="hljs-string">'bVisible'</span> );
		<span class="hljs-keyword">var</span> iPos = $.inArray( iMatch, aiVis );
	
		<span class="hljs-keyword">return</span> iPos !== -<span class="hljs-number">1</span> ? iPos : <span class="hljs-literal">null</span>;
	}
	
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Get the number of visible columns
 @param {object} oSettings dataTables settings object
 @returns {int} i the number of visible columns
 @memberof DataTable#oApi</p></div></div><div class="code"><div class="wrapper">	<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_fnVisbleColumns</span><span class="hljs-params">( oSettings )</span>
	{</span>
		<span class="hljs-keyword">return</span> _fnGetColumns( oSettings, <span class="hljs-string">'bVisible'</span> ).length;
	}
	
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Get an array of column indexes that match a given property
 @param {object} oSettings dataTables settings object
 @param {string} sParam Parameter in aoColumns to look for - typically
   bVisible or bSearchable
 @returns {array} Array of indexes with matched properties
 @memberof DataTable#oApi</p></div></div><div class="code"><div class="wrapper">	<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_fnGetColumns</span><span class="hljs-params">( oSettings, sParam )</span>
	{</span>
		<span class="hljs-keyword">var</span> a = [];
	
		$.map( oSettings.aoColumns, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(val, i)</span> {</span>
			<span class="hljs-keyword">if</span> ( val[sParam] ) {
				a.push( i );
			}
		} );
	
		<span class="hljs-keyword">return</span> a;
	}
	
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Calculate the &#39;type&#39; of a column
 @param {object} settings dataTables settings object
 @memberof DataTable#oApi</p></div></div><div class="code"><div class="wrapper">	<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_fnColumnTypes</span> <span class="hljs-params">( settings )</span>
	{</span>
		<span class="hljs-keyword">var</span> columns = settings.aoColumns;
		<span class="hljs-keyword">var</span> data = settings.aoData;
		<span class="hljs-keyword">var</span> types = DataTable.ext.type.detect;
		<span class="hljs-keyword">var</span> i, ien, j, jen, k, ken;
		<span class="hljs-keyword">var</span> col, cell, detectedType, cache;
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>For each column, spin over the </p></div></div><div class="code"><div class="wrapper">		<span class="hljs-keyword">for</span> ( i=<span class="hljs-number">0</span>, ien=columns.length ; i&lt;ien ; i++ ) {
			col = columns[i];
			cache = [];
	
			<span class="hljs-keyword">if</span> ( ! col.sType &amp;&amp; col._sManualType ) {
				col.sType = col._sManualType;
			}
			<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( ! col.sType ) {
				<span class="hljs-keyword">for</span> ( j=<span class="hljs-number">0</span>, jen=types.length ; j&lt;jen ; j++ ) {
					<span class="hljs-keyword">for</span> ( k=<span class="hljs-number">0</span>, ken=data.length ; k&lt;ken ; k++ ) {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Use a cache array so we only need to get the type data
from the formatter once (when using multiple detectors)</p></div></div><div class="code"><div class="wrapper">						<span class="hljs-keyword">if</span> ( cache[k] === <span class="hljs-literal">undefined</span> ) {
							cache[k] = _fnGetCellData( settings, k, i, <span class="hljs-string">'type'</span> );
						}
	
						detectedType = types[j]( cache[k], settings );
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Doesn&#39;t match, so break early, since this type can&#39;t
apply to this column. Also, HTML is a special case since
it is so similar to <code>string</code>. Just a single match is
needed for a column to be html type</p></div></div><div class="code"><div class="wrapper">						<span class="hljs-keyword">if</span> ( ! detectedType || detectedType === <span class="hljs-string">'html'</span> ) {
							<span class="hljs-keyword">break</span>;
						}
					}
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Type is valid for all data points in the column - use this
type</p></div></div><div class="code"><div class="wrapper">					<span class="hljs-keyword">if</span> ( detectedType ) {
						col.sType = detectedType;
						<span class="hljs-keyword">break</span>;
					}
				}
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Fall back - if no type was detected, always use string</p></div></div><div class="code"><div class="wrapper">				<span class="hljs-keyword">if</span> ( ! col.sType ) {
					col.sType = <span class="hljs-string">'string'</span>;
				}
			}
		}
	}
	
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Take the column definitions and static columns arrays and calculate how
they relate to column indexes. The callback function will then apply the
definition found for a column to a suitable configuration object.
 @param {object} oSettings dataTables settings object
 @param {array} aoColDefs The aoColumnDefs array that is to be applied
 @param {array} aoCols The aoColumns array that defines columns individually
 @param {function} fn Callback function - takes two parameters, the calculated
   column index and the definition for that column.
 @memberof DataTable#oApi</p></div></div><div class="code"><div class="wrapper">	<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_fnApplyColumnDefs</span><span class="hljs-params">( oSettings, aoColDefs, aoCols, fn )</span>
	{</span>
		<span class="hljs-keyword">var</span> i, iLen, j, jLen, k, kLen, def;
		<span class="hljs-keyword">var</span> columns = oSettings.aoColumns;
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Column definitions with aTargets</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-keyword">if</span> ( aoColDefs )
		{</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Loop over the definitions array - loop in reverse so first instance has priority </p></div></div><div class="code"><div class="wrapper">			<span class="hljs-keyword">for</span> ( i=aoColDefs.length-<span class="hljs-number">1</span> ; i&gt;=<span class="hljs-number">0</span> ; i-- )
			{
				def = aoColDefs[i];
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Each definition can target multiple columns, as it is an array </p></div></div><div class="code"><div class="wrapper">				<span class="hljs-keyword">var</span> aTargets = def.targets !== <span class="hljs-literal">undefined</span> ?
					def.targets :
					def.aTargets;
	
				<span class="hljs-keyword">if</span> ( ! $.isArray( aTargets ) )
				{
					aTargets = [ aTargets ];
				}
	
				<span class="hljs-keyword">for</span> ( j=<span class="hljs-number">0</span>, jLen=aTargets.length ; j&lt;jLen ; j++ )
				{
					<span class="hljs-keyword">if</span> ( <span class="hljs-keyword">typeof</span> aTargets[j] === <span class="hljs-string">'number'</span> &amp;&amp; aTargets[j] &gt;= <span class="hljs-number">0</span> )
					{</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Add columns that we don&#39;t yet know about </p></div></div><div class="code"><div class="wrapper">						<span class="hljs-keyword">while</span>( columns.length &lt;= aTargets[j] )
						{
							_fnAddColumn( oSettings );
						}
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Integer, basic index </p></div></div><div class="code"><div class="wrapper">						fn( aTargets[j], def );
					}
					<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( <span class="hljs-keyword">typeof</span> aTargets[j] === <span class="hljs-string">'number'</span> &amp;&amp; aTargets[j] &lt; <span class="hljs-number">0</span> )
					{</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Negative integer, right to left column counting </p></div></div><div class="code"><div class="wrapper">						fn( columns.length+aTargets[j], def );
					}
					<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( <span class="hljs-keyword">typeof</span> aTargets[j] === <span class="hljs-string">'string'</span> )
					{</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Class name matching on TH element </p></div></div><div class="code"><div class="wrapper">						<span class="hljs-keyword">for</span> ( k=<span class="hljs-number">0</span>, kLen=columns.length ; k&lt;kLen ; k++ )
						{
							<span class="hljs-keyword">if</span> ( aTargets[j] == <span class="hljs-string">"_all"</span> ||
							     $(columns[k].nTh).hasClass( aTargets[j] ) )
							{
								fn( k, def );
							}
						}
					}
				}
			}
		}
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Statically defined columns array</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-keyword">if</span> ( aoCols )
		{
			<span class="hljs-keyword">for</span> ( i=<span class="hljs-number">0</span>, iLen=aoCols.length ; i&lt;iLen ; i++ )
			{
				fn( i, aoCols[i] );
			}
		}
	}
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Add a data array to the table, creating DOM node etc. This is the parallel to
_fnGatherData, but for adding rows from a Javascript source, rather than a
DOM source.
 @param {object} oSettings dataTables settings object
 @param {array} aData data array to be added
 @param {node} [nTr] TR element to add to the table - optional. If not given,
   DataTables will create a row automatically
 @param {array} [anTds] Array of TD|TH elements for the row - must be given
   if nTr is.
 @returns {int} &gt;=0 if successful (index of new aoData entry), -1 if failed
 @memberof DataTable#oApi</p></div></div><div class="code"><div class="wrapper">	<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_fnAddData</span> <span class="hljs-params">( oSettings, aDataIn, nTr, anTds )</span>
	{</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Create the object for storing information about this new row </p></div></div><div class="code"><div class="wrapper">		<span class="hljs-keyword">var</span> iRow = oSettings.aoData.length;
		<span class="hljs-keyword">var</span> oData = $.extend( <span class="hljs-literal">true</span>, {}, DataTable.models.oRow, {
			src: nTr ? <span class="hljs-string">'dom'</span> : <span class="hljs-string">'data'</span>
		} );
	
		oData._aData = aDataIn;
		oSettings.aoData.push( oData );
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Create the cells </p></div></div><div class="code"><div class="wrapper">		<span class="hljs-keyword">var</span> nTd, sThisType;
		<span class="hljs-keyword">var</span> columns = oSettings.aoColumns;
		<span class="hljs-keyword">for</span> ( <span class="hljs-keyword">var</span> i=<span class="hljs-number">0</span>, iLen=columns.length ; i&lt;iLen ; i++ )
		{</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>When working with a row, the data source object must be populated. In
all other cases, the data source object is already populated, so we
don&#39;t overwrite it, which might break bindings etc</p></div></div><div class="code"><div class="wrapper">			<span class="hljs-keyword">if</span> ( nTr ) {
				_fnSetCellData( oSettings, iRow, i, _fnGetCellData( oSettings, iRow, i ) );
			}
			columns[i].sType = <span class="hljs-literal">null</span>;
		}
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Add to the display array </p></div></div><div class="code"><div class="wrapper">		oSettings.aiDisplayMaster.push( iRow );
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Create the DOM information, or register it if already present </p></div></div><div class="code"><div class="wrapper">		<span class="hljs-keyword">if</span> ( nTr || ! oSettings.oFeatures.bDeferRender )
		{
			_fnCreateTr( oSettings, iRow, nTr, anTds );
		}
	
		<span class="hljs-keyword">return</span> iRow;
	}
	
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Add one or more TR elements to the table. Generally we&#39;d expect to
use this for reading data from a DOM sourced table, but it could be
used for an TR element. Note that if a TR is given, it is used (i.e.
it is not cloned).
 @param {object} settings dataTables settings object
 @param {array|node|jQuery} trs The TR element(s) to add to the table
 @returns {array} Array of indexes for the added rows
 @memberof DataTable#oApi</p></div></div><div class="code"><div class="wrapper">	<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_fnAddTr</span><span class="hljs-params">( settings, trs )</span>
	{</span>
		<span class="hljs-keyword">var</span> row;
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Allow an individual node to be passed in</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-keyword">if</span> ( ! (trs <span class="hljs-keyword">instanceof</span> $) ) {
			trs = $(trs);
		}
	
		<span class="hljs-keyword">return</span> trs.map( <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(i, el)</span> {</span>
			row = _fnGetRowElements( settings, el );
			<span class="hljs-keyword">return</span> _fnAddData( settings, row.data, el, row.cells );
		} );
	}
	
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Take a TR element and convert it to an index in aoData
 @param {object} oSettings dataTables settings object
 @param {node} n the TR element to find
 @returns {int} index if the node is found, null if not
 @memberof DataTable#oApi</p></div></div><div class="code"><div class="wrapper">	<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_fnNodeToDataIndex</span><span class="hljs-params">( oSettings, n )</span>
	{</span>
		<span class="hljs-keyword">return</span> (n._DT_RowIndex!==<span class="hljs-literal">undefined</span>) ? n._DT_RowIndex : <span class="hljs-literal">null</span>;
	}
	
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Take a TD element and convert it into a column data index (not the visible index)
 @param {object} oSettings dataTables settings object
 @param {int} iRow The row number the TD/TH can be found in
 @param {node} n The TD/TH element to find
 @returns {int} index if the node is found, -1 if not
 @memberof DataTable#oApi</p></div></div><div class="code"><div class="wrapper">	<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_fnNodeToColumnIndex</span><span class="hljs-params">( oSettings, iRow, n )</span>
	{</span>
		<span class="hljs-keyword">return</span> $.inArray( n, oSettings.aoData[ iRow ].anCells );
	}
	
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Get the data for a given cell from the internal cache, taking into account data mapping
 @param {object} settings dataTables settings object
 @param {int} rowIdx aoData row id
 @param {int} colIdx Column index
 @param {string} type data get type (&#39;display&#39;, &#39;type&#39; &#39;filter&#39; &#39;sort&#39;)
 @returns {*} Cell data
 @memberof DataTable#oApi</p></div></div><div class="code"><div class="wrapper">	<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_fnGetCellData</span><span class="hljs-params">( settings, rowIdx, colIdx, type )</span>
	{</span>
		<span class="hljs-keyword">var</span> draw           = settings.iDraw;
		<span class="hljs-keyword">var</span> col            = settings.aoColumns[colIdx];
		<span class="hljs-keyword">var</span> rowData        = settings.aoData[rowIdx]._aData;
		<span class="hljs-keyword">var</span> defaultContent = col.sDefaultContent;
		<span class="hljs-keyword">var</span> cellData       = col.fnGetData( rowData, type, {
			settings: settings,
			row:      rowIdx,
			col:      colIdx
		} );
	
		<span class="hljs-keyword">if</span> ( cellData === <span class="hljs-literal">undefined</span> ) {
			<span class="hljs-keyword">if</span> ( settings.iDrawError != draw &amp;&amp; defaultContent === <span class="hljs-literal">null</span> ) {
				_fnLog( settings, <span class="hljs-number">0</span>, <span class="hljs-string">"Requested unknown parameter "</span>+
					(<span class="hljs-keyword">typeof</span> col.mData==<span class="hljs-string">'function'</span> ? <span class="hljs-string">'{function}'</span> : <span class="hljs-string">"'"</span>+col.mData+<span class="hljs-string">"'"</span>)+
					<span class="hljs-string">" for row "</span>+rowIdx, <span class="hljs-number">4</span> );
				settings.iDrawError = draw;
			}
			<span class="hljs-keyword">return</span> defaultContent;
		}
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>When the data source is null, we can use default column data </p></div></div><div class="code"><div class="wrapper">		<span class="hljs-keyword">if</span> ( (cellData === rowData || cellData === <span class="hljs-literal">null</span>) &amp;&amp; defaultContent !== <span class="hljs-literal">null</span> ) {
			cellData = defaultContent;
		}
		<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( <span class="hljs-keyword">typeof</span> cellData === <span class="hljs-string">'function'</span> ) {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>If the data source is a function, then we run it and use the return,
executing in the scope of the data object (for instances)</p></div></div><div class="code"><div class="wrapper">			<span class="hljs-keyword">return</span> cellData.call( rowData );
		}
	
		<span class="hljs-keyword">if</span> ( cellData === <span class="hljs-literal">null</span> &amp;&amp; type == <span class="hljs-string">'display'</span> ) {
			<span class="hljs-keyword">return</span> <span class="hljs-string">''</span>;
		}
		<span class="hljs-keyword">return</span> cellData;
	}
	
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Set the value for a specific cell, into the internal data cache
 @param {object} settings dataTables settings object
 @param {int} rowIdx aoData row id
 @param {int} colIdx Column index
 @param {*} val Value to set
 @memberof DataTable#oApi</p></div></div><div class="code"><div class="wrapper">	<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_fnSetCellData</span><span class="hljs-params">( settings, rowIdx, colIdx, val )</span>
	{</span>
		<span class="hljs-keyword">var</span> col     = settings.aoColumns[colIdx];
		<span class="hljs-keyword">var</span> rowData = settings.aoData[rowIdx]._aData;
	
		col.fnSetData( rowData, val, {
			settings: settings,
			row:      rowIdx,
			col:      colIdx
		}  );
	}
	
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Private variable that is used to match action syntax in the data property object</p></div></div><div class="code"><div class="wrapper">	<span class="hljs-keyword">var</span> __reArray = <span class="hljs-regexp">/\[.*?\]$/</span>;
	<span class="hljs-keyword">var</span> __reFn = <span class="hljs-regexp">/\(\)$/</span>;
	</div></div></div><div class="segment"><div class="comments doc-section"><div class="wrapper"><p>Split string on periods, taking into account escaped periods</p>
<p>Parameters:</p>
<ul>
<li><strong>str must be a string.</strong><br/>(String to split)</li>
</ul>
<p><strong>Returns an array</strong><br/>(Split string)</p></div></div><div class="code"><div class="wrapper">	<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_fnSplitObjNotation</span><span class="hljs-params">( str )</span>
	{</span>
		<span class="hljs-keyword">return</span> $.map( str.match(<span class="hljs-regexp">/(\\.|[^\.])+/g</span>), <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">( s )</span> {</span>
			<span class="hljs-keyword">return</span> s.replace(<span class="hljs-regexp">/\\./g</span>, <span class="hljs-string">'.'</span>);
		} );
	}
	
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Return a function that can be used to get data from a source object, taking
into account the ability to use nested objects as a source
 @param {string|int|function} mSource The data source for the object
 @returns {function} Data get function
 @memberof DataTable#oApi</p></div></div><div class="code"><div class="wrapper">	<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_fnGetObjectDataFn</span><span class="hljs-params">( mSource )</span>
	{</span>
		<span class="hljs-keyword">if</span> ( $.isPlainObject( mSource ) )
		{</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Build an object of get functions, and wrap them in a single call </p></div></div><div class="code"><div class="wrapper">			<span class="hljs-keyword">var</span> o = {};
			$.each( mSource, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(key, val)</span> {</span>
				<span class="hljs-keyword">if</span> ( val ) {
					o[key] = _fnGetObjectDataFn( val );
				}
			} );
	
			<span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(data, type, row, meta)</span> {</span>
				<span class="hljs-keyword">var</span> t = o[type] || o._;
				<span class="hljs-keyword">return</span> t !== <span class="hljs-literal">undefined</span> ?
					t(data, type, row, meta) :
					data;
			};
		}
		<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( mSource === <span class="hljs-literal">null</span> )
		{</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Give an empty string for rendering / sorting etc </p></div></div><div class="code"><div class="wrapper">			<span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(data)</span> {</span> <span class="hljs-comment">// type, row and meta also passed, but not used</span>
				<span class="hljs-keyword">return</span> data;
			};
		}
		<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( <span class="hljs-keyword">typeof</span> mSource === <span class="hljs-string">'function'</span> )
		{
			<span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(data, type, row, meta)</span> {</span>
				<span class="hljs-keyword">return</span> mSource( data, type, row, meta );
			};
		}
		<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( <span class="hljs-keyword">typeof</span> mSource === <span class="hljs-string">'string'</span> &amp;&amp; (mSource.indexOf(<span class="hljs-string">'.'</span>) !== -<span class="hljs-number">1</span> ||
			      mSource.indexOf(<span class="hljs-string">'['</span>) !== -<span class="hljs-number">1</span> || mSource.indexOf(<span class="hljs-string">'('</span>) !== -<span class="hljs-number">1</span>) )
		{</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>If there is a . in the source string then the data source is in a
nested object so we loop over the data for each level to get the next
level down. On each loop we test for undefined, and if found immediately
return. This allows entire objects to be missing and sDefaultContent to
be used if defined, rather than throwing an error</p></div></div><div class="code"><div class="wrapper">			<span class="hljs-keyword">var</span> fetchData = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(data, type, src)</span> {</span>
				<span class="hljs-keyword">var</span> arrayNotation, funcNotation, out, innerSrc;
	
				<span class="hljs-keyword">if</span> ( src !== <span class="hljs-string">""</span> )
				{
					<span class="hljs-keyword">var</span> a = _fnSplitObjNotation( src );
	
					<span class="hljs-keyword">for</span> ( <span class="hljs-keyword">var</span> i=<span class="hljs-number">0</span>, iLen=a.length ; i&lt;iLen ; i++ )
					{</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Check if we are dealing with special notation</p></div></div><div class="code"><div class="wrapper">						arrayNotation = a[i].match(__reArray);
						funcNotation = a[i].match(__reFn);
	
						<span class="hljs-keyword">if</span> ( arrayNotation )
						{</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Array notation</p></div></div><div class="code"><div class="wrapper">							a[i] = a[i].replace(__reArray, <span class="hljs-string">''</span>);
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Condition allows simply [] to be passed in</p></div></div><div class="code"><div class="wrapper">							<span class="hljs-keyword">if</span> ( a[i] !== <span class="hljs-string">""</span> ) {
								data = data[ a[i] ];
							}
							out = [];
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Get the remainder of the nested object to get</p></div></div><div class="code"><div class="wrapper">							a.splice( <span class="hljs-number">0</span>, i+<span class="hljs-number">1</span> );
							innerSrc = a.join(<span class="hljs-string">'.'</span>);
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Traverse each entry in the array getting the properties requested</p></div></div><div class="code"><div class="wrapper">							<span class="hljs-keyword">for</span> ( <span class="hljs-keyword">var</span> j=<span class="hljs-number">0</span>, jLen=data.length ; j&lt;jLen ; j++ ) {
								out.push( fetchData( data[j], type, innerSrc ) );
							}
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>If a string is given in between the array notation indicators, that
is used to join the strings together, otherwise an array is returned</p></div></div><div class="code"><div class="wrapper">							<span class="hljs-keyword">var</span> join = arrayNotation[<span class="hljs-number">0</span>].substring(<span class="hljs-number">1</span>, arrayNotation[<span class="hljs-number">0</span>].length-<span class="hljs-number">1</span>);
							data = (join===<span class="hljs-string">""</span>) ? out : out.join(join);
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>The inner call to fetchData has already traversed through the remainder
of the source requested, so we exit from the loop</p></div></div><div class="code"><div class="wrapper">							<span class="hljs-keyword">break</span>;
						}
						<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( funcNotation )
						{</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Function call</p></div></div><div class="code"><div class="wrapper">							a[i] = a[i].replace(__reFn, <span class="hljs-string">''</span>);
							data = data[ a[i] ]();
							<span class="hljs-keyword">continue</span>;
						}
	
						<span class="hljs-keyword">if</span> ( data === <span class="hljs-literal">null</span> || data[ a[i] ] === <span class="hljs-literal">undefined</span> )
						{
							<span class="hljs-keyword">return</span> <span class="hljs-literal">undefined</span>;
						}
						data = data[ a[i] ];
					}
				}
	
				<span class="hljs-keyword">return</span> data;
			};
	
			<span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(data, type)</span> {</span> <span class="hljs-comment">// row and meta also passed, but not used</span>
				<span class="hljs-keyword">return</span> fetchData( data, type, mSource );
			};
		}
		<span class="hljs-keyword">else</span>
		{</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Array or flat object mapping </p></div></div><div class="code"><div class="wrapper">			<span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(data, type)</span> {</span> <span class="hljs-comment">// row and meta also passed, but not used</span>
				<span class="hljs-keyword">return</span> data[mSource];
			};
		}
	}
	
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Return a function that can be used to set data from a source object, taking
into account the ability to use nested objects as a source
 @param {string|int|function} mSource The data source for the object
 @returns {function} Data set function
 @memberof DataTable#oApi</p></div></div><div class="code"><div class="wrapper">	<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_fnSetObjectDataFn</span><span class="hljs-params">( mSource )</span>
	{</span>
		<span class="hljs-keyword">if</span> ( $.isPlainObject( mSource ) )
		{</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Unlike get, only the underscore (global) option is used for for
setting data since we don&#39;t know the type here. This is why an object
option is not documented for <code>mData</code> (which is read/write), but it is
for <code>mRender</code> which is read only.</p></div></div><div class="code"><div class="wrapper">			<span class="hljs-keyword">return</span> _fnSetObjectDataFn( mSource._ );
		}
		<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( mSource === <span class="hljs-literal">null</span> )
		{</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Nothing to do when the data source is null </p></div></div><div class="code"><div class="wrapper">			<span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>};
		}
		<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( <span class="hljs-keyword">typeof</span> mSource === <span class="hljs-string">'function'</span> )
		{
			<span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(data, val, meta)</span> {</span>
				mSource( data, <span class="hljs-string">'set'</span>, val, meta );
			};
		}
		<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( <span class="hljs-keyword">typeof</span> mSource === <span class="hljs-string">'string'</span> &amp;&amp; (mSource.indexOf(<span class="hljs-string">'.'</span>) !== -<span class="hljs-number">1</span> ||
			      mSource.indexOf(<span class="hljs-string">'['</span>) !== -<span class="hljs-number">1</span> || mSource.indexOf(<span class="hljs-string">'('</span>) !== -<span class="hljs-number">1</span>) )
		{</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Like the get, we need to get data from a nested object </p></div></div><div class="code"><div class="wrapper">			<span class="hljs-keyword">var</span> setData = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(data, val, src)</span> {</span>
				<span class="hljs-keyword">var</span> a = _fnSplitObjNotation( src ), b;
				<span class="hljs-keyword">var</span> aLast = a[a.length-<span class="hljs-number">1</span>];
				<span class="hljs-keyword">var</span> arrayNotation, funcNotation, o, innerSrc;
	
				<span class="hljs-keyword">for</span> ( <span class="hljs-keyword">var</span> i=<span class="hljs-number">0</span>, iLen=a.length-<span class="hljs-number">1</span> ; i&lt;iLen ; i++ )
				{</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Check if we are dealing with an array notation request</p></div></div><div class="code"><div class="wrapper">					arrayNotation = a[i].match(__reArray);
					funcNotation = a[i].match(__reFn);
	
					<span class="hljs-keyword">if</span> ( arrayNotation )
					{
						a[i] = a[i].replace(__reArray, <span class="hljs-string">''</span>);
						data[ a[i] ] = [];
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Get the remainder of the nested object to set so we can recurse</p></div></div><div class="code"><div class="wrapper">						b = a.slice();
						b.splice( <span class="hljs-number">0</span>, i+<span class="hljs-number">1</span> );
						innerSrc = b.join(<span class="hljs-string">'.'</span>);
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Traverse each entry in the array setting the properties requested</p></div></div><div class="code"><div class="wrapper">						<span class="hljs-keyword">for</span> ( <span class="hljs-keyword">var</span> j=<span class="hljs-number">0</span>, jLen=val.length ; j&lt;jLen ; j++ )
						{
							o = {};
							setData( o, val[j], innerSrc );
							data[ a[i] ].push( o );
						}
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>The inner call to setData has already traversed through the remainder
of the source and has set the data, thus we can exit here</p></div></div><div class="code"><div class="wrapper">						<span class="hljs-keyword">return</span>;
					}
					<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( funcNotation )
					{</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Function call</p></div></div><div class="code"><div class="wrapper">						a[i] = a[i].replace(__reFn, <span class="hljs-string">''</span>);
						data = data[ a[i] ]( val );
					}
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>If the nested object doesn&#39;t currently exist - since we are
trying to set the value - create it</p></div></div><div class="code"><div class="wrapper">					<span class="hljs-keyword">if</span> ( data[ a[i] ] === <span class="hljs-literal">null</span> || data[ a[i] ] === <span class="hljs-literal">undefined</span> )
					{
						data[ a[i] ] = {};
					}
					data = data[ a[i] ];
				}
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Last item in the input - i.e, the actual set</p></div></div><div class="code"><div class="wrapper">				<span class="hljs-keyword">if</span> ( aLast.match(__reFn ) )
				{</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Function call</p></div></div><div class="code"><div class="wrapper">					data = data[ aLast.replace(__reFn, <span class="hljs-string">''</span>) ]( val );
				}
				<span class="hljs-keyword">else</span>
				{</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>If array notation is used, we just want to strip it and use the property name
and assign the value. If it isn&#39;t used, then we get the result we want anyway</p></div></div><div class="code"><div class="wrapper">					data[ aLast.replace(__reArray, <span class="hljs-string">''</span>) ] = val;
				}
			};
	
			<span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(data, val)</span> {</span> <span class="hljs-comment">// meta is also passed in, but not used</span>
				<span class="hljs-keyword">return</span> setData( data, val, mSource );
			};
		}
		<span class="hljs-keyword">else</span>
		{</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Array or flat object mapping </p></div></div><div class="code"><div class="wrapper">			<span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(data, val)</span> {</span> <span class="hljs-comment">// meta is also passed in, but not used</span>
				data[mSource] = val;
			};
		}
	}
	
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Return an array with the full table data
 @param {object} oSettings dataTables settings object
 @returns array {array} aData Master data array
 @memberof DataTable#oApi</p></div></div><div class="code"><div class="wrapper">	<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_fnGetDataMaster</span> <span class="hljs-params">( settings )</span>
	{</span>
		<span class="hljs-keyword">return</span> _pluck( settings.aoData, <span class="hljs-string">'_aData'</span> );
	}
	
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Nuke the table
 @param {object} oSettings dataTables settings object
 @memberof DataTable#oApi</p></div></div><div class="code"><div class="wrapper">	<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_fnClearTable</span><span class="hljs-params">( settings )</span>
	{</span>
		settings.aoData.length = <span class="hljs-number">0</span>;
		settings.aiDisplayMaster.length = <span class="hljs-number">0</span>;
		settings.aiDisplay.length = <span class="hljs-number">0</span>;
	}
	
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Take an array of integers (index array) and remove a target integer (value - not
the key!)
 @param {array} a Index array to target
 @param {int} iTarget value to find
 @memberof DataTable#oApi</p></div></div><div class="code"><div class="wrapper">	<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_fnDeleteIndex</span><span class="hljs-params">( a, iTarget, splice )</span>
	{</span>
		<span class="hljs-keyword">var</span> iTargetIndex = -<span class="hljs-number">1</span>;
	
		<span class="hljs-keyword">for</span> ( <span class="hljs-keyword">var</span> i=<span class="hljs-number">0</span>, iLen=a.length ; i&lt;iLen ; i++ )
		{
			<span class="hljs-keyword">if</span> ( a[i] == iTarget )
			{
				iTargetIndex = i;
			}
			<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( a[i] &gt; iTarget )
			{
				a[i]--;
			}
		}
	
		<span class="hljs-keyword">if</span> ( iTargetIndex != -<span class="hljs-number">1</span> &amp;&amp; splice === <span class="hljs-literal">undefined</span> )
		{
			a.splice( iTargetIndex, <span class="hljs-number">1</span> );
		}
	}
	
	</div></div></div><div class="segment"><div class="comments doc-section"><div class="wrapper"><p><span class='doc-section-header'> memberof DataTable#oApi</span></p>
<p>Mark cached data as invalid such that a re-read of the data will occur when
the cached data is next requested. Also update from the data source object.</p>
<p>TODO: For the modularisation of v1.11 this will need to become a callback, so
  the sort and filter methods can subscribe to it. That will required
  initialisation options for sorting, which is why it is not already baked in</p>
<p>Parameters:</p>
<ul>
<li><p><strong>settings must be an object.</strong><br/>(DataTables settings object)</p>
</li>
<li><p><strong>rowIdx must be an int.</strong><br/>(Row index to invalidate)</p>
</li>
</ul></div></div><div class="code"><div class="wrapper">	<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_fnInvalidateRow</span><span class="hljs-params">( settings, rowIdx, src, column )</span>
	{</span>
		<span class="hljs-keyword">var</span> row = settings.aoData[ rowIdx ];
		<span class="hljs-keyword">var</span> i, ien;
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Are we reading last data from DOM or the data object?</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-keyword">if</span> ( src === <span class="hljs-string">'dom'</span> || ((! src || src === <span class="hljs-string">'auto'</span>) &amp;&amp; row.src === <span class="hljs-string">'dom'</span>) ) {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Read the data from the DOM</p></div></div><div class="code"><div class="wrapper">			row._aData = _fnGetRowElements( settings, row ).data;
		}
		<span class="hljs-keyword">else</span> {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Reading from data object, update the DOM</p></div></div><div class="code"><div class="wrapper">			<span class="hljs-keyword">var</span> cells = row.anCells;
			<span class="hljs-keyword">var</span> cell;
	
			<span class="hljs-keyword">if</span> ( cells ) {
				<span class="hljs-keyword">for</span> ( i=<span class="hljs-number">0</span>, ien=cells.length ; i&lt;ien ; i++ ) {
					cell = cells[i];
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>This is very frustrating, but in IE if you just write directly
to innerHTML, and elements that are overwritten are GC&#39;ed,
even if there is a reference to them elsewhere</p></div></div><div class="code"><div class="wrapper">					<span class="hljs-keyword">while</span> ( cell.childNodes.length ) {
						cell.removeChild( cell.firstChild );
					}
	
					cells[i].innerHTML = _fnGetCellData( settings, rowIdx, i, <span class="hljs-string">'display'</span> );
				}
			}
		}
	
		row._aSortData = <span class="hljs-literal">null</span>;
		row._aFilterData = <span class="hljs-literal">null</span>;
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Invalidate the type for a specific column (if given) or all columns since
the data might have changed</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-keyword">var</span> cols = settings.aoColumns;
		<span class="hljs-keyword">if</span> ( column !== <span class="hljs-literal">undefined</span> ) {
			cols[ column ].sType = <span class="hljs-literal">null</span>;
		}
		<span class="hljs-keyword">else</span> {
			<span class="hljs-keyword">for</span> ( i=<span class="hljs-number">0</span>, ien=cols.length ; i&lt;ien ; i++ ) {
				cols[i].sType = <span class="hljs-literal">null</span>;
			}
		}
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Update DataTables special <code>DT_*</code> attributes for the row</p></div></div><div class="code"><div class="wrapper">		_fnRowAttributes( row );
	}
	
	</div></div></div><div class="segment"><div class="comments doc-section"><div class="wrapper"><p><span class='doc-section-header'> memberof DataTable#oApi</span></p>
<p>Build a data source object from an HTML row, reading the contents of the
cells that are in the row.</p>
<p>Parameters:</p>
<ul>
<li><p><strong>settings must be an object.</strong><br/>(DataTables settings object)</p>
</li>
<li><p><strong>TR can be a node or an object.</strong><br/>(element from which to read data or existing row object from which to re-read the data from the cells)</p>
</li>
</ul>
<p><strong>Returns an object</strong><br/>(Object with two parameters: <code>data</code> the data read, in document order, and <code>cells</code> and array of nodes (they can be useful to the caller, so rather than needing a second traversal to get them, just return them from here).)</p></div></div><div class="code"><div class="wrapper">	<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_fnGetRowElements</span><span class="hljs-params">( settings, row )</span>
	{</span>
		<span class="hljs-keyword">var</span>
			d = [],
			tds = [],
			td = row.firstChild,
			name, col, o, i=<span class="hljs-number">0</span>, contents,
			columns = settings.aoColumns;
	
		<span class="hljs-keyword">var</span> attr = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">( str, data, td  )</span> {</span>
			<span class="hljs-keyword">if</span> ( <span class="hljs-keyword">typeof</span> str === <span class="hljs-string">'string'</span> ) {
				<span class="hljs-keyword">var</span> idx = str.indexOf(<span class="hljs-string">'@'</span>);
	
				<span class="hljs-keyword">if</span> ( idx !== -<span class="hljs-number">1</span> ) {
					<span class="hljs-keyword">var</span> src = str.substring( idx+<span class="hljs-number">1</span> );
					o[ <span class="hljs-string">'@'</span>+src ] = td.getAttribute( src );
				}
			}
		};
	
		<span class="hljs-keyword">var</span> cellProcess = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">( cell )</span> {</span>
			col = columns[i];
			contents = $.trim(cell.innerHTML);
	
			<span class="hljs-keyword">if</span> ( col &amp;&amp; col._bAttrSrc ) {
				o = {
					display: contents
				};
	
				attr( col.mData.sort, o, cell );
				attr( col.mData.type, o, cell );
				attr( col.mData.filter, o, cell );
	
				d.push( o );
			}
			<span class="hljs-keyword">else</span> {
				d.push( contents );
			}
	
			i++;
		};
	
		<span class="hljs-keyword">if</span> ( td ) {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p><code>tr</code> element passed in</p></div></div><div class="code"><div class="wrapper">			<span class="hljs-keyword">while</span> ( td ) {
				name = td.nodeName.toUpperCase();
	
				<span class="hljs-keyword">if</span> ( name == <span class="hljs-string">"TD"</span> || name == <span class="hljs-string">"TH"</span> ) {
					cellProcess( td );
					tds.push( td );
				}
	
				td = td.nextSibling;
			}
		}
		<span class="hljs-keyword">else</span> {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Existing row object passed in</p></div></div><div class="code"><div class="wrapper">			tds = row.anCells;
			
			<span class="hljs-keyword">for</span> ( <span class="hljs-keyword">var</span> j=<span class="hljs-number">0</span>, jen=tds.length ; j&lt;jen ; j++ ) {
				cellProcess( tds[j] );
			}
		}
	
		<span class="hljs-keyword">return</span> {
			data: d,
			cells: tds
		};
	}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Create a new TR element (and it&#39;s TD children) for a row
 @param {object} oSettings dataTables settings object
 @param {int} iRow Row to consider
 @param {node} [nTrIn] TR element to add to the table - optional. If not given,
   DataTables will create a row automatically
 @param {array} [anTds] Array of TD|TH elements for the row - must be given
   if nTr is.
 @memberof DataTable#oApi</p></div></div><div class="code"><div class="wrapper">	<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_fnCreateTr</span> <span class="hljs-params">( oSettings, iRow, nTrIn, anTds )</span>
	{</span>
		<span class="hljs-keyword">var</span>
			row = oSettings.aoData[iRow],
			rowData = row._aData,
			cells = [],
			nTr, nTd, oCol,
			i, iLen;
	
		<span class="hljs-keyword">if</span> ( row.nTr === <span class="hljs-literal">null</span> )
		{
			nTr = nTrIn || document.createElement(<span class="hljs-string">'tr'</span>);
	
			row.nTr = nTr;
			row.anCells = cells;
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Use a private property on the node to allow reserve mapping from the node
to the aoData array for fast look up</p></div></div><div class="code"><div class="wrapper">			nTr._DT_RowIndex = iRow;
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Special parameters can be given by the data source to be used on the row </p></div></div><div class="code"><div class="wrapper">			_fnRowAttributes( row );
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Process each column </p></div></div><div class="code"><div class="wrapper">			<span class="hljs-keyword">for</span> ( i=<span class="hljs-number">0</span>, iLen=oSettings.aoColumns.length ; i&lt;iLen ; i++ )
			{
				oCol = oSettings.aoColumns[i];
	
				nTd = nTrIn ? anTds[i] : document.createElement( oCol.sCellType );
				cells.push( nTd );
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Need to create the HTML if new, or if a rendering function is defined</p></div></div><div class="code"><div class="wrapper">				<span class="hljs-keyword">if</span> ( !nTrIn || oCol.mRender || oCol.mData !== i )
				{
					nTd.innerHTML = _fnGetCellData( oSettings, iRow, i, <span class="hljs-string">'display'</span> );
				}
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Add user defined class </p></div></div><div class="code"><div class="wrapper">				<span class="hljs-keyword">if</span> ( oCol.sClass )
				{
					nTd.className += <span class="hljs-string">' '</span>+oCol.sClass;
				}
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Visibility - add or remove as required</p></div></div><div class="code"><div class="wrapper">				<span class="hljs-keyword">if</span> ( oCol.bVisible &amp;&amp; ! nTrIn )
				{
					nTr.appendChild( nTd );
				}
				<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( ! oCol.bVisible &amp;&amp; nTrIn )
				{
					nTd.parentNode.removeChild( nTd );
				}
	
				<span class="hljs-keyword">if</span> ( oCol.fnCreatedCell )
				{
					oCol.fnCreatedCell.call( oSettings.oInstance,
						nTd, _fnGetCellData( oSettings, iRow, i ), rowData, iRow, i
					);
				}
			}
	
			_fnCallbackFire( oSettings, <span class="hljs-string">'aoRowCreatedCallback'</span>, <span class="hljs-literal">null</span>, [nTr, rowData, iRow] );
		}
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Remove once webkit bug 131819 and Chromium bug 365619 have been resolved
and deployed</p></div></div><div class="code"><div class="wrapper">		row.nTr.setAttribute( <span class="hljs-string">'role'</span>, <span class="hljs-string">'row'</span> );
	}
	
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Add attributes to a row based on the special <code>DT_*</code> parameters in a data
source object.
 @param {object} DataTables row object for the row to be modified
 @memberof DataTable#oApi</p></div></div><div class="code"><div class="wrapper">	<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_fnRowAttributes</span><span class="hljs-params">( row )</span>
	{</span>
		<span class="hljs-keyword">var</span> tr = row.nTr;
		<span class="hljs-keyword">var</span> data = row._aData;
	
		<span class="hljs-keyword">if</span> ( tr ) {
			<span class="hljs-keyword">if</span> ( data.DT_RowId ) {
				tr.id = data.DT_RowId;
			}
	
			<span class="hljs-keyword">if</span> ( data.DT_RowClass ) {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Remove any classes added by DT_RowClass before</p></div></div><div class="code"><div class="wrapper">				<span class="hljs-keyword">var</span> a = data.DT_RowClass.split(<span class="hljs-string">' '</span>);
				row.__rowc = row.__rowc ?
					_unique( row.__rowc.concat( a ) ) :
					a;
	
				$(tr)
					.removeClass( row.__rowc.join(<span class="hljs-string">' '</span>) )
					.addClass( data.DT_RowClass );
			}
	
			<span class="hljs-keyword">if</span> ( data.DT_RowData ) {
				$(tr).data( data.DT_RowData );
			}
		}
	}
	
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Create the HTML header for the table
 @param {object} oSettings dataTables settings object
 @memberof DataTable#oApi</p></div></div><div class="code"><div class="wrapper">	<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_fnBuildHead</span><span class="hljs-params">( oSettings )</span>
	{</span>
		<span class="hljs-keyword">var</span> i, ien, cell, row, column;
		<span class="hljs-keyword">var</span> thead = oSettings.nTHead;
		<span class="hljs-keyword">var</span> tfoot = oSettings.nTFoot;
		<span class="hljs-keyword">var</span> createHeader = $(<span class="hljs-string">'th, td'</span>, thead).length === <span class="hljs-number">0</span>;
		<span class="hljs-keyword">var</span> classes = oSettings.oClasses;
		<span class="hljs-keyword">var</span> columns = oSettings.aoColumns;
	
		<span class="hljs-keyword">if</span> ( createHeader ) {
			row = $(<span class="hljs-string">'&lt;tr/&gt;'</span>).appendTo( thead );
		}
	
		<span class="hljs-keyword">for</span> ( i=<span class="hljs-number">0</span>, ien=columns.length ; i&lt;ien ; i++ ) {
			column = columns[i];
			cell = $( column.nTh ).addClass( column.sClass );
	
			<span class="hljs-keyword">if</span> ( createHeader ) {
				cell.appendTo( row );
			}
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>1.11 move into sorting</p></div></div><div class="code"><div class="wrapper">			<span class="hljs-keyword">if</span> ( oSettings.oFeatures.bSort ) {
				cell.addClass( column.sSortingClass );
	
				<span class="hljs-keyword">if</span> ( column.bSortable !== <span class="hljs-literal">false</span> ) {
					cell
						.attr( <span class="hljs-string">'tabindex'</span>, oSettings.iTabIndex )
						.attr( <span class="hljs-string">'aria-controls'</span>, oSettings.sTableId );
	
					_fnSortAttachListener( oSettings, column.nTh, i );
				}
			}
	
			<span class="hljs-keyword">if</span> ( column.sTitle != cell.html() ) {
				cell.html( column.sTitle );
			}
	
			_fnRenderer( oSettings, <span class="hljs-string">'header'</span> )(
				oSettings, cell, column, classes
			);
		}
	
		<span class="hljs-keyword">if</span> ( createHeader ) {
			_fnDetectHeader( oSettings.aoHeader, thead );
		}
		</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>ARIA role for the rows </p></div></div><div class="code"><div class="wrapper">	 	$(thead).find(<span class="hljs-string">'&gt;tr'</span>).attr(<span class="hljs-string">'role'</span>, <span class="hljs-string">'row'</span>);
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Deal with the footer - add classes if required </p></div></div><div class="code"><div class="wrapper">		$(thead).find(<span class="hljs-string">'&gt;tr&gt;th, &gt;tr&gt;td'</span>).addClass( classes.sHeaderTH );
		$(tfoot).find(<span class="hljs-string">'&gt;tr&gt;th, &gt;tr&gt;td'</span>).addClass( classes.sFooterTH );
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Cache the footer cells. Note that we only take the cells from the first
row in the footer. If there is more than one row the user wants to
interact with, they need to use the table().foot() method. Note also this
allows cells to be used for multiple columns using colspan</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-keyword">if</span> ( tfoot !== <span class="hljs-literal">null</span> ) {
			<span class="hljs-keyword">var</span> cells = oSettings.aoFooter[<span class="hljs-number">0</span>];
	
			<span class="hljs-keyword">for</span> ( i=<span class="hljs-number">0</span>, ien=cells.length ; i&lt;ien ; i++ ) {
				column = columns[i];
				column.nTf = cells[i].cell;
	
				<span class="hljs-keyword">if</span> ( column.sClass ) {
					$(column.nTf).addClass( column.sClass );
				}
			}
		}
	}
	
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Draw the header (or footer) element based on the column visibility states. The
methodology here is to use the layout array from _fnDetectHeader, modified for
the instantaneous column visibility, to construct the new layout. The grid is
traversed over cell at a time in a rows x columns grid fashion, although each
cell insert can cover multiple elements in the grid - which is tracks using the
aApplied array. Cell inserts in the grid will only occur where there isn&#39;t
already a cell in that position.
 @param {object} oSettings dataTables settings object
 @param array {objects} aoSource Layout array from _fnDetectHeader
 @param {boolean} [bIncludeHidden=false] If true then include the hidden columns in the calc,
 @memberof DataTable#oApi</p></div></div><div class="code"><div class="wrapper">	<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_fnDrawHead</span><span class="hljs-params">( oSettings, aoSource, bIncludeHidden )</span>
	{</span>
		<span class="hljs-keyword">var</span> i, iLen, j, jLen, k, kLen, n, nLocalTr;
		<span class="hljs-keyword">var</span> aoLocal = [];
		<span class="hljs-keyword">var</span> aApplied = [];
		<span class="hljs-keyword">var</span> iColumns = oSettings.aoColumns.length;
		<span class="hljs-keyword">var</span> iRowspan, iColspan;
	
		<span class="hljs-keyword">if</span> ( ! aoSource )
		{
			<span class="hljs-keyword">return</span>;
		}
	
		<span class="hljs-keyword">if</span> (  bIncludeHidden === <span class="hljs-literal">undefined</span> )
		{
			bIncludeHidden = <span class="hljs-literal">false</span>;
		}
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Make a copy of the master layout array, but without the visible columns in it </p></div></div><div class="code"><div class="wrapper">		<span class="hljs-keyword">for</span> ( i=<span class="hljs-number">0</span>, iLen=aoSource.length ; i&lt;iLen ; i++ )
		{
			aoLocal[i] = aoSource[i].slice();
			aoLocal[i].nTr = aoSource[i].nTr;
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Remove any columns which are currently hidden </p></div></div><div class="code"><div class="wrapper">			<span class="hljs-keyword">for</span> ( j=iColumns-<span class="hljs-number">1</span> ; j&gt;=<span class="hljs-number">0</span> ; j-- )
			{
				<span class="hljs-keyword">if</span> ( !oSettings.aoColumns[j].bVisible &amp;&amp; !bIncludeHidden )
				{
					aoLocal[i].splice( j, <span class="hljs-number">1</span> );
				}
			}
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Prep the applied array - it needs an element for each row </p></div></div><div class="code"><div class="wrapper">			aApplied.push( [] );
		}
	
		<span class="hljs-keyword">for</span> ( i=<span class="hljs-number">0</span>, iLen=aoLocal.length ; i&lt;iLen ; i++ )
		{
			nLocalTr = aoLocal[i].nTr;
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>All cells are going to be replaced, so empty out the row </p></div></div><div class="code"><div class="wrapper">			<span class="hljs-keyword">if</span> ( nLocalTr )
			{
				<span class="hljs-keyword">while</span>( (n = nLocalTr.firstChild) )
				{
					nLocalTr.removeChild( n );
				}
			}
	
			<span class="hljs-keyword">for</span> ( j=<span class="hljs-number">0</span>, jLen=aoLocal[i].length ; j&lt;jLen ; j++ )
			{
				iRowspan = <span class="hljs-number">1</span>;
				iColspan = <span class="hljs-number">1</span>;
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Check to see if there is already a cell (row/colspan) covering our target
insert point. If there is, then there is nothing to do.</p></div></div><div class="code"><div class="wrapper">				<span class="hljs-keyword">if</span> ( aApplied[i][j] === <span class="hljs-literal">undefined</span> )
				{
					nLocalTr.appendChild( aoLocal[i][j].cell );
					aApplied[i][j] = <span class="hljs-number">1</span>;
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Expand the cell to cover as many rows as needed </p></div></div><div class="code"><div class="wrapper">					<span class="hljs-keyword">while</span> ( aoLocal[i+iRowspan] !== <span class="hljs-literal">undefined</span> &amp;&amp;
					        aoLocal[i][j].cell == aoLocal[i+iRowspan][j].cell )
					{
						aApplied[i+iRowspan][j] = <span class="hljs-number">1</span>;
						iRowspan++;
					}
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Expand the cell to cover as many columns as needed </p></div></div><div class="code"><div class="wrapper">					<span class="hljs-keyword">while</span> ( aoLocal[i][j+iColspan] !== <span class="hljs-literal">undefined</span> &amp;&amp;
					        aoLocal[i][j].cell == aoLocal[i][j+iColspan].cell )
					{</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Must update the applied array over the rows for the columns </p></div></div><div class="code"><div class="wrapper">						<span class="hljs-keyword">for</span> ( k=<span class="hljs-number">0</span> ; k&lt;iRowspan ; k++ )
						{
							aApplied[i+k][j+iColspan] = <span class="hljs-number">1</span>;
						}
						iColspan++;
					}
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Do the actual expansion in the DOM </p></div></div><div class="code"><div class="wrapper">					$(aoLocal[i][j].cell)
						.attr(<span class="hljs-string">'rowspan'</span>, iRowspan)
						.attr(<span class="hljs-string">'colspan'</span>, iColspan);
				}
			}
		}
	}
	
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Insert the required TR nodes into the table for display
 @param {object} oSettings dataTables settings object
 @memberof DataTable#oApi</p></div></div><div class="code"><div class="wrapper">	<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_fnDraw</span><span class="hljs-params">( oSettings )</span>
	{</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Provide a pre-callback function which can be used to cancel the draw is false is returned </p></div></div><div class="code"><div class="wrapper">		<span class="hljs-keyword">var</span> aPreDraw = _fnCallbackFire( oSettings, <span class="hljs-string">'aoPreDrawCallback'</span>, <span class="hljs-string">'preDraw'</span>, [oSettings] );
		<span class="hljs-keyword">if</span> ( $.inArray( <span class="hljs-literal">false</span>, aPreDraw ) !== -<span class="hljs-number">1</span> )
		{
			_fnProcessingDisplay( oSettings, <span class="hljs-literal">false</span> );
			<span class="hljs-keyword">return</span>;
		}
	
		<span class="hljs-keyword">var</span> i, iLen, n;
		<span class="hljs-keyword">var</span> anRows = [];
		<span class="hljs-keyword">var</span> iRowCount = <span class="hljs-number">0</span>;
		<span class="hljs-keyword">var</span> asStripeClasses = oSettings.asStripeClasses;
		<span class="hljs-keyword">var</span> iStripes = asStripeClasses.length;
		<span class="hljs-keyword">var</span> iOpenRows = oSettings.aoOpenRows.length;
		<span class="hljs-keyword">var</span> oLang = oSettings.oLanguage;
		<span class="hljs-keyword">var</span> iInitDisplayStart = oSettings.iInitDisplayStart;
		<span class="hljs-keyword">var</span> bServerSide = _fnDataSource( oSettings ) == <span class="hljs-string">'ssp'</span>;
		<span class="hljs-keyword">var</span> aiDisplay = oSettings.aiDisplay;
	
		oSettings.bDrawing = <span class="hljs-literal">true</span>;
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Check and see if we have an initial draw position from state saving </p></div></div><div class="code"><div class="wrapper">		<span class="hljs-keyword">if</span> ( iInitDisplayStart !== <span class="hljs-literal">undefined</span> &amp;&amp; iInitDisplayStart !== -<span class="hljs-number">1</span> )
		{
			oSettings._iDisplayStart = bServerSide ?
				iInitDisplayStart :
				iInitDisplayStart &gt;= oSettings.fnRecordsDisplay() ?
					<span class="hljs-number">0</span> :
					iInitDisplayStart;
	
			oSettings.iInitDisplayStart = -<span class="hljs-number">1</span>;
		}
	
		<span class="hljs-keyword">var</span> iDisplayStart = oSettings._iDisplayStart;
		<span class="hljs-keyword">var</span> iDisplayEnd = oSettings.fnDisplayEnd();
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Server-side processing draw intercept </p></div></div><div class="code"><div class="wrapper">		<span class="hljs-keyword">if</span> ( oSettings.bDeferLoading )
		{
			oSettings.bDeferLoading = <span class="hljs-literal">false</span>;
			oSettings.iDraw++;
			_fnProcessingDisplay( oSettings, <span class="hljs-literal">false</span> );
		}
		<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( !bServerSide )
		{
			oSettings.iDraw++;
		}
		<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( !oSettings.bDestroying &amp;&amp; !_fnAjaxUpdate( oSettings ) )
		{
			<span class="hljs-keyword">return</span>;
		}
	
		<span class="hljs-keyword">if</span> ( aiDisplay.length !== <span class="hljs-number">0</span> )
		{
			<span class="hljs-keyword">var</span> iStart = bServerSide ? <span class="hljs-number">0</span> : iDisplayStart;
			<span class="hljs-keyword">var</span> iEnd = bServerSide ? oSettings.aoData.length : iDisplayEnd;
	
			<span class="hljs-keyword">for</span> ( <span class="hljs-keyword">var</span> j=iStart ; j&lt;iEnd ; j++ )
			{
				<span class="hljs-keyword">var</span> iDataIndex = aiDisplay[j];
				<span class="hljs-keyword">var</span> aoData = oSettings.aoData[ iDataIndex ];
				<span class="hljs-keyword">if</span> ( aoData.nTr === <span class="hljs-literal">null</span> )
				{
					_fnCreateTr( oSettings, iDataIndex );
				}
	
				<span class="hljs-keyword">var</span> nRow = aoData.nTr;
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Remove the old striping classes and then add the new one </p></div></div><div class="code"><div class="wrapper">				<span class="hljs-keyword">if</span> ( iStripes !== <span class="hljs-number">0</span> )
				{
					<span class="hljs-keyword">var</span> sStripe = asStripeClasses[ iRowCount % iStripes ];
					<span class="hljs-keyword">if</span> ( aoData._sRowStripe != sStripe )
					{
						$(nRow).removeClass( aoData._sRowStripe ).addClass( sStripe );
						aoData._sRowStripe = sStripe;
					}
				}
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Row callback functions - might want to manipulate the row </p></div></div><div class="code"><div class="wrapper">				_fnCallbackFire( oSettings, <span class="hljs-string">'aoRowCallback'</span>, <span class="hljs-literal">null</span>,
					[nRow, aoData._aData, iRowCount, j] );
	
				anRows.push( nRow );
				iRowCount++;
			}
		}
		<span class="hljs-keyword">else</span>
		{</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Table is empty - create a row with an empty message in it </p></div></div><div class="code"><div class="wrapper">			<span class="hljs-keyword">var</span> sZero = oLang.sZeroRecords;
			<span class="hljs-keyword">if</span> ( oSettings.iDraw == <span class="hljs-number">1</span> &amp;&amp;  _fnDataSource( oSettings ) == <span class="hljs-string">'ajax'</span> )
			{
				sZero = oLang.sLoadingRecords;
			}
			<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( oLang.sEmptyTable &amp;&amp; oSettings.fnRecordsTotal() === <span class="hljs-number">0</span> )
			{
				sZero = oLang.sEmptyTable;
			}
	
			anRows[ <span class="hljs-number">0</span> ] = $( <span class="hljs-string">'&lt;tr/&gt;'</span>, { <span class="hljs-string">'class'</span>: iStripes ? asStripeClasses[<span class="hljs-number">0</span>] : <span class="hljs-string">''</span> } )
				.append( $(<span class="hljs-string">'&lt;td /&gt;'</span>, {
					<span class="hljs-string">'valign'</span>:  <span class="hljs-string">'top'</span>,
					<span class="hljs-string">'colSpan'</span>: _fnVisbleColumns( oSettings ),
					<span class="hljs-string">'class'</span>:   oSettings.oClasses.sRowEmpty
				} ).html( sZero ) )[<span class="hljs-number">0</span>];
		}
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Header and footer callbacks </p></div></div><div class="code"><div class="wrapper">		_fnCallbackFire( oSettings, <span class="hljs-string">'aoHeaderCallback'</span>, <span class="hljs-string">'header'</span>, [ $(oSettings.nTHead).children(<span class="hljs-string">'tr'</span>)[<span class="hljs-number">0</span>],
			_fnGetDataMaster( oSettings ), iDisplayStart, iDisplayEnd, aiDisplay ] );
	
		_fnCallbackFire( oSettings, <span class="hljs-string">'aoFooterCallback'</span>, <span class="hljs-string">'footer'</span>, [ $(oSettings.nTFoot).children(<span class="hljs-string">'tr'</span>)[<span class="hljs-number">0</span>],
			_fnGetDataMaster( oSettings ), iDisplayStart, iDisplayEnd, aiDisplay ] );
	
		<span class="hljs-keyword">var</span> body = $(oSettings.nTBody);
	
		body.children().detach();
		body.append( $(anRows) );
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Call all required callback functions for the end of a draw </p></div></div><div class="code"><div class="wrapper">		_fnCallbackFire( oSettings, <span class="hljs-string">'aoDrawCallback'</span>, <span class="hljs-string">'draw'</span>, [oSettings] );
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Draw is complete, sorting and filtering must be as well </p></div></div><div class="code"><div class="wrapper">		oSettings.bSorted = <span class="hljs-literal">false</span>;
		oSettings.bFiltered = <span class="hljs-literal">false</span>;
		oSettings.bDrawing = <span class="hljs-literal">false</span>;
	}
	
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Redraw the table - taking account of the various features which are enabled
 @param {object} oSettings dataTables settings object
 @param {boolean} [holdPosition] Keep the current paging position. By default
   the paging is reset to the first page
 @memberof DataTable#oApi</p></div></div><div class="code"><div class="wrapper">	<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_fnReDraw</span><span class="hljs-params">( settings, holdPosition )</span>
	{</span>
		<span class="hljs-keyword">var</span>
			features = settings.oFeatures,
			sort     = features.bSort,
			filter   = features.bFilter;
	
		<span class="hljs-keyword">if</span> ( sort ) {
			_fnSort( settings );
		}
	
		<span class="hljs-keyword">if</span> ( filter ) {
			_fnFilterComplete( settings, settings.oPreviousSearch );
		}
		<span class="hljs-keyword">else</span> {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>No filtering, so we want to just use the display master</p></div></div><div class="code"><div class="wrapper">			settings.aiDisplay = settings.aiDisplayMaster.slice();
		}
	
		<span class="hljs-keyword">if</span> ( holdPosition !== <span class="hljs-literal">true</span> ) {
			settings._iDisplayStart = <span class="hljs-number">0</span>;
		}
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Let any modules know about the draw hold position state (used by
scrolling internally)</p></div></div><div class="code"><div class="wrapper">		settings._drawHold = holdPosition;
	
		_fnDraw( settings );
	
		settings._drawHold = <span class="hljs-literal">false</span>;
	}
	
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Add the options to the page HTML for the table
 @param {object} oSettings dataTables settings object
 @memberof DataTable#oApi</p></div></div><div class="code"><div class="wrapper">	<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_fnAddOptionsHtml</span> <span class="hljs-params">( oSettings )</span>
	{</span>
		<span class="hljs-keyword">var</span> classes = oSettings.oClasses;
		<span class="hljs-keyword">var</span> table = $(oSettings.nTable);
		<span class="hljs-keyword">var</span> holding = $(<span class="hljs-string">'&lt;div/&gt;'</span>).insertBefore( table ); <span class="hljs-comment">// Holding element for speed</span>
		<span class="hljs-keyword">var</span> features = oSettings.oFeatures;
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>All DataTables are wrapped in a div</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-keyword">var</span> insert = $(<span class="hljs-string">'&lt;div/&gt;'</span>, {
			id:      oSettings.sTableId+<span class="hljs-string">'_wrapper'</span>,
			<span class="hljs-string">'class'</span>: classes.sWrapper + (oSettings.nTFoot ? <span class="hljs-string">''</span> : <span class="hljs-string">' '</span>+classes.sNoFooter)
		} );
	
		oSettings.nHolding = holding[<span class="hljs-number">0</span>];
		oSettings.nTableWrapper = insert[<span class="hljs-number">0</span>];
		oSettings.nTableReinsertBefore = oSettings.nTable.nextSibling;
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Loop over the user set positioning and place the elements as needed </p></div></div><div class="code"><div class="wrapper">		<span class="hljs-keyword">var</span> aDom = oSettings.sDom.split(<span class="hljs-string">''</span>);
		<span class="hljs-keyword">var</span> featureNode, cOption, nNewNode, cNext, sAttr, j;
		<span class="hljs-keyword">for</span> ( <span class="hljs-keyword">var</span> i=<span class="hljs-number">0</span> ; i&lt;aDom.length ; i++ )
		{
			featureNode = <span class="hljs-literal">null</span>;
			cOption = aDom[i];
	
			<span class="hljs-keyword">if</span> ( cOption == <span class="hljs-string">'&lt;'</span> )
			{</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>New container div </p></div></div><div class="code"><div class="wrapper">				nNewNode = $(<span class="hljs-string">'&lt;div/&gt;'</span>)[<span class="hljs-number">0</span>];
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Check to see if we should append an id and/or a class name to the container </p></div></div><div class="code"><div class="wrapper">				cNext = aDom[i+<span class="hljs-number">1</span>];
				<span class="hljs-keyword">if</span> ( cNext == <span class="hljs-string">"'"</span> || cNext == <span class="hljs-string">'"'</span> )
				{
					sAttr = <span class="hljs-string">""</span>;
					j = <span class="hljs-number">2</span>;
					<span class="hljs-keyword">while</span> ( aDom[i+j] != cNext )
					{
						sAttr += aDom[i+j];
						j++;
					}
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Replace jQuery UI constants @todo depreciated </p></div></div><div class="code"><div class="wrapper">					<span class="hljs-keyword">if</span> ( sAttr == <span class="hljs-string">"H"</span> )
					{
						sAttr = classes.sJUIHeader;
					}
					<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( sAttr == <span class="hljs-string">"F"</span> )
					{
						sAttr = classes.sJUIFooter;
					}
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>The attribute can be in the format of &quot;#id.class&quot;, &quot;#id&quot; or &quot;class&quot; This logic
breaks the string into parts and applies them as needed</p></div></div><div class="code"><div class="wrapper">					<span class="hljs-keyword">if</span> ( sAttr.indexOf(<span class="hljs-string">'.'</span>) != -<span class="hljs-number">1</span> )
					{
						<span class="hljs-keyword">var</span> aSplit = sAttr.split(<span class="hljs-string">'.'</span>);
						nNewNode.id = aSplit[<span class="hljs-number">0</span>].substr(<span class="hljs-number">1</span>, aSplit[<span class="hljs-number">0</span>].length-<span class="hljs-number">1</span>);
						nNewNode.className = aSplit[<span class="hljs-number">1</span>];
					}
					<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( sAttr.charAt(<span class="hljs-number">0</span>) == <span class="hljs-string">"#"</span> )
					{
						nNewNode.id = sAttr.substr(<span class="hljs-number">1</span>, sAttr.length-<span class="hljs-number">1</span>);
					}
					<span class="hljs-keyword">else</span>
					{
						nNewNode.className = sAttr;
					}
	
					i += j; <span class="hljs-comment">/* Move along the position array */</span>
				}
	
				insert.append( nNewNode );
				insert = $(nNewNode);
			}
			<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( cOption == <span class="hljs-string">'&gt;'</span> )
			{</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>End container div </p></div></div><div class="code"><div class="wrapper">				insert = insert.parent();
			}</div></div></div><div class="segment"><div class="comments doc-section"><div class="wrapper"><p>TODO: Move options into their own plugins?</p></div></div><div class="code"><div class="wrapper">			<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( cOption == <span class="hljs-string">'l'</span> &amp;&amp; features.bPaginate &amp;&amp; features.bLengthChange )
			{</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Length </p></div></div><div class="code"><div class="wrapper">				featureNode = _fnFeatureHtmlLength( oSettings );
			}
			<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( cOption == <span class="hljs-string">'f'</span> &amp;&amp; features.bFilter )
			{</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Filter </p></div></div><div class="code"><div class="wrapper">				featureNode = _fnFeatureHtmlFilter( oSettings );
			}
			<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( cOption == <span class="hljs-string">'r'</span> &amp;&amp; features.bProcessing )
			{</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>pRocessing </p></div></div><div class="code"><div class="wrapper">				featureNode = _fnFeatureHtmlProcessing( oSettings );
			}
			<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( cOption == <span class="hljs-string">'t'</span> )
			{</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Table </p></div></div><div class="code"><div class="wrapper">				featureNode = _fnFeatureHtmlTable( oSettings );
			}
			<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( cOption ==  <span class="hljs-string">'i'</span> &amp;&amp; features.bInfo )
			{</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Info </p></div></div><div class="code"><div class="wrapper">				featureNode = _fnFeatureHtmlInfo( oSettings );
			}
			<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( cOption == <span class="hljs-string">'p'</span> &amp;&amp; features.bPaginate )
			{</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Pagination </p></div></div><div class="code"><div class="wrapper">				featureNode = _fnFeatureHtmlPaginate( oSettings );
			}
			<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( DataTable.ext.feature.length !== <span class="hljs-number">0</span> )
			{</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Plug-in features </p></div></div><div class="code"><div class="wrapper">				<span class="hljs-keyword">var</span> aoFeatures = DataTable.ext.feature;
				<span class="hljs-keyword">for</span> ( <span class="hljs-keyword">var</span> k=<span class="hljs-number">0</span>, kLen=aoFeatures.length ; k&lt;kLen ; k++ )
				{
					<span class="hljs-keyword">if</span> ( cOption == aoFeatures[k].cFeature )
					{
						featureNode = aoFeatures[k].fnInit( oSettings );
						<span class="hljs-keyword">break</span>;
					}
				}
			}
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Add to the 2D features array </p></div></div><div class="code"><div class="wrapper">			<span class="hljs-keyword">if</span> ( featureNode )
			{
				<span class="hljs-keyword">var</span> aanFeatures = oSettings.aanFeatures;
	
				<span class="hljs-keyword">if</span> ( ! aanFeatures[cOption] )
				{
					aanFeatures[cOption] = [];
				}
	
				aanFeatures[cOption].push( featureNode );
				insert.append( featureNode );
			}
		}
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Built our DOM structure - replace the holding div with what we want </p></div></div><div class="code"><div class="wrapper">		holding.replaceWith( insert );
	}
	
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Use the DOM source to create up an array of header cells. The idea here is to
create a layout grid (array) of rows x columns, which contains a reference
to the cell that that point in the grid (regardless of col/rowspan), such that
any column / row could be removed and the new grid constructed
 @param array {object} aLayout Array to store the calculated layout in
 @param {node} nThead The header/footer element for the table
 @memberof DataTable#oApi</p></div></div><div class="code"><div class="wrapper">	<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_fnDetectHeader</span> <span class="hljs-params">( aLayout, nThead )</span>
	{</span>
		<span class="hljs-keyword">var</span> nTrs = $(nThead).children(<span class="hljs-string">'tr'</span>);
		<span class="hljs-keyword">var</span> nTr, nCell;
		<span class="hljs-keyword">var</span> i, k, l, iLen, jLen, iColShifted, iColumn, iColspan, iRowspan;
		<span class="hljs-keyword">var</span> bUnique;
		<span class="hljs-keyword">var</span> fnShiftCol = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">( a, i, j )</span> {</span>
			<span class="hljs-keyword">var</span> k = a[i];
	                <span class="hljs-keyword">while</span> ( k[j] ) {
				j++;
			}
			<span class="hljs-keyword">return</span> j;
		};
	
		aLayout.splice( <span class="hljs-number">0</span>, aLayout.length );
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>We know how many rows there are in the layout - so prep it </p></div></div><div class="code"><div class="wrapper">		<span class="hljs-keyword">for</span> ( i=<span class="hljs-number">0</span>, iLen=nTrs.length ; i&lt;iLen ; i++ )
		{
			aLayout.push( [] );
		}
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Calculate a layout array </p></div></div><div class="code"><div class="wrapper">		<span class="hljs-keyword">for</span> ( i=<span class="hljs-number">0</span>, iLen=nTrs.length ; i&lt;iLen ; i++ )
		{
			nTr = nTrs[i];
			iColumn = <span class="hljs-number">0</span>;
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>For every cell in the row... </p></div></div><div class="code"><div class="wrapper">			nCell = nTr.firstChild;
			<span class="hljs-keyword">while</span> ( nCell ) {
				<span class="hljs-keyword">if</span> ( nCell.nodeName.toUpperCase() == <span class="hljs-string">"TD"</span> ||
				     nCell.nodeName.toUpperCase() == <span class="hljs-string">"TH"</span> )
				{</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Get the col and rowspan attributes from the DOM and sanitise them </p></div></div><div class="code"><div class="wrapper">					iColspan = nCell.getAttribute(<span class="hljs-string">'colspan'</span>) * <span class="hljs-number">1</span>;
					iRowspan = nCell.getAttribute(<span class="hljs-string">'rowspan'</span>) * <span class="hljs-number">1</span>;
					iColspan = (!iColspan || iColspan===<span class="hljs-number">0</span> || iColspan===<span class="hljs-number">1</span>) ? <span class="hljs-number">1</span> : iColspan;
					iRowspan = (!iRowspan || iRowspan===<span class="hljs-number">0</span> || iRowspan===<span class="hljs-number">1</span>) ? <span class="hljs-number">1</span> : iRowspan;
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>There might be colspan cells already in this row, so shift our target
accordingly</p></div></div><div class="code"><div class="wrapper">					iColShifted = fnShiftCol( aLayout, i, iColumn );
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Cache calculation for unique columns </p></div></div><div class="code"><div class="wrapper">					bUnique = iColspan === <span class="hljs-number">1</span> ? <span class="hljs-literal">true</span> : <span class="hljs-literal">false</span>;
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>If there is col / rowspan, copy the information into the layout grid </p></div></div><div class="code"><div class="wrapper">					<span class="hljs-keyword">for</span> ( l=<span class="hljs-number">0</span> ; l&lt;iColspan ; l++ )
					{
						<span class="hljs-keyword">for</span> ( k=<span class="hljs-number">0</span> ; k&lt;iRowspan ; k++ )
						{
							aLayout[i+k][iColShifted+l] = {
								<span class="hljs-string">"cell"</span>: nCell,
								<span class="hljs-string">"unique"</span>: bUnique
							};
							aLayout[i+k].nTr = nTr;
						}
					}
				}
				nCell = nCell.nextSibling;
			}
		}
	}
	
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Get an array of unique th elements, one for each column
 @param {object} oSettings dataTables settings object
 @param {node} nHeader automatically detect the layout from this node - optional
 @param {array} aLayout thead/tfoot layout from _fnDetectHeader - optional
 @returns array {node} aReturn list of unique th&#39;s
 @memberof DataTable#oApi</p></div></div><div class="code"><div class="wrapper">	<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_fnGetUniqueThs</span> <span class="hljs-params">( oSettings, nHeader, aLayout )</span>
	{</span>
		<span class="hljs-keyword">var</span> aReturn = [];
		<span class="hljs-keyword">if</span> ( !aLayout )
		{
			aLayout = oSettings.aoHeader;
			<span class="hljs-keyword">if</span> ( nHeader )
			{
				aLayout = [];
				_fnDetectHeader( aLayout, nHeader );
			}
		}
	
		<span class="hljs-keyword">for</span> ( <span class="hljs-keyword">var</span> i=<span class="hljs-number">0</span>, iLen=aLayout.length ; i&lt;iLen ; i++ )
		{
			<span class="hljs-keyword">for</span> ( <span class="hljs-keyword">var</span> j=<span class="hljs-number">0</span>, jLen=aLayout[i].length ; j&lt;jLen ; j++ )
			{
				<span class="hljs-keyword">if</span> ( aLayout[i][j].unique &amp;&amp;
					 (!aReturn[j] || !oSettings.bSortCellsTop) )
				{
					aReturn[j] = aLayout[i][j].cell;
				}
			}
		}
	
		<span class="hljs-keyword">return</span> aReturn;
	}
	
	
	</div></div></div><div class="segment"><div class="comments doc-section"><div class="wrapper"><p>Create an Ajax call based on the table&#39;s settings, taking into account that
parameters can have multiple forms, and backwards compatibility.</p>
<p>Parameters:</p>
<ul>
<li><p><strong>oSettings must be an object.</strong><br/>(dataTables settings object)</p>
</li>
<li><p><strong>data must be an array.</strong><br/>(Data to send to the server, required by DataTables - may be augmented by developer callbacks)</p>
</li>
<li><p><strong>fn must be a function.</strong><br/>(Callback function to run when data is obtained)</p>
</li>
</ul></div></div><div class="code"><div class="wrapper">	<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_fnBuildAjax</span><span class="hljs-params">( oSettings, data, fn )</span>
	{</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Compatibility with 1.9-, allow fnServerData and event to manipulate</p></div></div><div class="code"><div class="wrapper">		_fnCallbackFire( oSettings, <span class="hljs-string">'aoServerParams'</span>, <span class="hljs-string">'serverParams'</span>, [data] );
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Convert to object based for 1.10+ if using the old array scheme which can
come from server-side processing or serverParams</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-keyword">if</span> ( data &amp;&amp; $.isArray(data) ) {
			<span class="hljs-keyword">var</span> tmp = {};
			<span class="hljs-keyword">var</span> rbracket = <span class="hljs-regexp">/(.*?)\[\]$/</span>;
	
			$.each( data, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(key, val)</span> {</span>
				<span class="hljs-keyword">var</span> match = val.name.match(rbracket);
	
				<span class="hljs-keyword">if</span> ( match ) {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Support for arrays</p></div></div><div class="code"><div class="wrapper">					<span class="hljs-keyword">var</span> name = match[<span class="hljs-number">0</span>];
	
					<span class="hljs-keyword">if</span> ( ! tmp[ name ] ) {
						tmp[ name ] = [];
					}
					tmp[ name ].push( val.value );
				}
				<span class="hljs-keyword">else</span> {
					tmp[val.name] = val.value;
				}
			} );
			data = tmp;
		}
	
		<span class="hljs-keyword">var</span> ajaxData;
		<span class="hljs-keyword">var</span> ajax = oSettings.ajax;
		<span class="hljs-keyword">var</span> instance = oSettings.oInstance;
	
		<span class="hljs-keyword">if</span> ( $.isPlainObject( ajax ) &amp;&amp; ajax.data )
		{
			ajaxData = ajax.data;
	
			<span class="hljs-keyword">var</span> newData = $.isFunction( ajaxData ) ?
				ajaxData( data ) :  <span class="hljs-comment">// fn can manipulate data or return an object</span>
				ajaxData;           <span class="hljs-comment">// object or array to merge</span>
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>If the function returned an object, use that alone</p></div></div><div class="code"><div class="wrapper">			data = $.isFunction( ajaxData ) &amp;&amp; newData ?
				newData :
				$.extend( <span class="hljs-literal">true</span>, data, newData );
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Remove the data property as we&#39;ve resolved it already and don&#39;t want
jQuery to do it again (it is restored at the end of the function)</p></div></div><div class="code"><div class="wrapper">			<span class="hljs-keyword">delete</span> ajax.data;
		}
	
		<span class="hljs-keyword">var</span> baseAjax = {
			<span class="hljs-string">"data"</span>: data,
			<span class="hljs-string">"success"</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(json)</span> {</span>
				<span class="hljs-keyword">var</span> error = json.error || json.sError;
				<span class="hljs-keyword">if</span> ( error ) {
					oSettings.oApi._fnLog( oSettings, <span class="hljs-number">0</span>, error );
				}
	
				oSettings.json = json;
				_fnCallbackFire( oSettings, <span class="hljs-literal">null</span>, <span class="hljs-string">'xhr'</span>, [oSettings, json] );
				fn( json );
			},
			<span class="hljs-string">"dataType"</span>: <span class="hljs-string">"json"</span>,
			<span class="hljs-string">"cache"</span>: <span class="hljs-literal">false</span>,
			<span class="hljs-string">"type"</span>: oSettings.sServerMethod,
			<span class="hljs-string">"error"</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(xhr, error, thrown)</span> {</span>
				<span class="hljs-keyword">var</span> log = oSettings.oApi._fnLog;
	
				<span class="hljs-keyword">if</span> ( error == <span class="hljs-string">"parsererror"</span> ) {
					log( oSettings, <span class="hljs-number">0</span>, <span class="hljs-string">'Invalid JSON response'</span>, <span class="hljs-number">1</span> );
				}
				<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( xhr.readyState === <span class="hljs-number">4</span> ) {
					log( oSettings, <span class="hljs-number">0</span>, <span class="hljs-string">'Ajax error'</span>, <span class="hljs-number">7</span> );
				}
	
				_fnProcessingDisplay( oSettings, <span class="hljs-literal">false</span> );
			}
		};
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Store the data submitted for the API</p></div></div><div class="code"><div class="wrapper">		oSettings.oAjaxData = data;
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Allow plug-ins and external processes to modify the data</p></div></div><div class="code"><div class="wrapper">		_fnCallbackFire( oSettings, <span class="hljs-literal">null</span>, <span class="hljs-string">'preXhr'</span>, [oSettings, data] );
	
		<span class="hljs-keyword">if</span> ( oSettings.fnServerData )
		{</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>DataTables 1.9- compatibility</p></div></div><div class="code"><div class="wrapper">			oSettings.fnServerData.call( instance,
				oSettings.sAjaxSource,
				$.map( data, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(val, key)</span> {</span> <span class="hljs-comment">// Need to convert back to 1.9 trad format</span>
					<span class="hljs-keyword">return</span> { name: key, value: val };
				} ),
				fn,
				oSettings
			);
		}
		<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( oSettings.sAjaxSource || <span class="hljs-keyword">typeof</span> ajax === <span class="hljs-string">'string'</span> )
		{</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>DataTables 1.9- compatibility</p></div></div><div class="code"><div class="wrapper">			oSettings.jqXHR = $.ajax( $.extend( baseAjax, {
				url: ajax || oSettings.sAjaxSource
			} ) );
		}
		<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( $.isFunction( ajax ) )
		{</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Is a function - let the caller define what needs to be done</p></div></div><div class="code"><div class="wrapper">			oSettings.jqXHR = ajax.call( instance, data, fn, oSettings );
		}
		<span class="hljs-keyword">else</span>
		{</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Object to extend the base settings</p></div></div><div class="code"><div class="wrapper">			oSettings.jqXHR = $.ajax( $.extend( baseAjax, ajax ) );
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Restore for next time around</p></div></div><div class="code"><div class="wrapper">			ajax.data = ajaxData;
		}
	}
	
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Update the table using an Ajax call
 @param {object} settings dataTables settings object
 @returns {boolean} Block the table drawing or not
 @memberof DataTable#oApi</p></div></div><div class="code"><div class="wrapper">	<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_fnAjaxUpdate</span><span class="hljs-params">( settings )</span>
	{</span>
		<span class="hljs-keyword">if</span> ( settings.bAjaxDataGet ) {
			settings.iDraw++;
			_fnProcessingDisplay( settings, <span class="hljs-literal">true</span> );
	
			_fnBuildAjax(
				settings,
				_fnAjaxParameters( settings ),
				<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(json)</span> {</span>
					_fnAjaxUpdateDraw( settings, json );
				}
			);
	
			<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
		}
		<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
	}
	
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Build up the parameters in an object needed for a server-side processing
request. Note that this is basically done twice, is different ways - a modern
method which is used by default in DataTables 1.10 which uses objects and
arrays, or the 1.9- method with is name / value pairs. 1.9 method is used if
the sAjaxSource option is used in the initialisation, or the legacyAjax
option is set.
 @param {object} oSettings dataTables settings object
 @returns {bool} block the table drawing or not
 @memberof DataTable#oApi</p></div></div><div class="code"><div class="wrapper">	<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_fnAjaxParameters</span><span class="hljs-params">( settings )</span>
	{</span>
		<span class="hljs-keyword">var</span>
			columns = settings.aoColumns,
			columnCount = columns.length,
			features = settings.oFeatures,
			preSearch = settings.oPreviousSearch,
			preColSearch = settings.aoPreSearchCols,
			i, data = [], dataProp, column, columnSearch,
			sort = _fnSortFlatten( settings ),
			displayStart = settings._iDisplayStart,
			displayLength = features.bPaginate !== <span class="hljs-literal">false</span> ?
				settings._iDisplayLength :
				-<span class="hljs-number">1</span>;
	
		<span class="hljs-keyword">var</span> param = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">( name, value )</span> {</span>
			data.push( { <span class="hljs-string">'name'</span>: name, <span class="hljs-string">'value'</span>: value } );
		};
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>DataTables 1.9- compatible method</p></div></div><div class="code"><div class="wrapper">		param( <span class="hljs-string">'sEcho'</span>,          settings.iDraw );
		param( <span class="hljs-string">'iColumns'</span>,       columnCount );
		param( <span class="hljs-string">'sColumns'</span>,       _pluck( columns, <span class="hljs-string">'sName'</span> ).join(<span class="hljs-string">','</span>) );
		param( <span class="hljs-string">'iDisplayStart'</span>,  displayStart );
		param( <span class="hljs-string">'iDisplayLength'</span>, displayLength );
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>DataTables 1.10+ method</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-keyword">var</span> d = {
			draw:    settings.iDraw,
			columns: [],
			order:   [],
			start:   displayStart,
			length:  displayLength,
			search:  {
				value: preSearch.sSearch,
				regex: preSearch.bRegex
			}
		};
	
		<span class="hljs-keyword">for</span> ( i=<span class="hljs-number">0</span> ; i&lt;columnCount ; i++ ) {
			column = columns[i];
			columnSearch = preColSearch[i];
			dataProp = <span class="hljs-keyword">typeof</span> column.mData==<span class="hljs-string">"function"</span> ? <span class="hljs-string">'function'</span> : column.mData ;
	
			d.columns.push( {
				data:       dataProp,
				name:       column.sName,
				searchable: column.bSearchable,
				orderable:  column.bSortable,
				search:     {
					value: columnSearch.sSearch,
					regex: columnSearch.bRegex
				}
			} );
	
			param( <span class="hljs-string">"mDataProp_"</span>+i, dataProp );
	
			<span class="hljs-keyword">if</span> ( features.bFilter ) {
				param( <span class="hljs-string">'sSearch_'</span>+i,     columnSearch.sSearch );
				param( <span class="hljs-string">'bRegex_'</span>+i,      columnSearch.bRegex );
				param( <span class="hljs-string">'bSearchable_'</span>+i, column.bSearchable );
			}
	
			<span class="hljs-keyword">if</span> ( features.bSort ) {
				param( <span class="hljs-string">'bSortable_'</span>+i, column.bSortable );
			}
		}
	
		<span class="hljs-keyword">if</span> ( features.bFilter ) {
			param( <span class="hljs-string">'sSearch'</span>, preSearch.sSearch );
			param( <span class="hljs-string">'bRegex'</span>, preSearch.bRegex );
		}
	
		<span class="hljs-keyword">if</span> ( features.bSort ) {
			$.each( sort, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">( i, val )</span> {</span>
				d.order.push( { column: val.col, dir: val.dir } );
	
				param( <span class="hljs-string">'iSortCol_'</span>+i, val.col );
				param( <span class="hljs-string">'sSortDir_'</span>+i, val.dir );
			} );
	
			param( <span class="hljs-string">'iSortingCols'</span>, sort.length );
		}
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>If the legacy.ajax parameter is null, then we automatically decide which
form to use, based on sAjaxSource</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-keyword">var</span> legacy = DataTable.ext.legacy.ajax;
		<span class="hljs-keyword">if</span> ( legacy === <span class="hljs-literal">null</span> ) {
			<span class="hljs-keyword">return</span> settings.sAjaxSource ? data : d;
		}
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Otherwise, if legacy has been specified then we use that to decide on the
form</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-keyword">return</span> legacy ? data : d;
	}
	
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Data the data from the server (nuking the old) and redraw the table
 @param {object} oSettings dataTables settings object
 @param {object} json json data return from the server.
 @param {string} json.sEcho Tracking flag for DataTables to match requests
 @param {int} json.iTotalRecords Number of records in the data set, not accounting for filtering
 @param {int} json.iTotalDisplayRecords Number of records in the data set, accounting for filtering
 @param {array} json.aaData The data to display on this page
 @param {string} [json.sColumns] Column ordering (sName, comma separated)
 @memberof DataTable#oApi</p></div></div><div class="code"><div class="wrapper">	<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_fnAjaxUpdateDraw</span> <span class="hljs-params">( settings, json )</span>
	{</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>v1.10 uses camelCase variables, while 1.9 uses Hungarian notation.
Support both</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-keyword">var</span> compat = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">( old, modern )</span> {</span>
			<span class="hljs-keyword">return</span> json[old] !== <span class="hljs-literal">undefined</span> ? json[old] : json[modern];
		};
	
		<span class="hljs-keyword">var</span> draw            = compat( <span class="hljs-string">'sEcho'</span>,                <span class="hljs-string">'draw'</span> );
		<span class="hljs-keyword">var</span> recordsTotal    = compat( <span class="hljs-string">'iTotalRecords'</span>,        <span class="hljs-string">'recordsTotal'</span> );
		<span class="hljs-keyword">var</span> rocordsFiltered = compat( <span class="hljs-string">'iTotalDisplayRecords'</span>, <span class="hljs-string">'recordsFiltered'</span> );
	
		<span class="hljs-keyword">if</span> ( draw ) {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Protect against out of sequence returns</p></div></div><div class="code"><div class="wrapper">			<span class="hljs-keyword">if</span> ( draw*<span class="hljs-number">1</span> &lt; settings.iDraw ) {
				<span class="hljs-keyword">return</span>;
			}
			settings.iDraw = draw * <span class="hljs-number">1</span>;
		}
	
		_fnClearTable( settings );
		settings._iRecordsTotal   = <span class="hljs-built_in">parseInt</span>(recordsTotal, <span class="hljs-number">10</span>);
		settings._iRecordsDisplay = <span class="hljs-built_in">parseInt</span>(rocordsFiltered, <span class="hljs-number">10</span>);
	
		<span class="hljs-keyword">var</span> data = _fnAjaxDataSrc( settings, json );
		<span class="hljs-keyword">for</span> ( <span class="hljs-keyword">var</span> i=<span class="hljs-number">0</span>, ien=data.length ; i&lt;ien ; i++ ) {
			_fnAddData( settings, data[i] );
		}
		settings.aiDisplay = settings.aiDisplayMaster.slice();
	
		settings.bAjaxDataGet = <span class="hljs-literal">false</span>;
		_fnDraw( settings );
	
		<span class="hljs-keyword">if</span> ( ! settings._bInitComplete ) {
			_fnInitComplete( settings, json );
		}
	
		settings.bAjaxDataGet = <span class="hljs-literal">true</span>;
		_fnProcessingDisplay( settings, <span class="hljs-literal">false</span> );
	}
	
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Get the data from the JSON data source to use for drawing a table. Using
<code>_fnGetObjectDataFn</code> allows the data to be sourced from a property of the
source object, or from a processing function.
 @param {object} oSettings dataTables settings object
 @param  {object} json Data source object / array from the server
 @return {array} Array of data to use</p></div></div><div class="code"><div class="wrapper">	<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_fnAjaxDataSrc</span> <span class="hljs-params">( oSettings, json )</span>
	{</span>
		<span class="hljs-keyword">var</span> dataSrc = $.isPlainObject( oSettings.ajax ) &amp;&amp; oSettings.ajax.dataSrc !== <span class="hljs-literal">undefined</span> ?
			oSettings.ajax.dataSrc :
			oSettings.sAjaxDataProp; <span class="hljs-comment">// Compatibility with 1.9-.</span>
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Compatibility with 1.9-. In order to read from aaData, check if the
default has been changed, if not, check for aaData</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-keyword">if</span> ( dataSrc === <span class="hljs-string">'data'</span> ) {
			<span class="hljs-keyword">return</span> json.aaData || json[dataSrc];
		}
	
		<span class="hljs-keyword">return</span> dataSrc !== <span class="hljs-string">""</span> ?
			_fnGetObjectDataFn( dataSrc )( json ) :
			json;
	}
	
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Generate the node required for filtering text
 @returns {node} Filter control element
 @param {object} oSettings dataTables settings object
 @memberof DataTable#oApi</p></div></div><div class="code"><div class="wrapper">	<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_fnFeatureHtmlFilter</span> <span class="hljs-params">( settings )</span>
	{</span>
		<span class="hljs-keyword">var</span> classes = settings.oClasses;
		<span class="hljs-keyword">var</span> tableId = settings.sTableId;
		<span class="hljs-keyword">var</span> language = settings.oLanguage;
		<span class="hljs-keyword">var</span> previousSearch = settings.oPreviousSearch;
		<span class="hljs-keyword">var</span> features = settings.aanFeatures;
		<span class="hljs-keyword">var</span> input = <span class="hljs-string">'&lt;input type="search" class="'</span>+classes.sFilterInput+<span class="hljs-string">'"/&gt;'</span>;
	
		<span class="hljs-keyword">var</span> str = language.sSearch;
		str = str.match(<span class="hljs-regexp">/_INPUT_/</span>) ?
			str.replace(<span class="hljs-string">'_INPUT_'</span>, input) :
			str+input;
	
		<span class="hljs-keyword">var</span> filter = $(<span class="hljs-string">'&lt;div/&gt;'</span>, {
				<span class="hljs-string">'id'</span>: ! features.f ? tableId+<span class="hljs-string">'_filter'</span> : <span class="hljs-literal">null</span>,
				<span class="hljs-string">'class'</span>: classes.sFilter
			} )
			.append( $(<span class="hljs-string">'&lt;label/&gt;'</span> ).append( str ) );
	
		<span class="hljs-keyword">var</span> searchFn = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Update all other filter input elements for the new display </p></div></div><div class="code"><div class="wrapper">			<span class="hljs-keyword">var</span> n = features.f;
			<span class="hljs-keyword">var</span> val = !<span class="hljs-keyword">this</span>.value ? <span class="hljs-string">""</span> : <span class="hljs-keyword">this</span>.value; <span class="hljs-comment">// mental IE8 fix :-(</span>
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Now do the filter </p></div></div><div class="code"><div class="wrapper">			<span class="hljs-keyword">if</span> ( val != previousSearch.sSearch ) {
				_fnFilterComplete( settings, {
					<span class="hljs-string">"sSearch"</span>: val,
					<span class="hljs-string">"bRegex"</span>: previousSearch.bRegex,
					<span class="hljs-string">"bSmart"</span>: previousSearch.bSmart ,
					<span class="hljs-string">"bCaseInsensitive"</span>: previousSearch.bCaseInsensitive
				} );
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Need to redraw, without resorting</p></div></div><div class="code"><div class="wrapper">				settings._iDisplayStart = <span class="hljs-number">0</span>;
				_fnDraw( settings );
			}
		};
		<span class="hljs-keyword">var</span> jqFilter = $(<span class="hljs-string">'input'</span>, filter)
			.val( previousSearch.sSearch )
			.attr( <span class="hljs-string">'placeholder'</span>, language.sSearchPlaceholder )
			.bind(
				<span class="hljs-string">'keyup.DT search.DT input.DT paste.DT cut.DT'</span>,
				_fnDataSource( settings ) === <span class="hljs-string">'ssp'</span> ?
					_fnThrottle( searchFn, <span class="hljs-number">400</span> ):
					searchFn
			)
			.bind( <span class="hljs-string">'keypress.DT'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(e)</span> {</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Prevent form submission </p></div></div><div class="code"><div class="wrapper">				<span class="hljs-keyword">if</span> ( e.keyCode == <span class="hljs-number">13</span> ) {
					<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
				}
			} )
			.attr(<span class="hljs-string">'aria-controls'</span>, tableId);
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Update the input elements whenever the table is filtered</p></div></div><div class="code"><div class="wrapper">		$(settings.nTable).on( <span class="hljs-string">'search.dt.DT'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">( ev, s )</span> {</span>
			<span class="hljs-keyword">if</span> ( settings === s ) {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>IE9 throws an &#39;unknown error&#39; if document.activeElement is used
inside an iframe or frame...</p></div></div><div class="code"><div class="wrapper">				<span class="hljs-keyword">try</span> {
					<span class="hljs-keyword">if</span> ( jqFilter[<span class="hljs-number">0</span>] !== document.activeElement ) {
						jqFilter.val( previousSearch.sSearch );
					}
				}
				<span class="hljs-keyword">catch</span> ( e ) {}
			}
		} );
	
		<span class="hljs-keyword">return</span> filter[<span class="hljs-number">0</span>];
	}
	
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Filter the table using both the global filter and column based filtering
 @param {object} oSettings dataTables settings object
 @param {object} oSearch search information
 @param {int} [iForce] force a research of the master array (1) or not (undefined or 0)
 @memberof DataTable#oApi</p></div></div><div class="code"><div class="wrapper">	<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_fnFilterComplete</span> <span class="hljs-params">( oSettings, oInput, iForce )</span>
	{</span>
		<span class="hljs-keyword">var</span> oPrevSearch = oSettings.oPreviousSearch;
		<span class="hljs-keyword">var</span> aoPrevSearch = oSettings.aoPreSearchCols;
		<span class="hljs-keyword">var</span> fnSaveFilter = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">( oFilter )</span> {</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Save the filtering values </p></div></div><div class="code"><div class="wrapper">			oPrevSearch.sSearch = oFilter.sSearch;
			oPrevSearch.bRegex = oFilter.bRegex;
			oPrevSearch.bSmart = oFilter.bSmart;
			oPrevSearch.bCaseInsensitive = oFilter.bCaseInsensitive;
		};
		<span class="hljs-keyword">var</span> fnRegex = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">( o )</span> {</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Backwards compatibility with the bEscapeRegex option</p></div></div><div class="code"><div class="wrapper">			<span class="hljs-keyword">return</span> o.bEscapeRegex !== <span class="hljs-literal">undefined</span> ? !o.bEscapeRegex : o.bRegex;
		};
	</div></div></div><div class="segment"><div class="comments doc-section"><div class="wrapper"><p>Resolve any column types that are unknown due to addition or invalidation</p>
<p>TODO: As per sort - can this be moved into an event handler?</p></div></div><div class="code"><div class="wrapper">		_fnColumnTypes( oSettings );
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>In server-side processing all filtering is done by the server, so no point hanging around here </p></div></div><div class="code"><div class="wrapper">		<span class="hljs-keyword">if</span> ( _fnDataSource( oSettings ) != <span class="hljs-string">'ssp'</span> )
		{</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Global filter </p></div></div><div class="code"><div class="wrapper">			_fnFilter( oSettings, oInput.sSearch, iForce, fnRegex(oInput), oInput.bSmart, oInput.bCaseInsensitive );
			fnSaveFilter( oInput );
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Now do the individual column filter </p></div></div><div class="code"><div class="wrapper">			<span class="hljs-keyword">for</span> ( <span class="hljs-keyword">var</span> i=<span class="hljs-number">0</span> ; i&lt;aoPrevSearch.length ; i++ )
			{
				_fnFilterColumn( oSettings, aoPrevSearch[i].sSearch, i, fnRegex(aoPrevSearch[i]),
					aoPrevSearch[i].bSmart, aoPrevSearch[i].bCaseInsensitive );
			}
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Custom filtering </p></div></div><div class="code"><div class="wrapper">			_fnFilterCustom( oSettings );
		}
		<span class="hljs-keyword">else</span>
		{
			fnSaveFilter( oInput );
		}
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Tell the draw function we have been filtering </p></div></div><div class="code"><div class="wrapper">		oSettings.bFiltered = <span class="hljs-literal">true</span>;
		_fnCallbackFire( oSettings, <span class="hljs-literal">null</span>, <span class="hljs-string">'search'</span>, [oSettings] );
	}
	
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Apply custom filtering functions
 @param {object} oSettings dataTables settings object
 @memberof DataTable#oApi</p></div></div><div class="code"><div class="wrapper">	<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_fnFilterCustom</span><span class="hljs-params">( settings )</span>
	{</span>
		<span class="hljs-keyword">var</span> filters = DataTable.ext.search;
		<span class="hljs-keyword">var</span> displayRows = settings.aiDisplay;
		<span class="hljs-keyword">var</span> row, rowIdx;
	
		<span class="hljs-keyword">for</span> ( <span class="hljs-keyword">var</span> i=<span class="hljs-number">0</span>, ien=filters.length ; i&lt;ien ; i++ ) {
			<span class="hljs-keyword">var</span> rows = [];
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Loop over each row and see if it should be included</p></div></div><div class="code"><div class="wrapper">			<span class="hljs-keyword">for</span> ( <span class="hljs-keyword">var</span> j=<span class="hljs-number">0</span>, jen=displayRows.length ; j&lt;jen ; j++ ) {
				rowIdx = displayRows[ j ];
				row = settings.aoData[ rowIdx ];
	
				<span class="hljs-keyword">if</span> ( filters[i]( settings, row._aFilterData, rowIdx, row._aData, j ) ) {
					rows.push( rowIdx );
				}
			}
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>So the array reference doesn&#39;t break set the results into the
existing array</p></div></div><div class="code"><div class="wrapper">			displayRows.length = <span class="hljs-number">0</span>;
			displayRows.push.apply( displayRows, rows );
		}
	}
	
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Filter the table on a per-column basis
 @param {object} oSettings dataTables settings object
 @param {string} sInput string to filter on
 @param {int} iColumn column to filter
 @param {bool} bRegex treat search string as a regular expression or not
 @param {bool} bSmart use smart filtering or not
 @param {bool} bCaseInsensitive Do case insenstive matching or not
 @memberof DataTable#oApi</p></div></div><div class="code"><div class="wrapper">	<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_fnFilterColumn</span> <span class="hljs-params">( settings, searchStr, colIdx, regex, smart, caseInsensitive )</span>
	{</span>
		<span class="hljs-keyword">if</span> ( searchStr === <span class="hljs-string">''</span> ) {
			<span class="hljs-keyword">return</span>;
		}
	
		<span class="hljs-keyword">var</span> data;
		<span class="hljs-keyword">var</span> display = settings.aiDisplay;
		<span class="hljs-keyword">var</span> rpSearch = _fnFilterCreateSearch( searchStr, regex, smart, caseInsensitive );
	
		<span class="hljs-keyword">for</span> ( <span class="hljs-keyword">var</span> i=display.length-<span class="hljs-number">1</span> ; i&gt;=<span class="hljs-number">0</span> ; i-- ) {
			data = settings.aoData[ display[i] ]._aFilterData[ colIdx ];
	
			<span class="hljs-keyword">if</span> ( ! rpSearch.test( data ) ) {
				display.splice( i, <span class="hljs-number">1</span> );
			}
		}
	}
	
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Filter the data table based on user input and draw the table
 @param {object} settings dataTables settings object
 @param {string} input string to filter on
 @param {int} force optional - force a research of the master array (1) or not (undefined or 0)
 @param {bool} regex treat as a regular expression or not
 @param {bool} smart perform smart filtering or not
 @param {bool} caseInsensitive Do case insenstive matching or not
 @memberof DataTable#oApi</p></div></div><div class="code"><div class="wrapper">	<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_fnFilter</span><span class="hljs-params">( settings, input, force, regex, smart, caseInsensitive )</span>
	{</span>
		<span class="hljs-keyword">var</span> rpSearch = _fnFilterCreateSearch( input, regex, smart, caseInsensitive );
		<span class="hljs-keyword">var</span> prevSearch = settings.oPreviousSearch.sSearch;
		<span class="hljs-keyword">var</span> displayMaster = settings.aiDisplayMaster;
		<span class="hljs-keyword">var</span> display, invalidated, i;
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Need to take account of custom filtering functions - always filter</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-keyword">if</span> ( DataTable.ext.search.length !== <span class="hljs-number">0</span> ) {
			force = <span class="hljs-literal">true</span>;
		}
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Check if any of the rows were invalidated</p></div></div><div class="code"><div class="wrapper">		invalidated = _fnFilterData( settings );
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>If the input is blank - we just want the full data set</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-keyword">if</span> ( input.length &lt;= <span class="hljs-number">0</span> ) {
			settings.aiDisplay = displayMaster.slice();
		}
		<span class="hljs-keyword">else</span> {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>New search - start from the master array</p></div></div><div class="code"><div class="wrapper">			<span class="hljs-keyword">if</span> ( invalidated ||
				 force ||
				 prevSearch.length &gt; input.length ||
				 input.indexOf(prevSearch) !== <span class="hljs-number">0</span> ||
				 settings.bSorted <span class="hljs-comment">// On resort, the display master needs to be</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>re-filtered since indexes will have changed</p></div></div><div class="code"><div class="wrapper">			) {
				settings.aiDisplay = displayMaster.slice();
			}
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Search the display array</p></div></div><div class="code"><div class="wrapper">			display = settings.aiDisplay;
	
			<span class="hljs-keyword">for</span> ( i=display.length-<span class="hljs-number">1</span> ; i&gt;=<span class="hljs-number">0</span> ; i-- ) {
				<span class="hljs-keyword">if</span> ( ! rpSearch.test( settings.aoData[ display[i] ]._sFilterRow ) ) {
					display.splice( i, <span class="hljs-number">1</span> );
				}
			}
		}
	}
	
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Build a regular expression object suitable for searching a table
 @param {string} sSearch string to search for
 @param {bool} bRegex treat as a regular expression or not
 @param {bool} bSmart perform smart filtering or not
 @param {bool} bCaseInsensitive Do case insensitive matching or not
 @returns {RegExp} constructed object
 @memberof DataTable#oApi</p></div></div><div class="code"><div class="wrapper">	<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_fnFilterCreateSearch</span><span class="hljs-params">( search, regex, smart, caseInsensitive )</span>
	{</span>
		search = regex ?
			search :
			_fnEscapeRegex( search );
		
		<span class="hljs-keyword">if</span> ( smart ) {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>For smart filtering we want to allow the search to work regardless of
word order. We also want double quoted text to be preserved, so word
order is important - a la google. So this is what we want to
generate:</p>
<p>^(?=.<em>?\bone\b)(?=.</em>?\btwo three\b)(?=.<em>?\bfour\b).</em>$</p></div></div><div class="code"><div class="wrapper">			<span class="hljs-keyword">var</span> a = $.map( search.match( <span class="hljs-regexp">/"[^"]+"|[^ ]+/g</span> ) || <span class="hljs-string">''</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">( word )</span> {</span>
				<span class="hljs-keyword">return</span> word.charAt(<span class="hljs-number">0</span>) === <span class="hljs-string">'"'</span> ?
					word.match( <span class="hljs-regexp">/^"(.*)"$/</span> )[<span class="hljs-number">1</span>] :
					word;
			} );
	
			search = <span class="hljs-string">'^(?=.*?'</span>+a.join( <span class="hljs-string">')(?=.*?'</span> )+<span class="hljs-string">').*$'</span>;
		}
	
		<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>( search, caseInsensitive ? <span class="hljs-string">'i'</span> : <span class="hljs-string">''</span> );
	}
	
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>scape a string such that it can be used in a regular expression
 @param {string} sVal string to escape
 @returns {string} escaped string
 @memberof DataTable#oApi</p></div></div><div class="code"><div class="wrapper">	<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_fnEscapeRegex</span> <span class="hljs-params">( sVal )</span>
	{</span>
		<span class="hljs-keyword">return</span> sVal.replace( _re_escape_regex, <span class="hljs-string">'\\$1'</span> );
	}
	
	
	
	<span class="hljs-keyword">var</span> __filter_div = $(<span class="hljs-string">'&lt;div&gt;'</span>)[<span class="hljs-number">0</span>];
	<span class="hljs-keyword">var</span> __filter_div_textContent = __filter_div.textContent !== <span class="hljs-literal">undefined</span>;
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Update the filtering data for each row if needed (by invalidation or first run)</p></div></div><div class="code"><div class="wrapper">	<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_fnFilterData</span> <span class="hljs-params">( settings )</span>
	{</span>
		<span class="hljs-keyword">var</span> columns = settings.aoColumns;
		<span class="hljs-keyword">var</span> column;
		<span class="hljs-keyword">var</span> i, j, ien, jen, filterData, cellData, row;
		<span class="hljs-keyword">var</span> fomatters = DataTable.ext.type.search;
		<span class="hljs-keyword">var</span> wasInvalidated = <span class="hljs-literal">false</span>;
	
		<span class="hljs-keyword">for</span> ( i=<span class="hljs-number">0</span>, ien=settings.aoData.length ; i&lt;ien ; i++ ) {
			row = settings.aoData[i];
	
			<span class="hljs-keyword">if</span> ( ! row._aFilterData ) {
				filterData = [];
	
				<span class="hljs-keyword">for</span> ( j=<span class="hljs-number">0</span>, jen=columns.length ; j&lt;jen ; j++ ) {
					column = columns[j];
	
					<span class="hljs-keyword">if</span> ( column.bSearchable ) {
						cellData = _fnGetCellData( settings, i, j, <span class="hljs-string">'filter'</span> );
	
						cellData = fomatters[ column.sType ] ?
							fomatters[ column.sType ]( cellData ) :
							cellData !== <span class="hljs-literal">null</span> ?
								cellData :
								<span class="hljs-string">''</span>;
					}
					<span class="hljs-keyword">else</span> {
						cellData = <span class="hljs-string">''</span>;
					}
	
					<span class="hljs-keyword">if</span> ( cellData ) {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>If it looks like there is an HTML entity in the string,
attempt to decode it so sorting works as expected. Note that
we could use a single line of jQuery to do this, but the DOM
method used here is much faster <a href="http://jsperf.com/html-decode">http://jsperf.com/html-decode</a></p></div></div><div class="code"><div class="wrapper">						<span class="hljs-keyword">if</span> ( cellData.indexOf &amp;&amp; cellData.indexOf(<span class="hljs-string">'&amp;'</span>) !== -<span class="hljs-number">1</span> ) {
							__filter_div.innerHTML = cellData;
							cellData = __filter_div_textContent ?
								__filter_div.textContent :
								__filter_div.innerText;
						}
	
						<span class="hljs-keyword">if</span> ( cellData.replace ) {
							cellData = cellData.replace(<span class="hljs-regexp">/[\r\n]/g</span>, <span class="hljs-string">''</span>);
						}
	
						filterData.push( cellData );
					}
				}
	
				row._aFilterData = filterData;
				row._sFilterRow = filterData.join(<span class="hljs-string">'  '</span>);
				wasInvalidated = <span class="hljs-literal">true</span>;
			}
		}
	
		<span class="hljs-keyword">return</span> wasInvalidated;
	}
	
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Convert from the internal Hungarian notation to camelCase for external
interaction
 @param {object} obj Object to convert
 @returns {object} Inverted object
 @memberof DataTable#oApi</p></div></div><div class="code"><div class="wrapper">	<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_fnSearchToCamel</span> <span class="hljs-params">( obj )</span>
	{</span>
		<span class="hljs-keyword">return</span> {
			search:          obj.sSearch,
			smart:           obj.bSmart,
			regex:           obj.bRegex,
			caseInsensitive: obj.bCaseInsensitive
		};
	}
	
	
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Convert from camelCase notation to the internal Hungarian. We could use the
Hungarian convert function here, but this is cleaner
 @param {object} obj Object to convert
 @returns {object} Inverted object
 @memberof DataTable#oApi</p></div></div><div class="code"><div class="wrapper">	<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_fnSearchToHung</span> <span class="hljs-params">( obj )</span>
	{</span>
		<span class="hljs-keyword">return</span> {
			sSearch:          obj.search,
			bSmart:           obj.smart,
			bRegex:           obj.regex,
			bCaseInsensitive: obj.caseInsensitive
		};
	}
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Generate the node required for the info display
 @param {object} oSettings dataTables settings object
 @returns {node} Information element
 @memberof DataTable#oApi</p></div></div><div class="code"><div class="wrapper">	<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_fnFeatureHtmlInfo</span> <span class="hljs-params">( settings )</span>
	{</span>
		<span class="hljs-keyword">var</span>
			tid = settings.sTableId,
			nodes = settings.aanFeatures.i,
			n = $(<span class="hljs-string">'&lt;div/&gt;'</span>, {
				<span class="hljs-string">'class'</span>: settings.oClasses.sInfo,
				<span class="hljs-string">'id'</span>: ! nodes ? tid+<span class="hljs-string">'_info'</span> : <span class="hljs-literal">null</span>
			} );
	
		<span class="hljs-keyword">if</span> ( ! nodes ) {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Update display on each draw</p></div></div><div class="code"><div class="wrapper">			settings.aoDrawCallback.push( {
				<span class="hljs-string">"fn"</span>: _fnUpdateInfo,
				<span class="hljs-string">"sName"</span>: <span class="hljs-string">"information"</span>
			} );
	
			n
				.attr( <span class="hljs-string">'role'</span>, <span class="hljs-string">'status'</span> )
				.attr( <span class="hljs-string">'aria-live'</span>, <span class="hljs-string">'polite'</span> );
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Table is described by our info div</p></div></div><div class="code"><div class="wrapper">			$(settings.nTable).attr( <span class="hljs-string">'aria-describedby'</span>, tid+<span class="hljs-string">'_info'</span> );
		}
	
		<span class="hljs-keyword">return</span> n[<span class="hljs-number">0</span>];
	}
	
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Update the information elements in the display
 @param {object} settings dataTables settings object
 @memberof DataTable#oApi</p></div></div><div class="code"><div class="wrapper">	<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_fnUpdateInfo</span> <span class="hljs-params">( settings )</span>
	{</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Show information about the table </p></div></div><div class="code"><div class="wrapper">		<span class="hljs-keyword">var</span> nodes = settings.aanFeatures.i;
		<span class="hljs-keyword">if</span> ( nodes.length === <span class="hljs-number">0</span> ) {
			<span class="hljs-keyword">return</span>;
		}
	
		<span class="hljs-keyword">var</span>
			lang  = settings.oLanguage,
			start = settings._iDisplayStart+<span class="hljs-number">1</span>,
			end   = settings.fnDisplayEnd(),
			max   = settings.fnRecordsTotal(),
			total = settings.fnRecordsDisplay(),
			out   = total ?
				lang.sInfo :
				lang.sInfoEmpty;
	
		<span class="hljs-keyword">if</span> ( total !== max ) {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Record set after filtering </p></div></div><div class="code"><div class="wrapper">			out += <span class="hljs-string">' '</span> + lang.sInfoFiltered;
		}
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Convert the macros</p></div></div><div class="code"><div class="wrapper">		out += lang.sInfoPostFix;
		out = _fnInfoMacros( settings, out );
	
		<span class="hljs-keyword">var</span> callback = lang.fnInfoCallback;
		<span class="hljs-keyword">if</span> ( callback !== <span class="hljs-literal">null</span> ) {
			out = callback.call( settings.oInstance,
				settings, start, end, max, total, out
			);
		}
	
		$(nodes).html( out );
	}
	
	
	<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_fnInfoMacros</span> <span class="hljs-params">( settings, str )</span>
	{</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>When infinite scrolling, we are always starting at 1. _iDisplayStart is used only
internally</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-keyword">var</span>
			formatter  = settings.fnFormatNumber,
			start      = settings._iDisplayStart+<span class="hljs-number">1</span>,
			len        = settings._iDisplayLength,
			vis        = settings.fnRecordsDisplay(),
			all        = len === -<span class="hljs-number">1</span>;
	
		<span class="hljs-keyword">return</span> str.
			replace(<span class="hljs-regexp">/_START_/g</span>, formatter.call( settings, start ) ).
			replace(<span class="hljs-regexp">/_END_/g</span>,   formatter.call( settings, settings.fnDisplayEnd() ) ).
			replace(<span class="hljs-regexp">/_MAX_/g</span>,   formatter.call( settings, settings.fnRecordsTotal() ) ).
			replace(<span class="hljs-regexp">/_TOTAL_/g</span>, formatter.call( settings, vis ) ).
			replace(<span class="hljs-regexp">/_PAGE_/g</span>,  formatter.call( settings, all ? <span class="hljs-number">1</span> : <span class="hljs-built_in">Math</span>.ceil( start / len ) ) ).
			replace(<span class="hljs-regexp">/_PAGES_/g</span>, formatter.call( settings, all ? <span class="hljs-number">1</span> : <span class="hljs-built_in">Math</span>.ceil( vis / len ) ) );
	}
	
	
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Draw the table for the first time, adding all required features
 @param {object} settings dataTables settings object
 @memberof DataTable#oApi</p></div></div><div class="code"><div class="wrapper">	<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_fnInitialise</span> <span class="hljs-params">( settings )</span>
	{</span>
		<span class="hljs-keyword">var</span> i, iLen, iAjaxStart=settings.iInitDisplayStart;
		<span class="hljs-keyword">var</span> columns = settings.aoColumns, column;
		<span class="hljs-keyword">var</span> features = settings.oFeatures;
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Ensure that the table data is fully initialised </p></div></div><div class="code"><div class="wrapper">		<span class="hljs-keyword">if</span> ( ! settings.bInitialised ) {
			setTimeout( <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span>{</span> _fnInitialise( settings ); }, <span class="hljs-number">200</span> );
			<span class="hljs-keyword">return</span>;
		}
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Show the display HTML options </p></div></div><div class="code"><div class="wrapper">		_fnAddOptionsHtml( settings );
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Build and draw the header / footer for the table </p></div></div><div class="code"><div class="wrapper">		_fnBuildHead( settings );
		_fnDrawHead( settings, settings.aoHeader );
		_fnDrawHead( settings, settings.aoFooter );
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Okay to show that something is going on now </p></div></div><div class="code"><div class="wrapper">		_fnProcessingDisplay( settings, <span class="hljs-literal">true</span> );
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Calculate sizes for columns </p></div></div><div class="code"><div class="wrapper">		<span class="hljs-keyword">if</span> ( features.bAutoWidth ) {
			_fnCalculateColumnWidths( settings );
		}
	
		<span class="hljs-keyword">for</span> ( i=<span class="hljs-number">0</span>, iLen=columns.length ; i&lt;iLen ; i++ ) {
			column = columns[i];
	
			<span class="hljs-keyword">if</span> ( column.sWidth ) {
				column.nTh.style.width = _fnStringToCss( column.sWidth );
			}
		}
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>If there is default sorting required - let&#39;s do it. The sort function
will do the drawing for us. Otherwise we draw the table regardless of the
Ajax source - this allows the table to look initialised for Ajax sourcing
data (show &#39;loading&#39; message possibly)</p></div></div><div class="code"><div class="wrapper">		_fnReDraw( settings );
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Server-side processing init complete is done by _fnAjaxUpdateDraw</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-keyword">var</span> dataSrc = _fnDataSource( settings );
		<span class="hljs-keyword">if</span> ( dataSrc != <span class="hljs-string">'ssp'</span> ) {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>if there is an ajax source load the data</p></div></div><div class="code"><div class="wrapper">			<span class="hljs-keyword">if</span> ( dataSrc == <span class="hljs-string">'ajax'</span> ) {
				_fnBuildAjax( settings, [], <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(json)</span> {</span>
					<span class="hljs-keyword">var</span> aData = _fnAjaxDataSrc( settings, json );
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Got the data - add it to the table</p></div></div><div class="code"><div class="wrapper">					<span class="hljs-keyword">for</span> ( i=<span class="hljs-number">0</span> ; i&lt;aData.length ; i++ ) {
						_fnAddData( settings, aData[i] );
					}
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Reset the init display for cookie saving. We&#39;ve already done
a filter, and therefore cleared it before. So we need to make
it appear &#39;fresh&#39;</p></div></div><div class="code"><div class="wrapper">					settings.iInitDisplayStart = iAjaxStart;
	
					_fnReDraw( settings );
	
					_fnProcessingDisplay( settings, <span class="hljs-literal">false</span> );
					_fnInitComplete( settings, json );
				}, settings );
			}
			<span class="hljs-keyword">else</span> {
				_fnProcessingDisplay( settings, <span class="hljs-literal">false</span> );
				_fnInitComplete( settings );
			}
		}
	}
	
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Draw the table for the first time, adding all required features
 @param {object} oSettings dataTables settings object
 @param {object} [json] JSON from the server that completed the table, if using Ajax source
   with client-side processing (optional)
 @memberof DataTable#oApi</p></div></div><div class="code"><div class="wrapper">	<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_fnInitComplete</span> <span class="hljs-params">( settings, json )</span>
	{</span>
		settings._bInitComplete = <span class="hljs-literal">true</span>;
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>On an Ajax load we now have data and therefore want to apply the column
sizing</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-keyword">if</span> ( json ) {
			_fnAdjustColumnSizing( settings );
		}
	
		_fnCallbackFire( settings, <span class="hljs-string">'aoInitComplete'</span>, <span class="hljs-string">'init'</span>, [settings, json] );
	}
	
	
	<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_fnLengthChange</span> <span class="hljs-params">( settings, val )</span>
	{</span>
		<span class="hljs-keyword">var</span> len = <span class="hljs-built_in">parseInt</span>( val, <span class="hljs-number">10</span> );
		settings._iDisplayLength = len;
	
		_fnLengthOverflow( settings );
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Fire length change event</p></div></div><div class="code"><div class="wrapper">		_fnCallbackFire( settings, <span class="hljs-literal">null</span>, <span class="hljs-string">'length'</span>, [settings, len] );
	}
	
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Generate the node required for user display length changing
 @param {object} settings dataTables settings object
 @returns {node} Display length feature node
 @memberof DataTable#oApi</p></div></div><div class="code"><div class="wrapper">	<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_fnFeatureHtmlLength</span> <span class="hljs-params">( settings )</span>
	{</span>
		<span class="hljs-keyword">var</span>
			classes  = settings.oClasses,
			tableId  = settings.sTableId,
			menu     = settings.aLengthMenu,
			d2       = $.isArray( menu[<span class="hljs-number">0</span>] ),
			lengths  = d2 ? menu[<span class="hljs-number">0</span>] : menu,
			language = d2 ? menu[<span class="hljs-number">1</span>] : menu;
	
		<span class="hljs-keyword">var</span> select = $(<span class="hljs-string">'&lt;select/&gt;'</span>, {
			<span class="hljs-string">'name'</span>:          tableId+<span class="hljs-string">'_length'</span>,
			<span class="hljs-string">'aria-controls'</span>: tableId,
			<span class="hljs-string">'class'</span>:         classes.sLengthSelect
		} );
	
		<span class="hljs-keyword">for</span> ( <span class="hljs-keyword">var</span> i=<span class="hljs-number">0</span>, ien=lengths.length ; i&lt;ien ; i++ ) {
			select[<span class="hljs-number">0</span>][ i ] = <span class="hljs-keyword">new</span> Option( language[i], lengths[i] );
		}
	
		<span class="hljs-keyword">var</span> div = $(<span class="hljs-string">'&lt;div&gt;&lt;label/&gt;&lt;/div&gt;'</span>).addClass( classes.sLength );
		<span class="hljs-keyword">if</span> ( ! settings.aanFeatures.l ) {
			div[<span class="hljs-number">0</span>].id = tableId+<span class="hljs-string">'_length'</span>;
		}
	
		div.children().append(
			settings.oLanguage.sLengthMenu.replace( <span class="hljs-string">'_MENU_'</span>, select[<span class="hljs-number">0</span>].outerHTML )
		);
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Can&#39;t use <code>select</code> variable as user might provide their own and the
reference is broken by the use of outerHTML</p></div></div><div class="code"><div class="wrapper">		$(<span class="hljs-string">'select'</span>, div)
			.val( settings._iDisplayLength )
			.bind( <span class="hljs-string">'change.DT'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(e)</span> {</span>
				_fnLengthChange( settings, $(<span class="hljs-keyword">this</span>).val() );
				_fnDraw( settings );
			} );
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Update node value whenever anything changes the table&#39;s length</p></div></div><div class="code"><div class="wrapper">		$(settings.nTable).bind( <span class="hljs-string">'length.dt.DT'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(e, s, len)</span> {</span>
			<span class="hljs-keyword">if</span> ( settings === s ) {
				$(<span class="hljs-string">'select'</span>, div).val( len );
			}
		} );
	
		<span class="hljs-keyword">return</span> div[<span class="hljs-number">0</span>];
	}
	
	
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><hr>
<p>Note that most of the paging logic is done in
DataTable.ext.pager</p></div></div><div class="code"><div class="wrapper">	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Generate the node required for default pagination
 @param {object} oSettings dataTables settings object
 @returns {node} Pagination feature node
 @memberof DataTable#oApi</p></div></div><div class="code"><div class="wrapper">	<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_fnFeatureHtmlPaginate</span> <span class="hljs-params">( settings )</span>
	{</span>
		<span class="hljs-keyword">var</span>
			type   = settings.sPaginationType,
			plugin = DataTable.ext.pager[ type ],
			modern = <span class="hljs-keyword">typeof</span> plugin === <span class="hljs-string">'function'</span>,
			redraw = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( settings )</span> {</span>
				_fnDraw( settings );
			},
			node = $(<span class="hljs-string">'&lt;div/&gt;'</span>).addClass( settings.oClasses.sPaging + type )[<span class="hljs-number">0</span>],
			features = settings.aanFeatures;
	
		<span class="hljs-keyword">if</span> ( ! modern ) {
			plugin.fnInit( settings, node, redraw );
		}
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Add a draw callback for the pagination on first instance, to update the paging display </p></div></div><div class="code"><div class="wrapper">		<span class="hljs-keyword">if</span> ( ! features.p )
		{
			node.id = settings.sTableId+<span class="hljs-string">'_paginate'</span>;
	
			settings.aoDrawCallback.push( {
				<span class="hljs-string">"fn"</span>: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( settings )</span> {</span>
					<span class="hljs-keyword">if</span> ( modern ) {
						<span class="hljs-keyword">var</span>
							start      = settings._iDisplayStart,
							len        = settings._iDisplayLength,
							visRecords = settings.fnRecordsDisplay(),
							all        = len === -<span class="hljs-number">1</span>,
							page = all ? <span class="hljs-number">0</span> : <span class="hljs-built_in">Math</span>.ceil( start / len ),
							pages = all ? <span class="hljs-number">1</span> : <span class="hljs-built_in">Math</span>.ceil( visRecords / len ),
							buttons = plugin(page, pages),
							i, ien;
	
						<span class="hljs-keyword">for</span> ( i=<span class="hljs-number">0</span>, ien=features.p.length ; i&lt;ien ; i++ ) {
							_fnRenderer( settings, <span class="hljs-string">'pageButton'</span> )(
								settings, features.p[i], i, buttons, page, pages
							);
						}
					}
					<span class="hljs-keyword">else</span> {
						plugin.fnUpdate( settings, redraw );
					}
				},
				<span class="hljs-string">"sName"</span>: <span class="hljs-string">"pagination"</span>
			} );
		}
	
		<span class="hljs-keyword">return</span> node;
	}
	
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Alter the display settings to change the page
 @param {object} settings DataTables settings object
 @param {string|int} action Paging action to take: &quot;first&quot;, &quot;previous&quot;,
   &quot;next&quot; or &quot;last&quot; or page number to jump to (integer)
 @param [bool] redraw Automatically draw the update or not
 @returns {bool} true page has changed, false - no change
 @memberof DataTable#oApi</p></div></div><div class="code"><div class="wrapper">	<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_fnPageChange</span> <span class="hljs-params">( settings, action, redraw )</span>
	{</span>
		<span class="hljs-keyword">var</span>
			start     = settings._iDisplayStart,
			len       = settings._iDisplayLength,
			records   = settings.fnRecordsDisplay();
	
		<span class="hljs-keyword">if</span> ( records === <span class="hljs-number">0</span> || len === -<span class="hljs-number">1</span> )
		{
			start = <span class="hljs-number">0</span>;
		}
		<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( <span class="hljs-keyword">typeof</span> action === <span class="hljs-string">"number"</span> )
		{
			start = action * len;
	
			<span class="hljs-keyword">if</span> ( start &gt; records )
			{
				start = <span class="hljs-number">0</span>;
			}
		}
		<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( action == <span class="hljs-string">"first"</span> )
		{
			start = <span class="hljs-number">0</span>;
		}
		<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( action == <span class="hljs-string">"previous"</span> )
		{
			start = len &gt;= <span class="hljs-number">0</span> ?
				start - len :
				<span class="hljs-number">0</span>;
	
			<span class="hljs-keyword">if</span> ( start &lt; <span class="hljs-number">0</span> )
			{
			  start = <span class="hljs-number">0</span>;
			}
		}
		<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( action == <span class="hljs-string">"next"</span> )
		{
			<span class="hljs-keyword">if</span> ( start + len &lt; records )
			{
				start += len;
			}
		}
		<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( action == <span class="hljs-string">"last"</span> )
		{
			start = <span class="hljs-built_in">Math</span>.floor( (records-<span class="hljs-number">1</span>) / len) * len;
		}
		<span class="hljs-keyword">else</span>
		{
			_fnLog( settings, <span class="hljs-number">0</span>, <span class="hljs-string">"Unknown paging action: "</span>+action, <span class="hljs-number">5</span> );
		}
	
		<span class="hljs-keyword">var</span> changed = settings._iDisplayStart !== start;
		settings._iDisplayStart = start;
	
		<span class="hljs-keyword">if</span> ( changed ) {
			_fnCallbackFire( settings, <span class="hljs-literal">null</span>, <span class="hljs-string">'page'</span>, [settings] );
	
			<span class="hljs-keyword">if</span> ( redraw ) {
				_fnDraw( settings );
			}
		}
	
		<span class="hljs-keyword">return</span> changed;
	}
	
	
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Generate the node required for the processing node
 @param {object} settings dataTables settings object
 @returns {node} Processing element
 @memberof DataTable#oApi</p></div></div><div class="code"><div class="wrapper">	<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_fnFeatureHtmlProcessing</span> <span class="hljs-params">( settings )</span>
	{</span>
		<span class="hljs-keyword">return</span> $(<span class="hljs-string">'&lt;div/&gt;'</span>, {
				<span class="hljs-string">'id'</span>: ! settings.aanFeatures.r ? settings.sTableId+<span class="hljs-string">'_processing'</span> : <span class="hljs-literal">null</span>,
				<span class="hljs-string">'class'</span>: settings.oClasses.sProcessing
			} )
			.html( settings.oLanguage.sProcessing )
			.insertBefore( settings.nTable )[<span class="hljs-number">0</span>];
	}
	
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Display or hide the processing indicator
 @param {object} settings dataTables settings object
 @param {bool} show Show the processing indicator (true) or not (false)
 @memberof DataTable#oApi</p></div></div><div class="code"><div class="wrapper">	<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_fnProcessingDisplay</span> <span class="hljs-params">( settings, show )</span>
	{</span>
		<span class="hljs-keyword">if</span> ( settings.oFeatures.bProcessing ) {
			$(settings.aanFeatures.r).css( <span class="hljs-string">'display'</span>, show ? <span class="hljs-string">'block'</span> : <span class="hljs-string">'none'</span> );
		}
	
		_fnCallbackFire( settings, <span class="hljs-literal">null</span>, <span class="hljs-string">'processing'</span>, [settings, show] );
	}
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Add any control elements for the table - specifically scrolling
 @param {object} settings dataTables settings object
 @returns {node} Node to add to the DOM
 @memberof DataTable#oApi</p></div></div><div class="code"><div class="wrapper">	<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_fnFeatureHtmlTable</span> <span class="hljs-params">( settings )</span>
	{</span>
		<span class="hljs-keyword">var</span> table = $(settings.nTable);
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Add the ARIA grid role to the table</p></div></div><div class="code"><div class="wrapper">		table.attr( <span class="hljs-string">'role'</span>, <span class="hljs-string">'grid'</span> );
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Scrolling from here on in</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-keyword">var</span> scroll = settings.oScroll;
	
		<span class="hljs-keyword">if</span> ( scroll.sX === <span class="hljs-string">''</span> &amp;&amp; scroll.sY === <span class="hljs-string">''</span> ) {
			<span class="hljs-keyword">return</span> settings.nTable;
		}
	
		<span class="hljs-keyword">var</span> scrollX = scroll.sX;
		<span class="hljs-keyword">var</span> scrollY = scroll.sY;
		<span class="hljs-keyword">var</span> classes = settings.oClasses;
		<span class="hljs-keyword">var</span> caption = table.children(<span class="hljs-string">'caption'</span>);
		<span class="hljs-keyword">var</span> captionSide = caption.length ? caption[<span class="hljs-number">0</span>]._captionSide : <span class="hljs-literal">null</span>;
		<span class="hljs-keyword">var</span> headerClone = $( table[<span class="hljs-number">0</span>].cloneNode(<span class="hljs-literal">false</span>) );
		<span class="hljs-keyword">var</span> footerClone = $( table[<span class="hljs-number">0</span>].cloneNode(<span class="hljs-literal">false</span>) );
		<span class="hljs-keyword">var</span> footer = table.children(<span class="hljs-string">'tfoot'</span>);
		<span class="hljs-keyword">var</span> _div = <span class="hljs-string">'&lt;div/&gt;'</span>;
		<span class="hljs-keyword">var</span> size = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">( s )</span> {</span>
			<span class="hljs-keyword">return</span> !s ? <span class="hljs-literal">null</span> : _fnStringToCss( s );
		};
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>This is fairly messy, but with x scrolling enabled, if the table has a
width attribute, regardless of any width applied using the column width
options, the browser will shrink or grow the table as needed to fit into
that 100%. That would make the width options useless. So we remove it.
This is okay, under the assumption that width:100% is applied to the
table in CSS (it is in the default stylesheet) which will set the table
width as appropriate (the attribute and css behave differently...)</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-keyword">if</span> ( scroll.sX &amp;&amp; table.attr(<span class="hljs-string">'width'</span>) === <span class="hljs-string">'100%'</span> ) {
			table.removeAttr(<span class="hljs-string">'width'</span>);
		}
	
		<span class="hljs-keyword">if</span> ( ! footer.length ) {
			footer = <span class="hljs-literal">null</span>;
		}
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>The HTML structure that we want to generate in this function is:
 div - scroller
   div - scroll head
     div - scroll head inner
       table - scroll head table
         thead - thead
   div - scroll body
     table - table (master table)
       thead - thead clone for sizing
       tbody - tbody
   div - scroll foot
     div - scroll foot inner
       table - scroll foot table
         tfoot - tfoot</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-keyword">var</span> scroller = $( _div, { <span class="hljs-string">'class'</span>: classes.sScrollWrapper } )
			.append(
				$(_div, { <span class="hljs-string">'class'</span>: classes.sScrollHead } )
					.css( {
						overflow: <span class="hljs-string">'hidden'</span>,
						position: <span class="hljs-string">'relative'</span>,
						border: <span class="hljs-number">0</span>,
						width: scrollX ? size(scrollX) : <span class="hljs-string">'100%'</span>
					} )
					.append(
						$(_div, { <span class="hljs-string">'class'</span>: classes.sScrollHeadInner } )
							.css( {
								<span class="hljs-string">'box-sizing'</span>: <span class="hljs-string">'content-box'</span>,
								width: scroll.sXInner || <span class="hljs-string">'100%'</span>
							} )
							.append(
								headerClone
									.removeAttr(<span class="hljs-string">'id'</span>)
									.css( <span class="hljs-string">'margin-left'</span>, <span class="hljs-number">0</span> )
									.append(
										table.children(<span class="hljs-string">'thead'</span>)
									)
							)
					)
					.append( captionSide === <span class="hljs-string">'top'</span> ? caption : <span class="hljs-literal">null</span> )
			)
			.append(
				$(_div, { <span class="hljs-string">'class'</span>: classes.sScrollBody } )
					.css( {
						overflow: <span class="hljs-string">'auto'</span>,
						height: size( scrollY ),
						width: size( scrollX )
					} )
					.append( table )
			);
	
		<span class="hljs-keyword">if</span> ( footer ) {
			scroller.append(
				$(_div, { <span class="hljs-string">'class'</span>: classes.sScrollFoot } )
					.css( {
						overflow: <span class="hljs-string">'hidden'</span>,
						border: <span class="hljs-number">0</span>,
						width: scrollX ? size(scrollX) : <span class="hljs-string">'100%'</span>
					} )
					.append(
						$(_div, { <span class="hljs-string">'class'</span>: classes.sScrollFootInner } )
							.append(
								footerClone
									.removeAttr(<span class="hljs-string">'id'</span>)
									.css( <span class="hljs-string">'margin-left'</span>, <span class="hljs-number">0</span> )
									.append(
										table.children(<span class="hljs-string">'tfoot'</span>)
									)
							)
					)
					.append( captionSide === <span class="hljs-string">'bottom'</span> ? caption : <span class="hljs-literal">null</span> )
			);
		}
	
		<span class="hljs-keyword">var</span> children = scroller.children();
		<span class="hljs-keyword">var</span> scrollHead = children[<span class="hljs-number">0</span>];
		<span class="hljs-keyword">var</span> scrollBody = children[<span class="hljs-number">1</span>];
		<span class="hljs-keyword">var</span> scrollFoot = footer ? children[<span class="hljs-number">2</span>] : <span class="hljs-literal">null</span>;
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>When the body is scrolled, then we also want to scroll the headers</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-keyword">if</span> ( scrollX ) {
			$(scrollBody).scroll( <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(e)</span> {</span>
				<span class="hljs-keyword">var</span> scrollLeft = <span class="hljs-keyword">this</span>.scrollLeft;
	
				scrollHead.scrollLeft = scrollLeft;
	
				<span class="hljs-keyword">if</span> ( footer ) {
					scrollFoot.scrollLeft = scrollLeft;
				}
			} );
		}
	
		settings.nScrollHead = scrollHead;
		settings.nScrollBody = scrollBody;
		settings.nScrollFoot = scrollFoot;
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>On redraw - align columns</p></div></div><div class="code"><div class="wrapper">		settings.aoDrawCallback.push( {
			<span class="hljs-string">"fn"</span>: _fnScrollDraw,
			<span class="hljs-string">"sName"</span>: <span class="hljs-string">"scrolling"</span>
		} );
	
		<span class="hljs-keyword">return</span> scroller[<span class="hljs-number">0</span>];
	}
	
	
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Update the header, footer and body tables for resizing - i.e. column
alignment.</p>
<p>Welcome to the most horrible function DataTables. The process that this
function follows is basically:</p>
<ol>
<li>Re-create the table inside the scrolling div</li>
<li>Take live measurements from the DOM</li>
<li>Apply the measurements to align the columns</li>
<li><p>Clean up</p>
<p>@param {object} settings dataTables settings object
@memberof DataTable#oApi</p>
</li>
</ol></div></div><div class="code"><div class="wrapper">	<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_fnScrollDraw</span> <span class="hljs-params">( settings )</span>
	{</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Given that this is such a monster function, a lot of variables are use
to try and keep the minimised size as small as possible</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-keyword">var</span>
			scroll         = settings.oScroll,
			scrollX        = scroll.sX,
			scrollXInner   = scroll.sXInner,
			scrollY        = scroll.sY,
			barWidth       = scroll.iBarWidth,
			divHeader      = $(settings.nScrollHead),
			divHeaderStyle = divHeader[<span class="hljs-number">0</span>].style,
			divHeaderInner = divHeader.children(<span class="hljs-string">'div'</span>),
			divHeaderInnerStyle = divHeaderInner[<span class="hljs-number">0</span>].style,
			divHeaderTable = divHeaderInner.children(<span class="hljs-string">'table'</span>),
			divBodyEl      = settings.nScrollBody,
			divBody        = $(divBodyEl),
			divBodyStyle   = divBodyEl.style,
			divFooter      = $(settings.nScrollFoot),
			divFooterInner = divFooter.children(<span class="hljs-string">'div'</span>),
			divFooterTable = divFooterInner.children(<span class="hljs-string">'table'</span>),
			header         = $(settings.nTHead),
			table          = $(settings.nTable),
			tableEl        = table[<span class="hljs-number">0</span>],
			tableStyle     = tableEl.style,
			footer         = settings.nTFoot ? $(settings.nTFoot) : <span class="hljs-literal">null</span>,
			browser        = settings.oBrowser,
			ie67           = browser.bScrollOversize,
			headerTrgEls, footerTrgEls,
			headerSrcEls, footerSrcEls,
			headerCopy, footerCopy,
			headerWidths=[], footerWidths=[],
			headerContent=[],
			idx, correction, sanityWidth,
			zeroOut = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(nSizer)</span> {</span>
				<span class="hljs-keyword">var</span> style = nSizer.style;
				style.paddingTop = <span class="hljs-string">"0"</span>;
				style.paddingBottom = <span class="hljs-string">"0"</span>;
				style.borderTopWidth = <span class="hljs-string">"0"</span>;
				style.borderBottomWidth = <span class="hljs-string">"0"</span>;
				style.height = <span class="hljs-number">0</span>;
			};
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><ol>
<li>Re-create the table inside the scrolling div</li>
</ol></div></div><div class="code"><div class="wrapper">	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Remove the old minimised thead and tfoot elements in the inner table</p></div></div><div class="code"><div class="wrapper">		table.children(<span class="hljs-string">'thead, tfoot'</span>).remove();
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Clone the current header and footer elements and then place it into the inner table</p></div></div><div class="code"><div class="wrapper">		headerCopy = header.clone().prependTo( table );
		headerTrgEls = header.find(<span class="hljs-string">'tr'</span>); <span class="hljs-comment">// original header is in its own table</span>
		headerSrcEls = headerCopy.find(<span class="hljs-string">'tr'</span>);
		headerCopy.find(<span class="hljs-string">'th, td'</span>).removeAttr(<span class="hljs-string">'tabindex'</span>);
	
		<span class="hljs-keyword">if</span> ( footer ) {
			footerCopy = footer.clone().prependTo( table );
			footerTrgEls = footer.find(<span class="hljs-string">'tr'</span>); <span class="hljs-comment">// the original tfoot is in its own table and must be sized</span>
			footerSrcEls = footerCopy.find(<span class="hljs-string">'tr'</span>);
		}
	
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><ol>
<li>Take live measurements from the DOM - do not alter the DOM itself!</li>
</ol></div></div><div class="code"><div class="wrapper">	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Remove old sizing and apply the calculated column widths
Get the unique column headers in the newly created (cloned) header. We want to apply the
calculated sizes to this header</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-keyword">if</span> ( ! scrollX )
		{
			divBodyStyle.width = <span class="hljs-string">'100%'</span>;
			divHeader[<span class="hljs-number">0</span>].style.width = <span class="hljs-string">'100%'</span>;
		}
	
		$.each( _fnGetUniqueThs( settings, headerCopy ), <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">( i, el )</span> {</span>
			idx = _fnVisibleToColumnIndex( settings, i );
			el.style.width = settings.aoColumns[idx].sWidth;
		} );
	
		<span class="hljs-keyword">if</span> ( footer ) {
			_fnApplyToChildren( <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(n)</span> {</span>
				n.style.width = <span class="hljs-string">""</span>;
			}, footerSrcEls );
		}
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>If scroll collapse is enabled, when we put the headers back into the body for sizing, we
will end up forcing the scrollbar to appear, making our measurements wrong for when we
then hide it (end of this function), so add the header height to the body scroller.</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-keyword">if</span> ( scroll.bCollapse &amp;&amp; scrollY !== <span class="hljs-string">""</span> ) {
			divBodyStyle.height = (divBody[<span class="hljs-number">0</span>].offsetHeight + header[<span class="hljs-number">0</span>].offsetHeight)+<span class="hljs-string">"px"</span>;
		}
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Size the table as a whole</p></div></div><div class="code"><div class="wrapper">		sanityWidth = table.outerWidth();
		<span class="hljs-keyword">if</span> ( scrollX === <span class="hljs-string">""</span> ) {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>No x scrolling</p></div></div><div class="code"><div class="wrapper">			tableStyle.width = <span class="hljs-string">"100%"</span>;
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>IE7 will make the width of the table when 100% include the scrollbar</p>
<ul>
<li>which is shouldn&#39;t. When there is a scrollbar we need to take this
into account.</li>
</ul></div></div><div class="code"><div class="wrapper">			<span class="hljs-keyword">if</span> ( ie67 &amp;&amp; (table.find(<span class="hljs-string">'tbody'</span>).height() &gt; divBodyEl.offsetHeight ||
				divBody.css(<span class="hljs-string">'overflow-y'</span>) == <span class="hljs-string">"scroll"</span>)
			) {
				tableStyle.width = _fnStringToCss( table.outerWidth() - barWidth);
			}
		}
		<span class="hljs-keyword">else</span>
		{</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>x scrolling</p></div></div><div class="code"><div class="wrapper">			<span class="hljs-keyword">if</span> ( scrollXInner !== <span class="hljs-string">""</span> ) {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>x scroll inner has been given - use it</p></div></div><div class="code"><div class="wrapper">				tableStyle.width = _fnStringToCss(scrollXInner);
			}
			<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( sanityWidth == divBody.width() &amp;&amp; divBody.height() &lt; table.height() ) {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>There is y-scrolling - try to take account of the y scroll bar</p></div></div><div class="code"><div class="wrapper">				tableStyle.width = _fnStringToCss( sanityWidth-barWidth );
				<span class="hljs-keyword">if</span> ( table.outerWidth() &gt; sanityWidth-barWidth ) {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Not possible to take account of it</p></div></div><div class="code"><div class="wrapper">					tableStyle.width = _fnStringToCss( sanityWidth );
				}
			}
			<span class="hljs-keyword">else</span> {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>When all else fails</p></div></div><div class="code"><div class="wrapper">				tableStyle.width = _fnStringToCss( sanityWidth );
			}
		}
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Recalculate the sanity width - now that we&#39;ve applied the required width,
before it was a temporary variable. This is required because the column
width calculation is done before this table DOM is created.</p></div></div><div class="code"><div class="wrapper">		sanityWidth = table.outerWidth();
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Hidden header should have zero height, so remove padding and borders. Then
set the width based on the real headers</p></div></div><div class="code"><div class="wrapper">	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Apply all styles in one pass</p></div></div><div class="code"><div class="wrapper">		_fnApplyToChildren( zeroOut, headerSrcEls );
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Read all widths in next pass</p></div></div><div class="code"><div class="wrapper">		_fnApplyToChildren( <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(nSizer)</span> {</span>
			headerContent.push( nSizer.innerHTML );
			headerWidths.push( _fnStringToCss( $(nSizer).css(<span class="hljs-string">'width'</span>) ) );
		}, headerSrcEls );
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Apply all widths in final pass</p></div></div><div class="code"><div class="wrapper">		_fnApplyToChildren( <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(nToSize, i)</span> {</span>
			nToSize.style.width = headerWidths[i];
		}, headerTrgEls );
	
		$(headerSrcEls).height(<span class="hljs-number">0</span>);
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Same again with the footer if we have one </p></div></div><div class="code"><div class="wrapper">		<span class="hljs-keyword">if</span> ( footer )
		{
			_fnApplyToChildren( zeroOut, footerSrcEls );
	
			_fnApplyToChildren( <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(nSizer)</span> {</span>
				footerWidths.push( _fnStringToCss( $(nSizer).css(<span class="hljs-string">'width'</span>) ) );
			}, footerSrcEls );
	
			_fnApplyToChildren( <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(nToSize, i)</span> {</span>
				nToSize.style.width = footerWidths[i];
			}, footerTrgEls );
	
			$(footerSrcEls).height(<span class="hljs-number">0</span>);
		}
	
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><ol>
<li>Apply the measurements</li>
</ol></div></div><div class="code"><div class="wrapper">	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>&quot;Hide&quot; the header and footer that we used for the sizing. We need to keep
the content of the cell so that the width applied to the header and body
both match, but we want to hide it completely. We want to also fix their
width to what they currently are</p></div></div><div class="code"><div class="wrapper">		_fnApplyToChildren( <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(nSizer, i)</span> {</span>
			nSizer.innerHTML = <span class="hljs-string">'&lt;div class="dataTables_sizing" style="height:0;overflow:hidden;"&gt;'</span>+headerContent[i]+<span class="hljs-string">'&lt;/div&gt;'</span>;
			nSizer.style.width = headerWidths[i];
		}, headerSrcEls );
	
		<span class="hljs-keyword">if</span> ( footer )
		{
			_fnApplyToChildren( <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(nSizer, i)</span> {</span>
				nSizer.innerHTML = <span class="hljs-string">""</span>;
				nSizer.style.width = footerWidths[i];
			}, footerSrcEls );
		}
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Sanity check that the table is of a sensible width. If not then we are going to get
misalignment - try to prevent this by not allowing the table to shrink below its min width</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-keyword">if</span> ( table.outerWidth() &lt; sanityWidth )
		{</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>The min width depends upon if we have a vertical scrollbar visible or not */</p></div></div><div class="code"><div class="wrapper">			correction = ((divBodyEl.scrollHeight &gt; divBodyEl.offsetHeight ||
				divBody.css(<span class="hljs-string">'overflow-y'</span>) == <span class="hljs-string">"scroll"</span>)) ?
					sanityWidth+barWidth :
					sanityWidth;
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>IE6/7 are a law unto themselves...</p></div></div><div class="code"><div class="wrapper">			<span class="hljs-keyword">if</span> ( ie67 &amp;&amp; (divBodyEl.scrollHeight &gt;
				divBodyEl.offsetHeight || divBody.css(<span class="hljs-string">'overflow-y'</span>) == <span class="hljs-string">"scroll"</span>)
			) {
				tableStyle.width = _fnStringToCss( correction-barWidth );
			}
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>And give the user a warning that we&#39;ve stopped the table getting too small</p></div></div><div class="code"><div class="wrapper">			<span class="hljs-keyword">if</span> ( scrollX === <span class="hljs-string">""</span> || scrollXInner !== <span class="hljs-string">""</span> ) {
				_fnLog( settings, <span class="hljs-number">1</span>, <span class="hljs-string">'Possible column misalignment'</span>, <span class="hljs-number">6</span> );
			}
		}
		<span class="hljs-keyword">else</span>
		{
			correction = <span class="hljs-string">'100%'</span>;
		}
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Apply to the container elements</p></div></div><div class="code"><div class="wrapper">		divBodyStyle.width = _fnStringToCss( correction );
		divHeaderStyle.width = _fnStringToCss( correction );
	
		<span class="hljs-keyword">if</span> ( footer ) {
			settings.nScrollFoot.style.width = _fnStringToCss( correction );
		}
	
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><ol>
<li>Clean up</li>
</ol></div></div><div class="code"><div class="wrapper">		<span class="hljs-keyword">if</span> ( ! scrollY ) {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>IE7&lt; puts a vertical scrollbar in place (when it shouldn&#39;t be) due to subtracting
the scrollbar height from the visible display, rather than adding it on. We need to
set the height in order to sort this. Don&#39;t want to do it in any other browsers.</p></div></div><div class="code"><div class="wrapper">			<span class="hljs-keyword">if</span> ( ie67 ) {
				divBodyStyle.height = _fnStringToCss( tableEl.offsetHeight+barWidth );
			}
		}
	
		<span class="hljs-keyword">if</span> ( scrollY &amp;&amp; scroll.bCollapse ) {
			divBodyStyle.height = _fnStringToCss( scrollY );
	
			<span class="hljs-keyword">var</span> iExtra = (scrollX &amp;&amp; tableEl.offsetWidth &gt; divBodyEl.offsetWidth) ?
				barWidth :
				<span class="hljs-number">0</span>;
	
			<span class="hljs-keyword">if</span> ( tableEl.offsetHeight &lt; divBodyEl.offsetHeight ) {
				divBodyStyle.height = _fnStringToCss( tableEl.offsetHeight+iExtra );
			}
		}
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Finally set the width&#39;s of the header and footer tables </p></div></div><div class="code"><div class="wrapper">		<span class="hljs-keyword">var</span> iOuterWidth = table.outerWidth();
		divHeaderTable[<span class="hljs-number">0</span>].style.width = _fnStringToCss( iOuterWidth );
		divHeaderInnerStyle.width = _fnStringToCss( iOuterWidth );
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Figure out if there are scrollbar present - if so then we need a the header and footer to
provide a bit more space to allow &quot;overflow&quot; scrolling (i.e. past the scrollbar)</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-keyword">var</span> bScrolling = table.height() &gt; divBodyEl.clientHeight || divBody.css(<span class="hljs-string">'overflow-y'</span>) == <span class="hljs-string">"scroll"</span>;
		<span class="hljs-keyword">var</span> padding = <span class="hljs-string">'padding'</span> + (browser.bScrollbarLeft ? <span class="hljs-string">'Left'</span> : <span class="hljs-string">'Right'</span> );
		divHeaderInnerStyle[ padding ] = bScrolling ? barWidth+<span class="hljs-string">"px"</span> : <span class="hljs-string">"0px"</span>;
	
		<span class="hljs-keyword">if</span> ( footer ) {
			divFooterTable[<span class="hljs-number">0</span>].style.width = _fnStringToCss( iOuterWidth );
			divFooterInner[<span class="hljs-number">0</span>].style.width = _fnStringToCss( iOuterWidth );
			divFooterInner[<span class="hljs-number">0</span>].style[padding] = bScrolling ? barWidth+<span class="hljs-string">"px"</span> : <span class="hljs-string">"0px"</span>;
		}
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Adjust the position of the header in case we loose the y-scrollbar </p></div></div><div class="code"><div class="wrapper">		divBody.scroll();
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>If sorting or filtering has occurred, jump the scrolling back to the top
only if we aren&#39;t holding the position</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-keyword">if</span> ( (settings.bSorted || settings.bFiltered) &amp;&amp; ! settings._drawHold ) {
			divBodyEl.scrollTop = <span class="hljs-number">0</span>;
		}
	}
	
	
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Apply a given function to the display child nodes of an element array (typically
TD children of TR rows
 @param {function} fn Method to apply to the objects
 @param array {nodes} an1 List of elements to look through for display children
 @param array {nodes} an2 Another list (identical structure to the first) - optional
 @memberof DataTable#oApi</p></div></div><div class="code"><div class="wrapper">	<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_fnApplyToChildren</span><span class="hljs-params">( fn, an1, an2 )</span>
	{</span>
		<span class="hljs-keyword">var</span> index=<span class="hljs-number">0</span>, i=<span class="hljs-number">0</span>, iLen=an1.length;
		<span class="hljs-keyword">var</span> nNode1, nNode2;
	
		<span class="hljs-keyword">while</span> ( i &lt; iLen ) {
			nNode1 = an1[i].firstChild;
			nNode2 = an2 ? an2[i].firstChild : <span class="hljs-literal">null</span>;
	
			<span class="hljs-keyword">while</span> ( nNode1 ) {
				<span class="hljs-keyword">if</span> ( nNode1.nodeType === <span class="hljs-number">1</span> ) {
					<span class="hljs-keyword">if</span> ( an2 ) {
						fn( nNode1, nNode2, index );
					}
					<span class="hljs-keyword">else</span> {
						fn( nNode1, index );
					}
	
					index++;
				}
	
				nNode1 = nNode1.nextSibling;
				nNode2 = an2 ? nNode2.nextSibling : <span class="hljs-literal">null</span>;
			}
	
			i++;
		}
	}
	
	
	
	<span class="hljs-keyword">var</span> __re_html_remove = <span class="hljs-regexp">/&lt;.*?&gt;/g</span>;
	
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Calculate the width of columns for the table
 @param {object} oSettings dataTables settings object
 @memberof DataTable#oApi</p></div></div><div class="code"><div class="wrapper">	<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_fnCalculateColumnWidths</span> <span class="hljs-params">( oSettings )</span>
	{</span>
		<span class="hljs-keyword">var</span>
			table = oSettings.nTable,
			columns = oSettings.aoColumns,
			scroll = oSettings.oScroll,
			scrollY = scroll.sY,
			scrollX = scroll.sX,
			scrollXInner = scroll.sXInner,
			columnCount = columns.length,
			visibleColumns = _fnGetColumns( oSettings, <span class="hljs-string">'bVisible'</span> ),
			headerCells = $(<span class="hljs-string">'th'</span>, oSettings.nTHead),
			tableWidthAttr = table.getAttribute(<span class="hljs-string">'width'</span>),
			tableContainer = table.parentNode,
			userInputs = <span class="hljs-literal">false</span>,
			i, column, columnIdx, width, outerWidth;
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Convert any user input sizes into pixel sizes </p></div></div><div class="code"><div class="wrapper">		<span class="hljs-keyword">for</span> ( i=<span class="hljs-number">0</span> ; i&lt;visibleColumns.length ; i++ ) {
			column = columns[ visibleColumns[i] ];
	
			<span class="hljs-keyword">if</span> ( column.sWidth !== <span class="hljs-literal">null</span> ) {
				column.sWidth = _fnConvertToWidth( column.sWidthOrig, tableContainer );
	
				userInputs = <span class="hljs-literal">true</span>;
			}
		}
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>If the number of columns in the DOM equals the number that we have to
process in DataTables, then we can use the offsets that are created by
the web- browser. No custom sizes can be set in order for this to happen,
nor scrolling used</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-keyword">if</span> ( ! userInputs &amp;&amp; ! scrollX &amp;&amp; ! scrollY &amp;&amp;
		    columnCount == _fnVisbleColumns( oSettings ) &amp;&amp;
			columnCount == headerCells.length
		) {
			<span class="hljs-keyword">for</span> ( i=<span class="hljs-number">0</span> ; i&lt;columnCount ; i++ ) {
				columns[i].sWidth = _fnStringToCss( headerCells.eq(i).width() );
			}
		}
		<span class="hljs-keyword">else</span>
		{</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Otherwise construct a single row table with the widest node in the
data, assign any user defined widths, then insert it into the DOM and
allow the browser to do all the hard work of calculating table widths</p></div></div><div class="code"><div class="wrapper">			<span class="hljs-keyword">var</span> tmpTable = $(table).clone() <span class="hljs-comment">// don't use cloneNode - IE8 will remove events on the main table</span>
				.empty()
				.css( <span class="hljs-string">'visibility'</span>, <span class="hljs-string">'hidden'</span> )
				.removeAttr( <span class="hljs-string">'id'</span> )
				.append( $(oSettings.nTHead).clone( <span class="hljs-literal">false</span> ) )
				.append( $(oSettings.nTFoot).clone( <span class="hljs-literal">false</span> ) )
				.append( $(<span class="hljs-string">'&lt;tbody&gt;&lt;tr/&gt;&lt;/tbody&gt;'</span>) );
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Remove any assigned widths from the footer (from scrolling)</p></div></div><div class="code"><div class="wrapper">			tmpTable.find(<span class="hljs-string">'tfoot th, tfoot td'</span>).css(<span class="hljs-string">'width'</span>, <span class="hljs-string">''</span>);
	
			<span class="hljs-keyword">var</span> tr = tmpTable.find( <span class="hljs-string">'tbody tr'</span> );
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Apply custom sizing to the cloned header</p></div></div><div class="code"><div class="wrapper">			headerCells = _fnGetUniqueThs( oSettings, tmpTable.find(<span class="hljs-string">'thead'</span>)[<span class="hljs-number">0</span>] );
	
			<span class="hljs-keyword">for</span> ( i=<span class="hljs-number">0</span> ; i&lt;visibleColumns.length ; i++ ) {
				column = columns[ visibleColumns[i] ];
	
				headerCells[i].style.width = column.sWidthOrig !== <span class="hljs-literal">null</span> &amp;&amp; column.sWidthOrig !== <span class="hljs-string">''</span> ?
					_fnStringToCss( column.sWidthOrig ) :
					<span class="hljs-string">''</span>;
			}
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Find the widest cell for each column and put it into the table</p></div></div><div class="code"><div class="wrapper">			<span class="hljs-keyword">if</span> ( oSettings.aoData.length ) {
				<span class="hljs-keyword">for</span> ( i=<span class="hljs-number">0</span> ; i&lt;visibleColumns.length ; i++ ) {
					columnIdx = visibleColumns[i];
					column = columns[ columnIdx ];
	
					$( _fnGetWidestNode( oSettings, columnIdx ) )
						.clone( <span class="hljs-literal">false</span> )
						.append( column.sContentPadding )
						.appendTo( tr );
				}
			}
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Table has been built, attach to the document so we can work with it</p></div></div><div class="code"><div class="wrapper">			tmpTable.appendTo( tableContainer );
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>When scrolling (X or Y) we want to set the width of the table as 
appropriate. However, when not scrolling leave the table width as it
is. This results in slightly different, but I think correct behaviour</p></div></div><div class="code"><div class="wrapper">			<span class="hljs-keyword">if</span> ( scrollX &amp;&amp; scrollXInner ) {
				tmpTable.width( scrollXInner );
			}
			<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( scrollX ) {
				tmpTable.css( <span class="hljs-string">'width'</span>, <span class="hljs-string">'auto'</span> );
	
				<span class="hljs-keyword">if</span> ( tmpTable.width() &lt; tableContainer.offsetWidth ) {
					tmpTable.width( tableContainer.offsetWidth );
				}
			}
			<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( scrollY ) {
				tmpTable.width( tableContainer.offsetWidth );
			}
			<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( tableWidthAttr ) {
				tmpTable.width( tableWidthAttr );
			}
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Take into account the y scrollbar</p></div></div><div class="code"><div class="wrapper">			_fnScrollingWidthAdjust( oSettings, tmpTable[<span class="hljs-number">0</span>] );
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Browsers need a bit of a hand when a width is assigned to any columns
when x-scrolling as they tend to collapse the table to the min-width,
even if we sent the column widths. So we need to keep track of what
the table width should be by summing the user given values, and the
automatic values</p></div></div><div class="code"><div class="wrapper">			<span class="hljs-keyword">if</span> ( scrollX )
			{
				<span class="hljs-keyword">var</span> total = <span class="hljs-number">0</span>;
	
				<span class="hljs-keyword">for</span> ( i=<span class="hljs-number">0</span> ; i&lt;visibleColumns.length ; i++ ) {
					column = columns[ visibleColumns[i] ];
					outerWidth = $(headerCells[i]).outerWidth();
	
					total += column.sWidthOrig === <span class="hljs-literal">null</span> ?
						outerWidth :
						<span class="hljs-built_in">parseInt</span>( column.sWidth, <span class="hljs-number">10</span> ) + outerWidth - $(headerCells[i]).width();
				}
	
				tmpTable.width( _fnStringToCss( total ) );
				table.style.width = _fnStringToCss( total );
			}
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Get the width of each column in the constructed table</p></div></div><div class="code"><div class="wrapper">			<span class="hljs-keyword">for</span> ( i=<span class="hljs-number">0</span> ; i&lt;visibleColumns.length ; i++ ) {
				column = columns[ visibleColumns[i] ];
				width = $(headerCells[i]).width();
	
				<span class="hljs-keyword">if</span> ( width ) {
					column.sWidth = _fnStringToCss( width );
				}
			}
	
			table.style.width = _fnStringToCss( tmpTable.css(<span class="hljs-string">'width'</span>) );
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Finished with the table - ditch it</p></div></div><div class="code"><div class="wrapper">			tmpTable.remove();
		}
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>If there is a width attr, we want to attach an event listener which
allows the table sizing to automatically adjust when the window is
resized. Use the width attr rather than CSS, since we can&#39;t know if the
CSS is a relative value or absolute - DOM read is always px.</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-keyword">if</span> ( tableWidthAttr ) {
			table.style.width = _fnStringToCss( tableWidthAttr );
		}
	
		<span class="hljs-keyword">if</span> ( (tableWidthAttr || scrollX) &amp;&amp; ! oSettings._reszEvt ) {
			$(window).bind(<span class="hljs-string">'resize.DT-'</span>+oSettings.sInstance, _fnThrottle( <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
				_fnAdjustColumnSizing( oSettings );
			} ) );
	
			oSettings._reszEvt = <span class="hljs-literal">true</span>;
		}
	}
	
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Throttle the calls to a function. Arguments and context are maintained for
the throttled function
 @param {function} fn Function to be called
 @param {int} [freq=200] call frequency in mS
 @returns {function} wrapped function
 @memberof DataTable#oApi</p></div></div><div class="code"><div class="wrapper">	<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_fnThrottle</span><span class="hljs-params">( fn, freq )</span> {</span>
		<span class="hljs-keyword">var</span>
			frequency = freq || <span class="hljs-number">200</span>,
			last,
			timer;
	
		<span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
			<span class="hljs-keyword">var</span>
				that = <span class="hljs-keyword">this</span>,
				now  = +<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(),
				args = <span class="hljs-built_in">arguments</span>;
	
			<span class="hljs-keyword">if</span> ( last &amp;&amp; now &lt; last + frequency ) {
				clearTimeout( timer );
	
				timer = setTimeout( <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
					last = <span class="hljs-literal">undefined</span>;
					fn.apply( that, args );
				}, frequency );
			}
			<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( last ) {
				last = now;
				fn.apply( that, args );
			}
			<span class="hljs-keyword">else</span> {
				last = now;
			}
		};
	}
	
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Convert a CSS unit width to pixels (e.g. 2em)
 @param {string} width width to be converted
 @param {node} parent parent to get the with for (required for relative widths) - optional
 @returns {int} width in pixels
 @memberof DataTable#oApi</p></div></div><div class="code"><div class="wrapper">	<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_fnConvertToWidth</span> <span class="hljs-params">( width, parent )</span>
	{</span>
		<span class="hljs-keyword">if</span> ( ! width ) {
			<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
		}
	
		<span class="hljs-keyword">var</span> n = $(<span class="hljs-string">'&lt;div/&gt;'</span>)
			.css( <span class="hljs-string">'width'</span>, _fnStringToCss( width ) )
			.appendTo( parent || document.body );
	
		<span class="hljs-keyword">var</span> val = n[<span class="hljs-number">0</span>].offsetWidth;
		n.remove();
	
		<span class="hljs-keyword">return</span> val;
	}
	
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Adjust a table&#39;s width to take account of vertical scroll bar
 @param {object} oSettings dataTables settings object
 @param {node} n table node
 @memberof DataTable#oApi</p></div></div><div class="code"><div class="wrapper">	
	<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_fnScrollingWidthAdjust</span> <span class="hljs-params">( settings, n )</span>
	{</span>
		<span class="hljs-keyword">var</span> scroll = settings.oScroll;
	
		<span class="hljs-keyword">if</span> ( scroll.sX || scroll.sY ) {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>When y-scrolling only, we want to remove the width of the scroll bar
so the table + scroll bar will fit into the area available, otherwise
we fix the table at its current size with no adjustment</p></div></div><div class="code"><div class="wrapper">			<span class="hljs-keyword">var</span> correction = ! scroll.sX ? scroll.iBarWidth : <span class="hljs-number">0</span>;
			n.style.width = _fnStringToCss( $(n).outerWidth() - correction );
		}
	}
	
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Get the widest node
 @param {object} settings dataTables settings object
 @param {int} colIdx column of interest
 @returns {node} widest table node
 @memberof DataTable#oApi</p></div></div><div class="code"><div class="wrapper">	<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_fnGetWidestNode</span><span class="hljs-params">( settings, colIdx )</span>
	{</span>
		<span class="hljs-keyword">var</span> idx = _fnGetMaxLenString( settings, colIdx );
		<span class="hljs-keyword">if</span> ( idx &lt; <span class="hljs-number">0</span> ) {
			<span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
		}
	
		<span class="hljs-keyword">var</span> data = settings.aoData[ idx ];
		<span class="hljs-keyword">return</span> ! data.nTr ? <span class="hljs-comment">// Might not have been created when deferred rendering</span>
			$(<span class="hljs-string">'&lt;td/&gt;'</span>).html( _fnGetCellData( settings, idx, colIdx, <span class="hljs-string">'display'</span> ) )[<span class="hljs-number">0</span>] :
			data.anCells[ colIdx ];
	}
	
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Get the maximum strlen for each data column
 @param {object} settings dataTables settings object
 @param {int} colIdx column of interest
 @returns {string} max string length for each column
 @memberof DataTable#oApi</p></div></div><div class="code"><div class="wrapper">	<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_fnGetMaxLenString</span><span class="hljs-params">( settings, colIdx )</span>
	{</span>
		<span class="hljs-keyword">var</span> s, max=-<span class="hljs-number">1</span>, maxIdx = -<span class="hljs-number">1</span>;
	
		<span class="hljs-keyword">for</span> ( <span class="hljs-keyword">var</span> i=<span class="hljs-number">0</span>, ien=settings.aoData.length ; i&lt;ien ; i++ ) {
			s = _fnGetCellData( settings, i, colIdx, <span class="hljs-string">'display'</span> )+<span class="hljs-string">''</span>;
			s = s.replace( __re_html_remove, <span class="hljs-string">''</span> );
	
			<span class="hljs-keyword">if</span> ( s.length &gt; max ) {
				max = s.length;
				maxIdx = i;
			}
		}
	
		<span class="hljs-keyword">return</span> maxIdx;
	}
	
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Append a CSS unit (only if required) to a string
 @param {string} value to css-ify
 @returns {string} value with css unit
 @memberof DataTable#oApi</p></div></div><div class="code"><div class="wrapper">	<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_fnStringToCss</span><span class="hljs-params">( s )</span>
	{</span>
		<span class="hljs-keyword">if</span> ( s === <span class="hljs-literal">null</span> ) {
			<span class="hljs-keyword">return</span> <span class="hljs-string">'0px'</span>;
		}
	
		<span class="hljs-keyword">if</span> ( <span class="hljs-keyword">typeof</span> s == <span class="hljs-string">'number'</span> ) {
			<span class="hljs-keyword">return</span> s &lt; <span class="hljs-number">0</span> ?
				<span class="hljs-string">'0px'</span> :
				s+<span class="hljs-string">'px'</span>;
		}
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Check it has a unit character already</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-keyword">return</span> s.match(<span class="hljs-regexp">/\d$/</span>) ?
			s+<span class="hljs-string">'px'</span> :
			s;
	}
	
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Get the width of a scroll bar in this browser being used
 @returns {int} width in pixels
 @memberof DataTable#oApi</p></div></div><div class="code"><div class="wrapper">	<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_fnScrollBarWidth</span> <span class="hljs-params">()</span>
	{</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>On first run a static variable is set, since this is only needed once.
Subsequent runs will just use the previously calculated value</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-keyword">if</span> ( ! DataTable.__scrollbarWidth ) {
			<span class="hljs-keyword">var</span> inner = $(<span class="hljs-string">'&lt;p/&gt;'</span>).css( {
				width: <span class="hljs-string">'100%'</span>,
				height: <span class="hljs-number">200</span>,
				padding: <span class="hljs-number">0</span>
			} )[<span class="hljs-number">0</span>];
	
			<span class="hljs-keyword">var</span> outer = $(<span class="hljs-string">'&lt;div/&gt;'</span>)
				.css( {
					position: <span class="hljs-string">'absolute'</span>,
					top: <span class="hljs-number">0</span>,
					left: <span class="hljs-number">0</span>,
					width: <span class="hljs-number">200</span>,
					height: <span class="hljs-number">150</span>,
					padding: <span class="hljs-number">0</span>,
					overflow: <span class="hljs-string">'hidden'</span>,
					visibility: <span class="hljs-string">'hidden'</span>
				} )
				.append( inner )
				.appendTo( <span class="hljs-string">'body'</span> );
	
			<span class="hljs-keyword">var</span> w1 = inner.offsetWidth;
			outer.css( <span class="hljs-string">'overflow'</span>, <span class="hljs-string">'scroll'</span> );
			<span class="hljs-keyword">var</span> w2 = inner.offsetWidth;
	
			<span class="hljs-keyword">if</span> ( w1 === w2 ) {
				w2 = outer[<span class="hljs-number">0</span>].clientWidth;
			}
	
			outer.remove();
	
			DataTable.__scrollbarWidth = w1 - w2;
		}
	
		<span class="hljs-keyword">return</span> DataTable.__scrollbarWidth;
	}
	
	
	
	<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_fnSortFlatten</span> <span class="hljs-params">( settings )</span>
	{</span>
		<span class="hljs-keyword">var</span>
			i, iLen, k, kLen,
			aSort = [],
			aiOrig = [],
			aoColumns = settings.aoColumns,
			aDataSort, iCol, sType, srcCol,
			fixed = settings.aaSortingFixed,
			fixedObj = $.isPlainObject( fixed ),
			nestedSort = [],
			add = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">( a )</span> {</span>
				<span class="hljs-keyword">if</span> ( a.length &amp;&amp; ! $.isArray( a[<span class="hljs-number">0</span>] ) ) {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>1D array</p></div></div><div class="code"><div class="wrapper">					nestedSort.push( a );
				}
				<span class="hljs-keyword">else</span> {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>2D array</p></div></div><div class="code"><div class="wrapper">					nestedSort.push.apply( nestedSort, a );
				}
			};
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Build the sort array, with pre-fix and post-fix options if they have been
specified</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-keyword">if</span> ( $.isArray( fixed ) ) {
			add( fixed );
		}
	
		<span class="hljs-keyword">if</span> ( fixedObj &amp;&amp; fixed.pre ) {
			add( fixed.pre );
		}
	
		add( settings.aaSorting );
	
		<span class="hljs-keyword">if</span> (fixedObj &amp;&amp; fixed.post ) {
			add( fixed.post );
		}
	
		<span class="hljs-keyword">for</span> ( i=<span class="hljs-number">0</span> ; i&lt;nestedSort.length ; i++ )
		{
			srcCol = nestedSort[i][<span class="hljs-number">0</span>];
			aDataSort = aoColumns[ srcCol ].aDataSort;
	
			<span class="hljs-keyword">for</span> ( k=<span class="hljs-number">0</span>, kLen=aDataSort.length ; k&lt;kLen ; k++ )
			{
				iCol = aDataSort[k];
				sType = aoColumns[ iCol ].sType || <span class="hljs-string">'string'</span>;
	
				aSort.push( {
					src:       srcCol,
					col:       iCol,
					dir:       nestedSort[i][<span class="hljs-number">1</span>],
					index:     nestedSort[i][<span class="hljs-number">2</span>],
					type:      sType,
					formatter: DataTable.ext.type.order[ sType+<span class="hljs-string">"-pre"</span> ]
				} );
			}
		}
	
		<span class="hljs-keyword">return</span> aSort;
	}
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Change the order of the table
 @param {object} oSettings dataTables settings object
 @memberof DataTable#oApi
 @todo This really needs split up!</p></div></div><div class="code"><div class="wrapper">	<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_fnSort</span> <span class="hljs-params">( oSettings )</span>
	{</span>
		<span class="hljs-keyword">var</span>
			i, ien, iLen, j, jLen, k, kLen,
			sDataType, nTh,
			aiOrig = [],
			oExtSort = DataTable.ext.type.order,
			aoData = oSettings.aoData,
			aoColumns = oSettings.aoColumns,
			aDataSort, data, iCol, sType, oSort,
			formatters = <span class="hljs-number">0</span>,
			sortCol,
			displayMaster = oSettings.aiDisplayMaster,
			aSort;
	</div></div></div><div class="segment"><div class="comments doc-section"><div class="wrapper"><p>Resolve any column types that are unknown due to addition or invalidation</p>
<p>TODO: Can this be moved into a &#39;data-ready&#39; handler which is called when
  data is going to be used in the table?</p></div></div><div class="code"><div class="wrapper">		_fnColumnTypes( oSettings );
	
		aSort = _fnSortFlatten( oSettings );
	
		<span class="hljs-keyword">for</span> ( i=<span class="hljs-number">0</span>, ien=aSort.length ; i&lt;ien ; i++ ) {
			sortCol = aSort[i];
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Track if we can use the fast sort algorithm</p></div></div><div class="code"><div class="wrapper">			<span class="hljs-keyword">if</span> ( sortCol.formatter ) {
				formatters++;
			}
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Load the data needed for the sort, for each cell</p></div></div><div class="code"><div class="wrapper">			_fnSortData( oSettings, sortCol.col );
		}
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>No sorting required if server-side or no sorting array </p></div></div><div class="code"><div class="wrapper">		<span class="hljs-keyword">if</span> ( _fnDataSource( oSettings ) != <span class="hljs-string">'ssp'</span> &amp;&amp; aSort.length !== <span class="hljs-number">0</span> )
		{</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Create a value - key array of the current row positions such that we can use their
current position during the sort, if values match, in order to perform stable sorting</p></div></div><div class="code"><div class="wrapper">			<span class="hljs-keyword">for</span> ( i=<span class="hljs-number">0</span>, iLen=displayMaster.length ; i&lt;iLen ; i++ ) {
				aiOrig[ displayMaster[i] ] = i;
			}
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Do the sort - here we want multi-column sorting based on a given data source (column)
and sorting function (from oSort) in a certain direction. It&#39;s reasonably complex to
follow on it&#39;s own, but this is what we want (example two column sorting):
 fnLocalSorting = function(a,b){
   var iTest;
   iTest = oSort<a href="&#39;data11&#39;," title="data12">&#39;string-asc&#39;</a>;
     if (iTest !== 0)
       return iTest;
   iTest = oSort<a href="&#39;data21&#39;," title="data22">&#39;numeric-desc&#39;</a>;
   if (iTest !== 0)
     return iTest;
   return oSort<a href="aiOrig[a], aiOrig[b]">&#39;numeric-asc&#39;</a>;
 }
Basically we have a test for each sorting column, if the data in that column is equal,
test the next column. If all columns match, then we use a numeric sort on the row
positions in the original data array to provide a stable sort.</p>
<p>Note - I know it seems excessive to have two sorting methods, but the first is around
15% faster, so the second is only maintained for backwards compatibility with sorting
methods which do not have a pre-sort formatting function.</p></div></div><div class="code"><div class="wrapper">			<span class="hljs-keyword">if</span> ( formatters === aSort.length ) {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>All sort types have formatting functions</p></div></div><div class="code"><div class="wrapper">				displayMaster.sort( <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">( a, b )</span> {</span>
					<span class="hljs-keyword">var</span>
						x, y, k, test, sort,
						len=aSort.length,
						dataA = aoData[a]._aSortData,
						dataB = aoData[b]._aSortData;
	
					<span class="hljs-keyword">for</span> ( k=<span class="hljs-number">0</span> ; k&lt;len ; k++ ) {
						sort = aSort[k];
	
						x = dataA[ sort.col ];
						y = dataB[ sort.col ];
	
						test = x&lt;y ? -<span class="hljs-number">1</span> : x&gt;y ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;
						<span class="hljs-keyword">if</span> ( test !== <span class="hljs-number">0</span> ) {
							<span class="hljs-keyword">return</span> sort.dir === <span class="hljs-string">'asc'</span> ? test : -test;
						}
					}
	
					x = aiOrig[a];
					y = aiOrig[b];
					<span class="hljs-keyword">return</span> x&lt;y ? -<span class="hljs-number">1</span> : x&gt;y ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;
				} );
			}
			<span class="hljs-keyword">else</span> {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Depreciated - remove in 1.11 (providing a plug-in option)
Not all sort types have formatting methods, so we have to call their sorting
methods.</p></div></div><div class="code"><div class="wrapper">				displayMaster.sort( <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">( a, b )</span> {</span>
					<span class="hljs-keyword">var</span>
						x, y, k, l, test, sort, fn,
						len=aSort.length,
						dataA = aoData[a]._aSortData,
						dataB = aoData[b]._aSortData;
	
					<span class="hljs-keyword">for</span> ( k=<span class="hljs-number">0</span> ; k&lt;len ; k++ ) {
						sort = aSort[k];
	
						x = dataA[ sort.col ];
						y = dataB[ sort.col ];
	
						fn = oExtSort[ sort.type+<span class="hljs-string">"-"</span>+sort.dir ] || oExtSort[ <span class="hljs-string">"string-"</span>+sort.dir ];
						test = fn( x, y );
						<span class="hljs-keyword">if</span> ( test !== <span class="hljs-number">0</span> ) {
							<span class="hljs-keyword">return</span> test;
						}
					}
	
					x = aiOrig[a];
					y = aiOrig[b];
					<span class="hljs-keyword">return</span> x&lt;y ? -<span class="hljs-number">1</span> : x&gt;y ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;
				} );
			}
		}
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Tell the draw function that we have sorted the data </p></div></div><div class="code"><div class="wrapper">		oSettings.bSorted = <span class="hljs-literal">true</span>;
	}
	
	
	<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_fnSortAria</span> <span class="hljs-params">( settings )</span>
	{</span>
		<span class="hljs-keyword">var</span> label;
		<span class="hljs-keyword">var</span> nextSort;
		<span class="hljs-keyword">var</span> columns = settings.aoColumns;
		<span class="hljs-keyword">var</span> aSort = _fnSortFlatten( settings );
		<span class="hljs-keyword">var</span> oAria = settings.oLanguage.oAria;
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>ARIA attributes - need to loop all columns, to update all (removing old
attributes as needed)</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-keyword">for</span> ( <span class="hljs-keyword">var</span> i=<span class="hljs-number">0</span>, iLen=columns.length ; i&lt;iLen ; i++ )
		{
			<span class="hljs-keyword">var</span> col = columns[i];
			<span class="hljs-keyword">var</span> asSorting = col.asSorting;
			<span class="hljs-keyword">var</span> sTitle = col.sTitle.replace( <span class="hljs-regexp">/&lt;.*?&gt;/g</span>, <span class="hljs-string">""</span> );
			<span class="hljs-keyword">var</span> th = col.nTh;
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>IE7 is throwing an error when setting these properties with jQuery&#39;s
attr() and removeAttr() methods...</p></div></div><div class="code"><div class="wrapper">			th.removeAttribute(<span class="hljs-string">'aria-sort'</span>);
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>In ARIA only the first sorting column can be marked as sorting - no multi-sort option </p></div></div><div class="code"><div class="wrapper">			<span class="hljs-keyword">if</span> ( col.bSortable ) {
				<span class="hljs-keyword">if</span> ( aSort.length &gt; <span class="hljs-number">0</span> &amp;&amp; aSort[<span class="hljs-number">0</span>].col == i ) {
					th.setAttribute(<span class="hljs-string">'aria-sort'</span>, aSort[<span class="hljs-number">0</span>].dir==<span class="hljs-string">"asc"</span> ? <span class="hljs-string">"ascending"</span> : <span class="hljs-string">"descending"</span> );
					nextSort = asSorting[ aSort[<span class="hljs-number">0</span>].index+<span class="hljs-number">1</span> ] || asSorting[<span class="hljs-number">0</span>];
				}
				<span class="hljs-keyword">else</span> {
					nextSort = asSorting[<span class="hljs-number">0</span>];
				}
	
				label = sTitle + ( nextSort === <span class="hljs-string">"asc"</span> ?
					oAria.sSortAscending :
					oAria.sSortDescending
				);
			}
			<span class="hljs-keyword">else</span> {
				label = sTitle;
			}
	
			th.setAttribute(<span class="hljs-string">'aria-label'</span>, label);
		}
	}
	
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Function to run on user sort request
 @param {object} settings dataTables settings object
 @param {node} attachTo node to attach the handler to
 @param {int} colIdx column sorting index
 @param {boolean} [append=false] Append the requested sort to the existing
   sort if true (i.e. multi-column sort)
 @param {function} [callback] callback function
 @memberof DataTable#oApi</p></div></div><div class="code"><div class="wrapper">	<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_fnSortListener</span> <span class="hljs-params">( settings, colIdx, append, callback )</span>
	{</span>
		<span class="hljs-keyword">var</span> col = settings.aoColumns[ colIdx ];
		<span class="hljs-keyword">var</span> sorting = settings.aaSorting;
		<span class="hljs-keyword">var</span> asSorting = col.asSorting;
		<span class="hljs-keyword">var</span> nextSortIdx;
		<span class="hljs-keyword">var</span> next = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">( a )</span> {</span>
			<span class="hljs-keyword">var</span> idx = a._idx;
			<span class="hljs-keyword">if</span> ( idx === <span class="hljs-literal">undefined</span> ) {
				idx = $.inArray( a[<span class="hljs-number">1</span>], asSorting );
			}
	
			<span class="hljs-keyword">return</span> idx+<span class="hljs-number">1</span> &gt;= asSorting.length ? <span class="hljs-number">0</span> : idx+<span class="hljs-number">1</span>;
		};
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Convert to 2D array if needed</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-keyword">if</span> ( <span class="hljs-keyword">typeof</span> sorting[<span class="hljs-number">0</span>] === <span class="hljs-string">'number'</span> ) {
			sorting = settings.aaSorting = [ sorting ];
		}
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>If appending the sort then we are multi-column sorting</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-keyword">if</span> ( append &amp;&amp; settings.oFeatures.bSortMulti ) {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Are we already doing some kind of sort on this column?</p></div></div><div class="code"><div class="wrapper">			<span class="hljs-keyword">var</span> sortIdx = $.inArray( colIdx, _pluck(sorting, <span class="hljs-string">'0'</span>) );
	
			<span class="hljs-keyword">if</span> ( sortIdx !== -<span class="hljs-number">1</span> ) {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Yes, modify the sort</p></div></div><div class="code"><div class="wrapper">				nextSortIdx = next( sorting[sortIdx] );
	
				sorting[sortIdx][<span class="hljs-number">1</span>] = asSorting[ nextSortIdx ];
				sorting[sortIdx]._idx = nextSortIdx;
			}
			<span class="hljs-keyword">else</span> {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>No sort on this column yet</p></div></div><div class="code"><div class="wrapper">				sorting.push( [ colIdx, asSorting[<span class="hljs-number">0</span>], <span class="hljs-number">0</span> ] );
				sorting[sorting.length-<span class="hljs-number">1</span>]._idx = <span class="hljs-number">0</span>;
			}
		}
		<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( sorting.length &amp;&amp; sorting[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] == colIdx ) {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Single column - already sorting on this column, modify the sort</p></div></div><div class="code"><div class="wrapper">			nextSortIdx = next( sorting[<span class="hljs-number">0</span>] );
	
			sorting.length = <span class="hljs-number">1</span>;
			sorting[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] = asSorting[ nextSortIdx ];
			sorting[<span class="hljs-number">0</span>]._idx = nextSortIdx;
		}
		<span class="hljs-keyword">else</span> {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Single column - sort only on this column</p></div></div><div class="code"><div class="wrapper">			sorting.length = <span class="hljs-number">0</span>;
			sorting.push( [ colIdx, asSorting[<span class="hljs-number">0</span>] ] );
			sorting[<span class="hljs-number">0</span>]._idx = <span class="hljs-number">0</span>;
		}
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Run the sort by calling a full redraw</p></div></div><div class="code"><div class="wrapper">		_fnReDraw( settings );
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>callback used for async user interaction</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-keyword">if</span> ( <span class="hljs-keyword">typeof</span> callback == <span class="hljs-string">'function'</span> ) {
			callback( settings );
		}
	}
	
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Attach a sort handler (click) to a node
 @param {object} settings dataTables settings object
 @param {node} attachTo node to attach the handler to
 @param {int} colIdx column sorting index
 @param {function} [callback] callback function
 @memberof DataTable#oApi</p></div></div><div class="code"><div class="wrapper">	<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_fnSortAttachListener</span> <span class="hljs-params">( settings, attachTo, colIdx, callback )</span>
	{</span>
		<span class="hljs-keyword">var</span> col = settings.aoColumns[ colIdx ];
	
		_fnBindAction( attachTo, {}, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(e)</span> {</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>If the column is not sortable - don&#39;t to anything </p></div></div><div class="code"><div class="wrapper">			<span class="hljs-keyword">if</span> ( col.bSortable === <span class="hljs-literal">false</span> ) {
				<span class="hljs-keyword">return</span>;
			}
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>If processing is enabled use a timeout to allow the processing
display to be shown - otherwise to it synchronously</p></div></div><div class="code"><div class="wrapper">			<span class="hljs-keyword">if</span> ( settings.oFeatures.bProcessing ) {
				_fnProcessingDisplay( settings, <span class="hljs-literal">true</span> );
	
				setTimeout( <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>
					_fnSortListener( settings, colIdx, e.shiftKey, callback );
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>In server-side processing, the draw callback will remove the
processing display</p></div></div><div class="code"><div class="wrapper">					<span class="hljs-keyword">if</span> ( _fnDataSource( settings ) !== <span class="hljs-string">'ssp'</span> ) {
						_fnProcessingDisplay( settings, <span class="hljs-literal">false</span> );
					}
				}, <span class="hljs-number">0</span> );
			}
			<span class="hljs-keyword">else</span> {
				_fnSortListener( settings, colIdx, e.shiftKey, callback );
			}
		} );
	}
	
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Set the sorting classes on table&#39;s body, Note: it is safe to call this function
when bSort and bSortClasses are false
 @param {object} oSettings dataTables settings object
 @memberof DataTable#oApi</p></div></div><div class="code"><div class="wrapper">	<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_fnSortingClasses</span><span class="hljs-params">( settings )</span>
	{</span>
		<span class="hljs-keyword">var</span> oldSort = settings.aLastSort;
		<span class="hljs-keyword">var</span> sortClass = settings.oClasses.sSortColumn;
		<span class="hljs-keyword">var</span> sort = _fnSortFlatten( settings );
		<span class="hljs-keyword">var</span> features = settings.oFeatures;
		<span class="hljs-keyword">var</span> i, ien, colIdx;
	
		<span class="hljs-keyword">if</span> ( features.bSort &amp;&amp; features.bSortClasses ) {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Remove old sorting classes</p></div></div><div class="code"><div class="wrapper">			<span class="hljs-keyword">for</span> ( i=<span class="hljs-number">0</span>, ien=oldSort.length ; i&lt;ien ; i++ ) {
				colIdx = oldSort[i].src;
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Remove column sorting</p></div></div><div class="code"><div class="wrapper">				$( _pluck( settings.aoData, <span class="hljs-string">'anCells'</span>, colIdx ) )
					.removeClass( sortClass + (i&lt;<span class="hljs-number">2</span> ? i+<span class="hljs-number">1</span> : <span class="hljs-number">3</span>) );
			}
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Add new column sorting</p></div></div><div class="code"><div class="wrapper">			<span class="hljs-keyword">for</span> ( i=<span class="hljs-number">0</span>, ien=sort.length ; i&lt;ien ; i++ ) {
				colIdx = sort[i].src;
	
				$( _pluck( settings.aoData, <span class="hljs-string">'anCells'</span>, colIdx ) )
					.addClass( sortClass + (i&lt;<span class="hljs-number">2</span> ? i+<span class="hljs-number">1</span> : <span class="hljs-number">3</span>) );
			}
		}
	
		settings.aLastSort = sort;
	}
	
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Get the data to sort a column, be it from cache, fresh (populating the
cache), or from a sort formatter</p></div></div><div class="code"><div class="wrapper">	<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_fnSortData</span><span class="hljs-params">( settings, idx )</span>
	{</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Custom sorting function - provided by the sort data type</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-keyword">var</span> column = settings.aoColumns[ idx ];
		<span class="hljs-keyword">var</span> customSort = DataTable.ext.order[ column.sSortDataType ];
		<span class="hljs-keyword">var</span> customData;
	
		<span class="hljs-keyword">if</span> ( customSort ) {
			customData = customSort.call( settings.oInstance, settings, idx,
				_fnColumnIndexToVisible( settings, idx )
			);
		}
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Use / populate cache</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-keyword">var</span> row, cellData;
		<span class="hljs-keyword">var</span> formatter = DataTable.ext.type.order[ column.sType+<span class="hljs-string">"-pre"</span> ];
	
		<span class="hljs-keyword">for</span> ( <span class="hljs-keyword">var</span> i=<span class="hljs-number">0</span>, ien=settings.aoData.length ; i&lt;ien ; i++ ) {
			row = settings.aoData[i];
	
			<span class="hljs-keyword">if</span> ( ! row._aSortData ) {
				row._aSortData = [];
			}
	
			<span class="hljs-keyword">if</span> ( ! row._aSortData[idx] || customSort ) {
				cellData = customSort ?
					customData[i] : <span class="hljs-comment">// If there was a custom sort function, use data from there</span>
					_fnGetCellData( settings, i, idx, <span class="hljs-string">'sort'</span> );
	
				row._aSortData[ idx ] = formatter ?
					formatter( cellData ) :
					cellData;
			}
		}
	}
	
	
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Save the state of a table
 @param {object} oSettings dataTables settings object
 @memberof DataTable#oApi</p></div></div><div class="code"><div class="wrapper">	<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_fnSaveState</span> <span class="hljs-params">( settings )</span>
	{</span>
		<span class="hljs-keyword">if</span> ( !settings.oFeatures.bStateSave || settings.bDestroying )
		{
			<span class="hljs-keyword">return</span>;
		}
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Store the interesting variables </p></div></div><div class="code"><div class="wrapper">		<span class="hljs-keyword">var</span> state = {
			time:    +<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(),
			start:   settings._iDisplayStart,
			length:  settings._iDisplayLength,
			order:   $.extend( <span class="hljs-literal">true</span>, [], settings.aaSorting ),
			search:  _fnSearchToCamel( settings.oPreviousSearch ),
			columns: $.map( settings.aoColumns, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">( col, i )</span> {</span>
				<span class="hljs-keyword">return</span> {
					visible: col.bVisible,
					search: _fnSearchToCamel( settings.aoPreSearchCols[i] )
				};
			} )
		};
	
		_fnCallbackFire( settings, <span class="hljs-string">"aoStateSaveParams"</span>, <span class="hljs-string">'stateSaveParams'</span>, [settings, state] );
	
		settings.oSavedState = state;
		settings.fnStateSaveCallback.call( settings.oInstance, settings, state );
	}
	
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Attempt to load a saved table state
 @param {object} oSettings dataTables settings object
 @param {object} oInit DataTables init object so we can override settings
 @memberof DataTable#oApi</p></div></div><div class="code"><div class="wrapper">	<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_fnLoadState</span> <span class="hljs-params">( settings, oInit )</span>
	{</span>
		<span class="hljs-keyword">var</span> i, ien;
		<span class="hljs-keyword">var</span> columns = settings.aoColumns;
	
		<span class="hljs-keyword">if</span> ( ! settings.oFeatures.bStateSave ) {
			<span class="hljs-keyword">return</span>;
		}
	
		<span class="hljs-keyword">var</span> state = settings.fnStateLoadCallback.call( settings.oInstance, settings );
		<span class="hljs-keyword">if</span> ( ! state || ! state.time ) {
			<span class="hljs-keyword">return</span>;
		}
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Allow custom and plug-in manipulation functions to alter the saved data set and
cancelling of loading by returning false</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-keyword">var</span> abStateLoad = _fnCallbackFire( settings, <span class="hljs-string">'aoStateLoadParams'</span>, <span class="hljs-string">'stateLoadParams'</span>, [settings, state] );
		<span class="hljs-keyword">if</span> ( $.inArray( <span class="hljs-literal">false</span>, abStateLoad ) !== -<span class="hljs-number">1</span> ) {
			<span class="hljs-keyword">return</span>;
		}
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Reject old data </p></div></div><div class="code"><div class="wrapper">		<span class="hljs-keyword">var</span> duration = settings.iStateDuration;
		<span class="hljs-keyword">if</span> ( duration &gt; <span class="hljs-number">0</span> &amp;&amp; state.time &lt; +<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>() - (duration*<span class="hljs-number">1000</span>) ) {
			<span class="hljs-keyword">return</span>;
		}
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Number of columns have changed - all bets are off, no restore of settings</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-keyword">if</span> ( columns.length !== state.columns.length ) {
			<span class="hljs-keyword">return</span>;
		}
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Store the saved state so it might be accessed at any time</p></div></div><div class="code"><div class="wrapper">		settings.oLoadedState = $.extend( <span class="hljs-literal">true</span>, {}, state );
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Restore key features - todo - for 1.11 this needs to be done by
subscribed events</p></div></div><div class="code"><div class="wrapper">		settings._iDisplayStart    = state.start;
		settings.iInitDisplayStart = state.start;
		settings._iDisplayLength   = state.length;
		settings.aaSorting = [];
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Order</p></div></div><div class="code"><div class="wrapper">		$.each( state.order, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">( i, col )</span> {</span>
			settings.aaSorting.push( col[<span class="hljs-number">0</span>] &gt;= columns.length ?
				[ <span class="hljs-number">0</span>, col[<span class="hljs-number">1</span>] ] :
				col
			);
		} );
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Search</p></div></div><div class="code"><div class="wrapper">		$.extend( settings.oPreviousSearch, _fnSearchToHung( state.search ) );
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Columns</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-keyword">for</span> ( i=<span class="hljs-number">0</span>, ien=state.columns.length ; i&lt;ien ; i++ ) {
			<span class="hljs-keyword">var</span> col = state.columns[i];
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Visibility</p></div></div><div class="code"><div class="wrapper">			columns[i].bVisible = col.visible;
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Search</p></div></div><div class="code"><div class="wrapper">			$.extend( settings.aoPreSearchCols[i], _fnSearchToHung( col.search ) );
		}
	
		_fnCallbackFire( settings, <span class="hljs-string">'aoStateLoaded'</span>, <span class="hljs-string">'stateLoaded'</span>, [settings, state] );
	}
	
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Return the settings object for a particular table
 @param {node} table table we are using as a dataTable
 @returns {object} Settings object - or null if not found
 @memberof DataTable#oApi</p></div></div><div class="code"><div class="wrapper">	<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_fnSettingsFromNode</span> <span class="hljs-params">( table )</span>
	{</span>
		<span class="hljs-keyword">var</span> settings = DataTable.settings;
		<span class="hljs-keyword">var</span> idx = $.inArray( table, _pluck( settings, <span class="hljs-string">'nTable'</span> ) );
	
		<span class="hljs-keyword">return</span> idx !== -<span class="hljs-number">1</span> ?
			settings[ idx ] :
			<span class="hljs-literal">null</span>;
	}
	
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Log an error message
 @param {object} settings dataTables settings object
 @param {int} level log error messages, or display them to the user
 @param {string} msg error message
 @param {int} tn Technical note id to get more information about the error.
 @memberof DataTable#oApi</p></div></div><div class="code"><div class="wrapper">	<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_fnLog</span><span class="hljs-params">( settings, level, msg, tn )</span>
	{</span>
		msg = <span class="hljs-string">'DataTables warning: '</span>+
			(settings!==<span class="hljs-literal">null</span> ? <span class="hljs-string">'table id='</span>+settings.sTableId+<span class="hljs-string">' - '</span> : <span class="hljs-string">''</span>)+msg;
	
		<span class="hljs-keyword">if</span> ( tn ) {
			msg += <span class="hljs-string">'. For more information about this error, please see '</span>+
			<span class="hljs-string">'http://datatables.net/tn/'</span>+tn;
		}
	
		<span class="hljs-keyword">if</span> ( ! level  ) {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Backwards compatibility pre 1.10</p></div></div><div class="code"><div class="wrapper">			<span class="hljs-keyword">var</span> ext = DataTable.ext;
			<span class="hljs-keyword">var</span> type = ext.sErrMode || ext.errMode;
	
			<span class="hljs-keyword">if</span> ( type == <span class="hljs-string">'alert'</span> ) {
				alert( msg );
			}
			<span class="hljs-keyword">else</span> {
				<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(msg);
			}
		}
		<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( window.console &amp;&amp; console.log ) {
			console.log( msg );
		}
	}
	
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>See if a property is defined on one object, if so assign it to the other object
 @param {object} ret target object
 @param {object} src source object
 @param {string} name property
 @param {string} [mappedName] name to map too - optional, name used if not given
 @memberof DataTable#oApi</p></div></div><div class="code"><div class="wrapper">	<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_fnMap</span><span class="hljs-params">( ret, src, name, mappedName )</span>
	{</span>
		<span class="hljs-keyword">if</span> ( $.isArray( name ) ) {
			$.each( name, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(i, val)</span> {</span>
				<span class="hljs-keyword">if</span> ( $.isArray( val ) ) {
					_fnMap( ret, src, val[<span class="hljs-number">0</span>], val[<span class="hljs-number">1</span>] );
				}
				<span class="hljs-keyword">else</span> {
					_fnMap( ret, src, val );
				}
			} );
	
			<span class="hljs-keyword">return</span>;
		}
	
		<span class="hljs-keyword">if</span> ( mappedName === <span class="hljs-literal">undefined</span> ) {
			mappedName = name;
		}
	
		<span class="hljs-keyword">if</span> ( src[name] !== <span class="hljs-literal">undefined</span> ) {
			ret[mappedName] = src[name];
		}
	}
	
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Extend objects - very similar to jQuery.extend, but deep copy objects, and
shallow copy arrays. The reason we need to do this, is that we don&#39;t want to
deep copy array init values (such as aaSorting) since the dev wouldn&#39;t be
able to override them, but we do want to deep copy arrays.
 @param {object} out Object to extend
 @param {object} extender Object from which the properties will be applied to
     out
 @param {boolean} breakRefs If true, then arrays will be sliced to take an
     independent copy with the exception of the <code>data</code> or <code>aaData</code> parameters
     if they are present. This is so you can pass in a collection to
     DataTables and have that used as your data source without breaking the
     references
 @returns {object} out Reference, just for convenience - out === the return.
 @memberof DataTable#oApi
 @todo This doesn&#39;t take account of arrays inside the deep copied objects.</p></div></div><div class="code"><div class="wrapper">	<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_fnExtend</span><span class="hljs-params">( out, extender, breakRefs )</span>
	{</span>
		<span class="hljs-keyword">var</span> val;
	
		<span class="hljs-keyword">for</span> ( <span class="hljs-keyword">var</span> prop <span class="hljs-keyword">in</span> extender ) {
			<span class="hljs-keyword">if</span> ( extender.hasOwnProperty(prop) ) {
				val = extender[prop];
	
				<span class="hljs-keyword">if</span> ( $.isPlainObject( val ) ) {
					<span class="hljs-keyword">if</span> ( ! $.isPlainObject( out[prop] ) ) {
						out[prop] = {};
					}
					$.extend( <span class="hljs-literal">true</span>, out[prop], val );
				}
				<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( breakRefs &amp;&amp; prop !== <span class="hljs-string">'data'</span> &amp;&amp; prop !== <span class="hljs-string">'aaData'</span> &amp;&amp; $.isArray(val) ) {
					out[prop] = val.slice();
				}
				<span class="hljs-keyword">else</span> {
					out[prop] = val;
				}
			}
		}
	
		<span class="hljs-keyword">return</span> out;
	}
	
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Bind an event handers to allow a click or return key to activate the callback.
This is good for accessibility since a return on the keyboard will have the
same effect as a click, if the element has focus.
 @param {element} n Element to bind the action to
 @param {object} oData Data object to pass to the triggered function
 @param {function} fn Callback function for when the event is triggered
 @memberof DataTable#oApi</p></div></div><div class="code"><div class="wrapper">	<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_fnBindAction</span><span class="hljs-params">( n, oData, fn )</span>
	{</span>
		$(n)
			.bind( <span class="hljs-string">'click.DT'</span>, oData, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(e)</span> {</span>
					n.blur(); <span class="hljs-comment">// Remove focus outline for mouse users</span>
					fn(e);
				} )
			.bind( <span class="hljs-string">'keypress.DT'</span>, oData, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(e)</span>{</span>
					<span class="hljs-keyword">if</span> ( e.which === <span class="hljs-number">13</span> ) {
						e.preventDefault();
						fn(e);
					}
				} )
			.bind( <span class="hljs-string">'selectstart.DT'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Take the brutal approach to cancelling text selection </p></div></div><div class="code"><div class="wrapper">					<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
				} );
	}
	
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Register a callback function. Easily allows a callback function to be added to
an array store of callback functions that can then all be called together.
 @param {object} oSettings dataTables settings object
 @param {string} sStore Name of the array storage for the callbacks in oSettings
 @param {function} fn Function to be called back
 @param {string} sName Identifying name for the callback (i.e. a label)
 @memberof DataTable#oApi</p></div></div><div class="code"><div class="wrapper">	<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_fnCallbackReg</span><span class="hljs-params">( oSettings, sStore, fn, sName )</span>
	{</span>
		<span class="hljs-keyword">if</span> ( fn )
		{
			oSettings[sStore].push( {
				<span class="hljs-string">"fn"</span>: fn,
				<span class="hljs-string">"sName"</span>: sName
			} );
		}
	}
	
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Fire callback functions and trigger events. Note that the loop over the
callback array store is done backwards! Further note that you do not want to
fire off triggers in time sensitive applications (for example cell creation)
as its slow.
 @param {object} settings dataTables settings object
 @param {string} callbackArr Name of the array storage for the callbacks in
     oSettings
 @param {string} event Name of the jQuery custom event to trigger. If null no
     trigger is fired
 @param {array} args Array of arguments to pass to the callback function /
     trigger
 @memberof DataTable#oApi</p></div></div><div class="code"><div class="wrapper">	<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_fnCallbackFire</span><span class="hljs-params">( settings, callbackArr, e, args )</span>
	{</span>
		<span class="hljs-keyword">var</span> ret = [];
	
		<span class="hljs-keyword">if</span> ( callbackArr ) {
			ret = $.map( settings[callbackArr].slice().reverse(), <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(val, i)</span> {</span>
				<span class="hljs-keyword">return</span> val.fn.apply( settings.oInstance, args );
			} );
		}
	
		<span class="hljs-keyword">if</span> ( e !== <span class="hljs-literal">null</span> ) {
			$(settings.nTable).trigger( e+<span class="hljs-string">'.dt'</span>, args );
		}
	
		<span class="hljs-keyword">return</span> ret;
	}
	
	
	<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_fnLengthOverflow</span> <span class="hljs-params">( settings )</span>
	{</span>
		<span class="hljs-keyword">var</span>
			start = settings._iDisplayStart,
			end = settings.fnDisplayEnd(),
			len = settings._iDisplayLength;
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>If we have space to show extra rows (backing up from the end point - then do so </p></div></div><div class="code"><div class="wrapper">		<span class="hljs-keyword">if</span> ( end === settings.fnRecordsDisplay() )
		{
			start = end - len;
		}
	
		<span class="hljs-keyword">if</span> ( len === -<span class="hljs-number">1</span> || start &lt; <span class="hljs-number">0</span> )
		{
			start = <span class="hljs-number">0</span>;
		}
	
		settings._iDisplayStart = start;
	}
	
	
	<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_fnRenderer</span><span class="hljs-params">( settings, type )</span>
	{</span>
		<span class="hljs-keyword">var</span> renderer = settings.renderer;
		<span class="hljs-keyword">var</span> host = DataTable.ext.renderer[type];
	
		<span class="hljs-keyword">if</span> ( $.isPlainObject( renderer ) &amp;&amp; renderer[type] ) {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Specific renderer for this type. If available use it, otherwise use
the default.</p></div></div><div class="code"><div class="wrapper">			<span class="hljs-keyword">return</span> host[renderer[type]] || host._;
		}
		<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( <span class="hljs-keyword">typeof</span> renderer === <span class="hljs-string">'string'</span> ) {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Common renderer - if there is one available for this type use it,
otherwise use the default</p></div></div><div class="code"><div class="wrapper">			<span class="hljs-keyword">return</span> host[renderer] || host._;
		}
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Use the default</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-keyword">return</span> host._;
	}
	
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Detect the data source being used for the table. Used to simplify the code
a little (ajax) and to make it compress a little smaller.</p>
<p> @param {object} settings dataTables settings object
 @returns {string} Data source
 @memberof DataTable#oApi</p></div></div><div class="code"><div class="wrapper">	<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_fnDataSource</span> <span class="hljs-params">( settings )</span>
	{</span>
		<span class="hljs-keyword">if</span> ( settings.oFeatures.bServerSide ) {
			<span class="hljs-keyword">return</span> <span class="hljs-string">'ssp'</span>;
		}
		<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( settings.ajax || settings.sAjaxSource ) {
			<span class="hljs-keyword">return</span> <span class="hljs-string">'ajax'</span>;
		}
		<span class="hljs-keyword">return</span> <span class="hljs-string">'dom'</span>;
	}
	

	DataTable = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( options )</span>
	{</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Perform a jQuery selector action on the table&#39;s TR elements (from the tbody) and
return the resulting jQuery object.
 @param {string|node|jQuery} sSelector jQuery selector or node collection to act on
 @param {object} [oOpts] Optional parameters for modifying the rows to be included
 @param {string} [oOpts.filter=none] Select TR elements that meet the current filter
   criterion (&quot;applied&quot;) or all TR elements (i.e. no filter).
 @param {string} [oOpts.order=current] Order of the TR elements in the processed array.
   Can be either &#39;current&#39;, whereby the current sorting of the table is used, or
   &#39;original&#39; whereby the original order the data was read into the table is used.
 @param {string} [oOpts.page=all] Limit the selection to the currently displayed page
   (&quot;current&quot;) or not (&quot;all&quot;). If &#39;current&#39; is given, then order is assumed to be
   &#39;current&#39; and filter is &#39;applied&#39;, regardless of what they might be given as.
 @returns {object} jQuery object, filtered by the given selector.
 @dtopt API
 @deprecated Since v1.10</p>
<p> @example
   $(document).ready(function() {
     var oTable = $(&#39;#example&#39;).dataTable();</p>
<pre><code> // Highlight every second row
 oTable.$(&#39;tr:odd&#39;).css(&#39;backgroundColor&#39;, &#39;blue&#39;);</code></pre>
<p>   } );</p>
<p> @example
   $(document).ready(function() {
     var oTable = $(&#39;#example&#39;).dataTable();</p>
<pre><code> // Filter to rows with &#39;Webkit&#39; in them, add a background colour and then
 // remove the filter, thus highlighting the &#39;Webkit&#39; rows only.
 oTable.fnFilter(&#39;Webkit&#39;);
 oTable.$(&#39;tr&#39;, {&quot;search&quot;: &quot;applied&quot;}).css(&#39;backgroundColor&#39;, &#39;blue&#39;);
 oTable.fnFilter(&#39;&#39;);</code></pre>
<p>   } );</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-keyword">this</span>.$ = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">( sSelector, oOpts )</span>
		{</span>
			<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.api(<span class="hljs-literal">true</span>).$( sSelector, oOpts );
		};
		
		</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Almost identical to $ in operation, but in this case returns the data for the matched
rows - as such, the jQuery selector used should match TR row nodes or TD/TH cell nodes
rather than any descendants, so the data can be obtained for the row/cell. If matching
rows are found, the data returned is the original data array/object that was used to
create the row (or a generated array if from a DOM source).</p>
<p>This method is often useful in-combination with $ where both functions are given the
same parameters and the array indexes will match identically.
 @param {string|node|jQuery} sSelector jQuery selector or node collection to act on
 @param {object} [oOpts] Optional parameters for modifying the rows to be included
 @param {string} [oOpts.filter=none] Select elements that meet the current filter
   criterion (&quot;applied&quot;) or all elements (i.e. no filter).
 @param {string} [oOpts.order=current] Order of the data in the processed array.
   Can be either &#39;current&#39;, whereby the current sorting of the table is used, or
   &#39;original&#39; whereby the original order the data was read into the table is used.
 @param {string} [oOpts.page=all] Limit the selection to the currently displayed page
   (&quot;current&quot;) or not (&quot;all&quot;). If &#39;current&#39; is given, then order is assumed to be
   &#39;current&#39; and filter is &#39;applied&#39;, regardless of what they might be given as.
 @returns {array} Data for the matched elements. If any elements, as a result of the
   selector, were not TR, TD or TH elements in the DataTable, they will have a null
   entry in the array.
 @dtopt API
 @deprecated Since v1.10</p>
<p> @example
   $(document).ready(function() {
     var oTable = $(&#39;#example&#39;).dataTable();</p>
<pre><code> // Get the data from the first row in the table
 var data = oTable._(&#39;tr:first&#39;);

 // Do something useful with the data
 alert( &quot;First cell is: &quot;+data[0] );</code></pre>
<p>   } );</p>
<p> @example
   $(document).ready(function() {
     var oTable = $(&#39;#example&#39;).dataTable();</p>
<pre><code> // Filter to &#39;Webkit&#39; and get all data for
 oTable.fnFilter(&#39;Webkit&#39;);
 var data = oTable._(&#39;tr&#39;, {&quot;search&quot;: &quot;applied&quot;});

 // Do something with the data
 alert( data.length+&quot; rows matched the search&quot; );</code></pre>
<p>   } );</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-keyword">this</span>._ = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">( sSelector, oOpts )</span>
		{</span>
			<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.api(<span class="hljs-literal">true</span>).rows( sSelector, oOpts ).data();
		};
		
		</div></div></div><div class="segment"><div class="comments doc-section"><div class="wrapper"><p>Create a DataTables Api instance, with the currently selected tables for
the Api&#39;s context.</p>
<p>Parameters:</p>
<ul>
<li><strong>traditional is optional, must be a boolean, and has a default value of false.</strong><br/>(Set the API instance&#39;s context to be only the table referred to by the <code>DataTable.ext.iApiIndex</code> option, as was used in the API presented by DataTables 1.9- (i.e. the traditional mode), or if all tables captured in the jQuery object should be used.)</li>
</ul>
<p><strong>Returns a DataTables.Api</strong></p></div></div><div class="code"><div class="wrapper">		<span class="hljs-keyword">this</span>.api = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">( traditional )</span>
		{</span>
			<span class="hljs-keyword">return</span> traditional ?
				<span class="hljs-keyword">new</span> _Api(
					_fnSettingsFromNode( <span class="hljs-keyword">this</span>[ _ext.iApiIndex ] )
				) :
				<span class="hljs-keyword">new</span> _Api( <span class="hljs-keyword">this</span> );
		};
		
		</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Add a single new row or multiple rows of data to the table. Please note
that this is suitable for client-side processing only - if you are using
server-side processing (i.e. &quot;bServerSide&quot;: true), then to add data, you
must add it to the data source, i.e. the server-side, through an Ajax call.
 @param {array|object} data The data to be added to the table. This can be:
   <ul>
     <li>1D array of data - add a single row with the data provided</li>
     <li>2D array of arrays - add multiple rows in a single call</li>
     <li>object - data object when using <i>mData</i></li>
     <li>array of objects - multiple data objects when using <i>mData</i></li>
   </ul>
 @param {bool} [redraw=true] redraw the table or not
 @returns {array} An array of integers, representing the list of indexes in
   <i>aoData</i> ({@link DataTable.models.oSettings}) that have been added to
   the table.
 @dtopt API
 @deprecated Since v1.10</p>
<p> @example
   // Global var for counter
   var giCount = 2;</p>
<p>   $(document).ready(function() {
     $(&#39;#example&#39;).dataTable();
   } );</p>
<p>   function fnClickAddRow() {
     $(&#39;#example&#39;).dataTable().fnAddData( [
       giCount+&quot;.1&quot;,
       giCount+&quot;.2&quot;,
       giCount+&quot;.3&quot;,
       giCount+&quot;.4&quot; ]
     );</p>
<pre><code> giCount++;</code></pre>
<p>   }</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-keyword">this</span>.fnAddData = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( data, redraw )</span>
		{</span>
			<span class="hljs-keyword">var</span> api = <span class="hljs-keyword">this</span>.api( <span class="hljs-literal">true</span> );
		</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Check if we want to add multiple rows or not </p></div></div><div class="code"><div class="wrapper">			<span class="hljs-keyword">var</span> rows = $.isArray(data) &amp;&amp; ( $.isArray(data[<span class="hljs-number">0</span>]) || $.isPlainObject(data[<span class="hljs-number">0</span>]) ) ?
				api.rows.add( data ) :
				api.row.add( data );
		
			<span class="hljs-keyword">if</span> ( redraw === <span class="hljs-literal">undefined</span> || redraw ) {
				api.draw();
			}
		
			<span class="hljs-keyword">return</span> rows.flatten().toArray();
		};
		
		</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>This function will make DataTables recalculate the column sizes, based on the data
contained in the table and the sizes applied to the columns (in the DOM, CSS or
through the sWidth parameter). This can be useful when the width of the table&#39;s
parent element changes (for example a window resize).
 @param {boolean} [bRedraw=true] Redraw the table or not, you will typically want to
 @dtopt API
 @deprecated Since v1.10</p>
<p> @example
   $(document).ready(function() {
     var oTable = $(&#39;#example&#39;).dataTable( {
       &quot;sScrollY&quot;: &quot;200px&quot;,
       &quot;bPaginate&quot;: false
     } );</p>
<pre><code> $(window).bind(&#39;resize&#39;, function () {
   oTable.fnAdjustColumnSizing();
 } );</code></pre>
<p>   } );</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-keyword">this</span>.fnAdjustColumnSizing = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">( bRedraw )</span>
		{</span>
			<span class="hljs-keyword">var</span> api = <span class="hljs-keyword">this</span>.api( <span class="hljs-literal">true</span> ).columns.adjust();
			<span class="hljs-keyword">var</span> settings = api.settings()[<span class="hljs-number">0</span>];
			<span class="hljs-keyword">var</span> scroll = settings.oScroll;
		
			<span class="hljs-keyword">if</span> ( bRedraw === <span class="hljs-literal">undefined</span> || bRedraw ) {
				api.draw( <span class="hljs-literal">false</span> );
			}
			<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( scroll.sX !== <span class="hljs-string">""</span> || scroll.sY !== <span class="hljs-string">""</span> ) {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>If not redrawing, but scrolling, we want to apply the new column sizes anyway </p></div></div><div class="code"><div class="wrapper">				_fnScrollDraw( settings );
			}
		};
		
		</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Quickly and simply clear a table
 @param {bool} [bRedraw=true] redraw the table or not
 @dtopt API
 @deprecated Since v1.10</p>
<p> @example
   $(document).ready(function() {
     var oTable = $(&#39;#example&#39;).dataTable();</p>
<pre><code> // Immediately &#39;nuke&#39; the current rows (perhaps waiting for an Ajax callback...)
 oTable.fnClearTable();</code></pre>
<p>   } );</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-keyword">this</span>.fnClearTable = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( bRedraw )</span>
		{</span>
			<span class="hljs-keyword">var</span> api = <span class="hljs-keyword">this</span>.api( <span class="hljs-literal">true</span> ).clear();
		
			<span class="hljs-keyword">if</span> ( bRedraw === <span class="hljs-literal">undefined</span> || bRedraw ) {
				api.draw();
			}
		};
		
		</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>The exact opposite of &#39;opening&#39; a row, this function will close any rows which
are currently &#39;open&#39;.
 @param {node} nTr the table row to &#39;close&#39;
 @returns {int} 0 on success, or 1 if failed (can&#39;t find the row)
 @dtopt API
 @deprecated Since v1.10</p>
<p> @example
   $(document).ready(function() {
     var oTable;</p>
<pre><code> // &#39;open&#39; an information row when a row is clicked on
 $(&#39;#example tbody tr&#39;).click( function () {
   if ( oTable.fnIsOpen(this) ) {
     oTable.fnClose( this );
   } else {
     oTable.fnOpen( this, &quot;Temporary row opened&quot;, &quot;info_row&quot; );
   }
 } );

 oTable = $(&#39;#example&#39;).dataTable();</code></pre>
<p>   } );</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-keyword">this</span>.fnClose = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( nTr )</span>
		{</span>
			<span class="hljs-keyword">this</span>.api( <span class="hljs-literal">true</span> ).row( nTr ).child.hide();
		};
		
		</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Remove a row for the table
 @param {mixed} target The index of the row from aoData to be deleted, or
   the TR element you want to delete
 @param {function|null} [callBack] Callback function
 @param {bool} [redraw=true] Redraw the table or not
 @returns {array} The row that was deleted
 @dtopt API
 @deprecated Since v1.10</p>
<p> @example
   $(document).ready(function() {
     var oTable = $(&#39;#example&#39;).dataTable();</p>
<pre><code> // Immediately remove the first row
 oTable.fnDeleteRow( 0 );</code></pre>
<p>   } );</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-keyword">this</span>.fnDeleteRow = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( target, callback, redraw )</span>
		{</span>
			<span class="hljs-keyword">var</span> api = <span class="hljs-keyword">this</span>.api( <span class="hljs-literal">true</span> );
			<span class="hljs-keyword">var</span> rows = api.rows( target );
			<span class="hljs-keyword">var</span> settings = rows.settings()[<span class="hljs-number">0</span>];
			<span class="hljs-keyword">var</span> data = settings.aoData[ rows[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] ];
		
			rows.remove();
		
			<span class="hljs-keyword">if</span> ( callback ) {
				callback.call( <span class="hljs-keyword">this</span>, settings, data );
			}
		
			<span class="hljs-keyword">if</span> ( redraw === <span class="hljs-literal">undefined</span> || redraw ) {
				api.draw();
			}
		
			<span class="hljs-keyword">return</span> data;
		};
		
		</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Restore the table to it&#39;s original state in the DOM by removing all of DataTables
enhancements, alterations to the DOM structure of the table and event listeners.
 @param {boolean} [remove=false] Completely remove the table from the DOM
 @dtopt API
 @deprecated Since v1.10</p>
<p> @example
   $(document).ready(function() {
     // This example is fairly pointless in reality, but shows how fnDestroy can be used
     var oTable = $(&#39;#example&#39;).dataTable();
     oTable.fnDestroy();
   } );</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-keyword">this</span>.fnDestroy = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">( remove )</span>
		{</span>
			<span class="hljs-keyword">this</span>.api( <span class="hljs-literal">true</span> ).destroy( remove );
		};
		
		</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Redraw the table
 @param {bool} [complete=true] Re-filter and resort (if enabled) the table before the draw.
 @dtopt API
 @deprecated Since v1.10</p>
<p> @example
   $(document).ready(function() {
     var oTable = $(&#39;#example&#39;).dataTable();</p>
<pre><code> // Re-draw the table - you wouldn&#39;t want to do it here, but it&#39;s an example :-)
 oTable.fnDraw();</code></pre>
<p>   } );</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-keyword">this</span>.fnDraw = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( complete )</span>
		{</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Note that this isn&#39;t an exact match to the old call to _fnDraw - it takes
into account the new data, but can old position.</p></div></div><div class="code"><div class="wrapper">			<span class="hljs-keyword">this</span>.api( <span class="hljs-literal">true</span> ).draw( ! complete );
		};
		
		</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Filter the input based on data
 @param {string} sInput String to filter the table on
 @param {int|null} [iColumn] Column to limit filtering to
 @param {bool} [bRegex=false] Treat as regular expression or not
 @param {bool} [bSmart=true] Perform smart filtering or not
 @param {bool} [bShowGlobal=true] Show the input global filter in it&#39;s input box(es)
 @param {bool} [bCaseInsensitive=true] Do case-insensitive matching (true) or not (false)
 @dtopt API
 @deprecated Since v1.10</p>
<p> @example
   $(document).ready(function() {
     var oTable = $(&#39;#example&#39;).dataTable();</p>
<pre><code> // Sometime later - filter...
 oTable.fnFilter( &#39;test string&#39; );</code></pre>
<p>   } );</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-keyword">this</span>.fnFilter = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( sInput, iColumn, bRegex, bSmart, bShowGlobal, bCaseInsensitive )</span>
		{</span>
			<span class="hljs-keyword">var</span> api = <span class="hljs-keyword">this</span>.api( <span class="hljs-literal">true</span> );
		
			<span class="hljs-keyword">if</span> ( iColumn === <span class="hljs-literal">null</span> || iColumn === <span class="hljs-literal">undefined</span> ) {
				api.search( sInput, bRegex, bSmart, bCaseInsensitive );
			}
			<span class="hljs-keyword">else</span> {
				api.column( iColumn ).search( sInput, bRegex, bSmart, bCaseInsensitive );
			}
		
			api.draw();
		};
		
		</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Get the data for the whole table, an individual row or an individual cell based on the
provided parameters.
 @param {int|node} [src] A TR row node, TD/TH cell node or an integer. If given as
   a TR node then the data source for the whole row will be returned. If given as a
   TD/TH cell node then iCol will be automatically calculated and the data for the
   cell returned. If given as an integer, then this is treated as the aoData internal
   data index for the row (see fnGetPosition) and the data for that row used.
 @param {int} [col] Optional column index that you want the data of.
 @returns {array|object|string} If mRow is undefined, then the data for all rows is
   returned. If mRow is defined, just data for that row, and is iCol is
   defined, only data for the designated cell is returned.
 @dtopt API
 @deprecated Since v1.10</p>
<p> @example
   // Row data
   $(document).ready(function() {
     oTable = $(&#39;#example&#39;).dataTable();</p>
<pre><code> oTable.$(&#39;tr&#39;).click( function () {
   var data = oTable.fnGetData( this );
   // ... do something with the array / object of data for the row
 } );</code></pre>
<p>   } );</p>
<p> @example
   // Individual cell data
   $(document).ready(function() {
     oTable = $(&#39;#example&#39;).dataTable();</p>
<pre><code> oTable.$(&#39;td&#39;).click( function () {
   var sData = oTable.fnGetData( this );
   alert( &#39;The cell clicked on had the value of &#39;+sData );
 } );</code></pre>
<p>   } );</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-keyword">this</span>.fnGetData = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( src, col )</span>
		{</span>
			<span class="hljs-keyword">var</span> api = <span class="hljs-keyword">this</span>.api( <span class="hljs-literal">true</span> );
		
			<span class="hljs-keyword">if</span> ( src !== <span class="hljs-literal">undefined</span> ) {
				<span class="hljs-keyword">var</span> type = src.nodeName ? src.nodeName.toLowerCase() : <span class="hljs-string">''</span>;
		
				<span class="hljs-keyword">return</span> col !== <span class="hljs-literal">undefined</span> || type == <span class="hljs-string">'td'</span> || type == <span class="hljs-string">'th'</span> ?
					api.cell( src, col ).data() :
					api.row( src ).data() || <span class="hljs-literal">null</span>;
			}
		
			<span class="hljs-keyword">return</span> api.data().toArray();
		};
		
		</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Get an array of the TR nodes that are used in the table&#39;s body. Note that you will
typically want to use the &#39;$&#39; API method in preference to this as it is more
flexible.
 @param {int} [iRow] Optional row index for the TR element you want
 @returns {array|node} If iRow is undefined, returns an array of all TR elements
   in the table&#39;s body, or iRow is defined, just the TR element requested.
 @dtopt API
 @deprecated Since v1.10</p>
<p> @example
   $(document).ready(function() {
     var oTable = $(&#39;#example&#39;).dataTable();</p>
<pre><code> // Get the nodes from the table
 var nNodes = oTable.fnGetNodes( );</code></pre>
<p>   } );</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-keyword">this</span>.fnGetNodes = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( iRow )</span>
		{</span>
			<span class="hljs-keyword">var</span> api = <span class="hljs-keyword">this</span>.api( <span class="hljs-literal">true</span> );
		
			<span class="hljs-keyword">return</span> iRow !== <span class="hljs-literal">undefined</span> ?
				api.row( iRow ).node() :
				api.rows().nodes().flatten().toArray();
		};
		
		</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Get the array indexes of a particular cell from it&#39;s DOM element
and column index including hidden columns
 @param {node} node this can either be a TR, TD or TH in the table&#39;s body
 @returns {int} If nNode is given as a TR, then a single index is returned, or
   if given as a cell, an array of [row index, column index (visible),
   column index (all)] is given.
 @dtopt API
 @deprecated Since v1.10</p>
<p> @example
   $(document).ready(function() {
     $(&#39;#example tbody td&#39;).click( function () {
       // Get the position of the current data from the node
       var aPos = oTable.fnGetPosition( this );</p>
<pre><code>   // Get the data array for this row
   var aData = oTable.fnGetData( aPos[0] );

   // Update the data array and return the value
   aData[ aPos[1] ] = &#39;clicked&#39;;
   this.innerHTML = &#39;clicked&#39;;
 } );

 // Init DataTables
 oTable = $(&#39;#example&#39;).dataTable();</code></pre>
<p>   } );</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-keyword">this</span>.fnGetPosition = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( node )</span>
		{</span>
			<span class="hljs-keyword">var</span> api = <span class="hljs-keyword">this</span>.api( <span class="hljs-literal">true</span> );
			<span class="hljs-keyword">var</span> nodeName = node.nodeName.toUpperCase();
		
			<span class="hljs-keyword">if</span> ( nodeName == <span class="hljs-string">'TR'</span> ) {
				<span class="hljs-keyword">return</span> api.row( node ).index();
			}
			<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( nodeName == <span class="hljs-string">'TD'</span> || nodeName == <span class="hljs-string">'TH'</span> ) {
				<span class="hljs-keyword">var</span> cell = api.cell( node ).index();
		
				<span class="hljs-keyword">return</span> [
					cell.row,
					cell.columnVisible,
					cell.column
				];
			}
			<span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
		};
		
		</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Check to see if a row is &#39;open&#39; or not.
 @param {node} nTr the table row to check
 @returns {boolean} true if the row is currently open, false otherwise
 @dtopt API
 @deprecated Since v1.10</p>
<p> @example
   $(document).ready(function() {
     var oTable;</p>
<pre><code> // &#39;open&#39; an information row when a row is clicked on
 $(&#39;#example tbody tr&#39;).click( function () {
   if ( oTable.fnIsOpen(this) ) {
     oTable.fnClose( this );
   } else {
     oTable.fnOpen( this, &quot;Temporary row opened&quot;, &quot;info_row&quot; );
   }
 } );

 oTable = $(&#39;#example&#39;).dataTable();</code></pre>
<p>   } );</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-keyword">this</span>.fnIsOpen = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( nTr )</span>
		{</span>
			<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.api( <span class="hljs-literal">true</span> ).row( nTr ).child.isShown();
		};
		
		</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>This function will place a new row directly after a row which is currently
on display on the page, with the HTML contents that is passed into the
function. This can be used, for example, to ask for confirmation that a
particular record should be deleted.
 @param {node} nTr The table row to &#39;open&#39;
 @param {string|node|jQuery} mHtml The HTML to put into the row
 @param {string} sClass Class to give the new TD cell
 @returns {node} The row opened. Note that if the table row passed in as the
   first parameter, is not found in the table, this method will silently
   return.
 @dtopt API
 @deprecated Since v1.10</p>
<p> @example
   $(document).ready(function() {
     var oTable;</p>
<pre><code> // &#39;open&#39; an information row when a row is clicked on
 $(&#39;#example tbody tr&#39;).click( function () {
   if ( oTable.fnIsOpen(this) ) {
     oTable.fnClose( this );
   } else {
     oTable.fnOpen( this, &quot;Temporary row opened&quot;, &quot;info_row&quot; );
   }
 } );

 oTable = $(&#39;#example&#39;).dataTable();</code></pre>
<p>   } );</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-keyword">this</span>.fnOpen = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( nTr, mHtml, sClass )</span>
		{</span>
			<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.api( <span class="hljs-literal">true</span> )
				.row( nTr )
				.child( mHtml, sClass )
				.show()
				.child()[<span class="hljs-number">0</span>];
		};
		
		</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Change the pagination - provides the internal logic for pagination in a simple API
function. With this function you can have a DataTables table go to the next,
previous, first or last pages.
 @param {string|int} mAction Paging action to take: &quot;first&quot;, &quot;previous&quot;, &quot;next&quot; or &quot;last&quot;
   or page number to jump to (integer), note that page 0 is the first page.
 @param {bool} [bRedraw=true] Redraw the table or not
 @dtopt API
 @deprecated Since v1.10</p>
<p> @example
   $(document).ready(function() {
     var oTable = $(&#39;#example&#39;).dataTable();
     oTable.fnPageChange( &#39;next&#39; );
   } );</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-keyword">this</span>.fnPageChange = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">( mAction, bRedraw )</span>
		{</span>
			<span class="hljs-keyword">var</span> api = <span class="hljs-keyword">this</span>.api( <span class="hljs-literal">true</span> ).page( mAction );
		
			<span class="hljs-keyword">if</span> ( bRedraw === <span class="hljs-literal">undefined</span> || bRedraw ) {
				api.draw(<span class="hljs-literal">false</span>);
			}
		};
		
		</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Show a particular column
 @param {int} iCol The column whose display should be changed
 @param {bool} bShow Show (true) or hide (false) the column
 @param {bool} [bRedraw=true] Redraw the table or not
 @dtopt API
 @deprecated Since v1.10</p>
<p> @example
   $(document).ready(function() {
     var oTable = $(&#39;#example&#39;).dataTable();</p>
<pre><code> // Hide the second column after initialisation
 oTable.fnSetColumnVis( 1, false );</code></pre>
<p>   } );</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-keyword">this</span>.fnSetColumnVis = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">( iCol, bShow, bRedraw )</span>
		{</span>
			<span class="hljs-keyword">var</span> api = <span class="hljs-keyword">this</span>.api( <span class="hljs-literal">true</span> ).column( iCol ).visible( bShow );
		
			<span class="hljs-keyword">if</span> ( bRedraw === <span class="hljs-literal">undefined</span> || bRedraw ) {
				api.columns.adjust().draw();
			}
		};
		
		</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Get the settings for a particular table for external manipulation
 @returns {object} DataTables settings object. See
   {@link DataTable.models.oSettings}
 @dtopt API
 @deprecated Since v1.10</p>
<p> @example
   $(document).ready(function() {
     var oTable = $(&#39;#example&#39;).dataTable();
     var oSettings = oTable.fnSettings();</p>
<pre><code> // Show an example parameter from the settings
 alert( oSettings._iDisplayStart );</code></pre>
<p>   } );</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-keyword">this</span>.fnSettings = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span>
		{</span>
			<span class="hljs-keyword">return</span> _fnSettingsFromNode( <span class="hljs-keyword">this</span>[_ext.iApiIndex] );
		};
		
		</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Sort the table by a particular column
 @param {int} iCol the data index to sort on. Note that this will not match the
   &#39;display index&#39; if you have hidden data entries
 @dtopt API
 @deprecated Since v1.10</p>
<p> @example
   $(document).ready(function() {
     var oTable = $(&#39;#example&#39;).dataTable();</p>
<pre><code> // Sort immediately with columns 0 and 1
 oTable.fnSort( [ [0,&#39;asc&#39;], [1,&#39;asc&#39;] ] );</code></pre>
<p>   } );</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-keyword">this</span>.fnSort = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( aaSort )</span>
		{</span>
			<span class="hljs-keyword">this</span>.api( <span class="hljs-literal">true</span> ).order( aaSort ).draw();
		};
		
		</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Attach a sort listener to an element for a given column
 @param {node} nNode the element to attach the sort listener to
 @param {int} iColumn the column that a click on this node will sort on
 @param {function} [fnCallback] callback function when sort is run
 @dtopt API
 @deprecated Since v1.10</p>
<p> @example
   $(document).ready(function() {
     var oTable = $(&#39;#example&#39;).dataTable();</p>
<pre><code> // Sort on column 1, when &#39;sorter&#39; is clicked on
 oTable.fnSortListener( document.getElementById(&#39;sorter&#39;), 1 );</code></pre>
<p>   } );</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-keyword">this</span>.fnSortListener = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( nNode, iColumn, fnCallback )</span>
		{</span>
			<span class="hljs-keyword">this</span>.api( <span class="hljs-literal">true</span> ).order.listener( nNode, iColumn, fnCallback );
		};
		
		</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Update a table cell or row - this method will accept either a single value to
update the cell with, an array of values with one element for each column or
an object in the same format as the original data source. The function is
self-referencing in order to make the multi column updates easier.
 @param {object|array|string} mData Data to update the cell/row with
 @param {node|int} mRow TR element you want to update or the aoData index
 @param {int} [iColumn] The column to update, give as null or undefined to
   update a whole row.
 @param {bool} [bRedraw=true] Redraw the table or not
 @param {bool} [bAction=true] Perform pre-draw actions or not
 @returns {int} 0 on success, 1 on error
 @dtopt API
 @deprecated Since v1.10</p>
<p> @example
   $(document).ready(function() {
     var oTable = $(&#39;#example&#39;).dataTable();
     oTable.fnUpdate( &#39;Example update&#39;, 0, 0 ); // Single cell
     oTable.fnUpdate( [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;], $(&#39;tbody tr&#39;)[0] ); // Row
   } );</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-keyword">this</span>.fnUpdate = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( mData, mRow, iColumn, bRedraw, bAction )</span>
		{</span>
			<span class="hljs-keyword">var</span> api = <span class="hljs-keyword">this</span>.api( <span class="hljs-literal">true</span> );
		
			<span class="hljs-keyword">if</span> ( iColumn === <span class="hljs-literal">undefined</span> || iColumn === <span class="hljs-literal">null</span> ) {
				api.row( mRow ).data( mData );
			}
			<span class="hljs-keyword">else</span> {
				api.cell( mRow, iColumn ).data( mData );
			}
		
			<span class="hljs-keyword">if</span> ( bAction === <span class="hljs-literal">undefined</span> || bAction ) {
				api.columns.adjust();
			}
		
			<span class="hljs-keyword">if</span> ( bRedraw === <span class="hljs-literal">undefined</span> || bRedraw ) {
				api.draw();
			}
			<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
		};
		
		</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Provide a common method for plug-ins to check the version of DataTables being used, in order
to ensure compatibility.
 @param {string} sVersion Version string to check for, in the format &quot;X.Y.Z&quot;. Note that the
   formats &quot;X&quot; and &quot;X.Y&quot; are also acceptable.
 @returns {boolean} true if this version of DataTables is greater or equal to the required
   version, or false if this version of DataTales is not suitable
 @method
 @dtopt API
 @deprecated Since v1.10</p>
<p> @example
   $(document).ready(function() {
     var oTable = $(&#39;#example&#39;).dataTable();
     alert( oTable.fnVersionCheck( &#39;1.9.0&#39; ) );
   } );</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-keyword">this</span>.fnVersionCheck = _ext.fnVersionCheck;
		

		<span class="hljs-keyword">var</span> _that = <span class="hljs-keyword">this</span>;
		<span class="hljs-keyword">var</span> emptyInit = options === <span class="hljs-literal">undefined</span>;
		<span class="hljs-keyword">var</span> len = <span class="hljs-keyword">this</span>.length;

		<span class="hljs-keyword">if</span> ( emptyInit ) {
			options = {};
		}

		<span class="hljs-keyword">this</span>.oApi = <span class="hljs-keyword">this</span>.internal = _ext.internal;</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Extend with old style plug-in API methods</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-keyword">for</span> ( <span class="hljs-keyword">var</span> fn <span class="hljs-keyword">in</span> DataTable.ext.internal ) {
			<span class="hljs-keyword">if</span> ( fn ) {
				<span class="hljs-keyword">this</span>[fn] = _fnExternApiFunc(fn);
			}
		}

		<span class="hljs-keyword">this</span>.each(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>For each initialisation we want to give it a clean initialisation
object that can be bashed around</p></div></div><div class="code"><div class="wrapper">			<span class="hljs-keyword">var</span> o = {};
			<span class="hljs-keyword">var</span> oInit = len &gt; <span class="hljs-number">1</span> ? <span class="hljs-comment">// optimisation for single table case</span>
				_fnExtend( o, options, <span class="hljs-literal">true</span> ) :
				options;

			<span class="hljs-comment">/*global oInit,_that,emptyInit*/</span>
			<span class="hljs-keyword">var</span> i=<span class="hljs-number">0</span>, iLen, j, jLen, k, kLen;
			<span class="hljs-keyword">var</span> sId = <span class="hljs-keyword">this</span>.getAttribute( <span class="hljs-string">'id'</span> );
			<span class="hljs-keyword">var</span> bInitHandedOff = <span class="hljs-literal">false</span>;
			<span class="hljs-keyword">var</span> defaults = DataTable.defaults;
			
			</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Sanity check </p></div></div><div class="code"><div class="wrapper">			<span class="hljs-keyword">if</span> ( <span class="hljs-keyword">this</span>.nodeName.toLowerCase() != <span class="hljs-string">'table'</span> )
			{
				_fnLog( <span class="hljs-literal">null</span>, <span class="hljs-number">0</span>, <span class="hljs-string">'Non-table node initialisation ('</span>+<span class="hljs-keyword">this</span>.nodeName+<span class="hljs-string">')'</span>, <span class="hljs-number">2</span> );
				<span class="hljs-keyword">return</span>;
			}
			</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Backwards compatibility for the defaults </p></div></div><div class="code"><div class="wrapper">			_fnCompatOpts( defaults );
			_fnCompatCols( defaults.column );
			</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Convert the camel-case defaults to Hungarian </p></div></div><div class="code"><div class="wrapper">			_fnCamelToHungarian( defaults, defaults, <span class="hljs-literal">true</span> );
			_fnCamelToHungarian( defaults.column, defaults.column, <span class="hljs-literal">true</span> );
			</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Setting up the initialisation object </p></div></div><div class="code"><div class="wrapper">			_fnCamelToHungarian( defaults, oInit );
			</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Check to see if we are re-initialising a table </p></div></div><div class="code"><div class="wrapper">			<span class="hljs-keyword">var</span> allSettings = DataTable.settings;
			<span class="hljs-keyword">for</span> ( i=<span class="hljs-number">0</span>, iLen=allSettings.length ; i&lt;iLen ; i++ )
			{</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Base check on table node </p></div></div><div class="code"><div class="wrapper">				<span class="hljs-keyword">if</span> ( allSettings[i].nTable == <span class="hljs-keyword">this</span> )
				{
					<span class="hljs-keyword">var</span> bRetrieve = oInit.bRetrieve !== <span class="hljs-literal">undefined</span> ? oInit.bRetrieve : defaults.bRetrieve;
					<span class="hljs-keyword">var</span> bDestroy = oInit.bDestroy !== <span class="hljs-literal">undefined</span> ? oInit.bDestroy : defaults.bDestroy;
			
					<span class="hljs-keyword">if</span> ( emptyInit || bRetrieve )
					{
						<span class="hljs-keyword">return</span> allSettings[i].oInstance;
					}
					<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( bDestroy )
					{
						allSettings[i].oInstance.fnDestroy();
						<span class="hljs-keyword">break</span>;
					}
					<span class="hljs-keyword">else</span>
					{
						_fnLog( allSettings[i], <span class="hljs-number">0</span>, <span class="hljs-string">'Cannot reinitialise DataTable'</span>, <span class="hljs-number">3</span> );
						<span class="hljs-keyword">return</span>;
					}
				}
			</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>If the element we are initialising has the same ID as a table which was previously
initialised, but the table nodes don&#39;t match (from before) then we destroy the old
instance by simply deleting it. This is under the assumption that the table has been
destroyed by other methods. Anyone using non-id selectors will need to do this manually</p></div></div><div class="code"><div class="wrapper">				<span class="hljs-keyword">if</span> ( allSettings[i].sTableId == <span class="hljs-keyword">this</span>.id )
				{
					allSettings.splice( i, <span class="hljs-number">1</span> );
					<span class="hljs-keyword">break</span>;
				}
			}
			</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Ensure the table has an ID - required for accessibility </p></div></div><div class="code"><div class="wrapper">			<span class="hljs-keyword">if</span> ( sId === <span class="hljs-literal">null</span> || sId === <span class="hljs-string">""</span> )
			{
				sId = <span class="hljs-string">"DataTables_Table_"</span>+(DataTable.ext._unique++);
				<span class="hljs-keyword">this</span>.id = sId;
			}
			</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Create the settings object for this table and set some of the default parameters </p></div></div><div class="code"><div class="wrapper">			<span class="hljs-keyword">var</span> oSettings = $.extend( <span class="hljs-literal">true</span>, {}, DataTable.models.oSettings, {
				<span class="hljs-string">"nTable"</span>:        <span class="hljs-keyword">this</span>,
				<span class="hljs-string">"oApi"</span>:          _that.internal,
				<span class="hljs-string">"oInit"</span>:         oInit,
				<span class="hljs-string">"sDestroyWidth"</span>: $(<span class="hljs-keyword">this</span>)[<span class="hljs-number">0</span>].style.width,
				<span class="hljs-string">"sInstance"</span>:     sId,
				<span class="hljs-string">"sTableId"</span>:      sId
			} );
			allSettings.push( oSettings );
			</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Need to add the instance after the instance after the settings object has been added
to the settings array, so we can self reference the table instance if more than one</p></div></div><div class="code"><div class="wrapper">			oSettings.oInstance = (_that.length===<span class="hljs-number">1</span>) ? _that : $(<span class="hljs-keyword">this</span>).dataTable();
			</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Backwards compatibility, before we apply all the defaults</p></div></div><div class="code"><div class="wrapper">			_fnCompatOpts( oInit );
			
			<span class="hljs-keyword">if</span> ( oInit.oLanguage )
			{
				_fnLanguageCompat( oInit.oLanguage );
			}
			</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>If the length menu is given, but the init display length is not, use the length menu</p></div></div><div class="code"><div class="wrapper">			<span class="hljs-keyword">if</span> ( oInit.aLengthMenu &amp;&amp; ! oInit.iDisplayLength )
			{
				oInit.iDisplayLength = $.isArray( oInit.aLengthMenu[<span class="hljs-number">0</span>] ) ?
					oInit.aLengthMenu[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] : oInit.aLengthMenu[<span class="hljs-number">0</span>];
			}
			</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Apply the defaults and init options to make a single init object will all
options defined from defaults and instance options.</p></div></div><div class="code"><div class="wrapper">			oInit = _fnExtend( $.extend( <span class="hljs-literal">true</span>, {}, defaults ), oInit );
			
			</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Map the initialisation options onto the settings object</p></div></div><div class="code"><div class="wrapper">			_fnMap( oSettings.oFeatures, oInit, [
				<span class="hljs-string">"bPaginate"</span>,
				<span class="hljs-string">"bLengthChange"</span>,
				<span class="hljs-string">"bFilter"</span>,
				<span class="hljs-string">"bSort"</span>,
				<span class="hljs-string">"bSortMulti"</span>,
				<span class="hljs-string">"bInfo"</span>,
				<span class="hljs-string">"bProcessing"</span>,
				<span class="hljs-string">"bAutoWidth"</span>,
				<span class="hljs-string">"bSortClasses"</span>,
				<span class="hljs-string">"bServerSide"</span>,
				<span class="hljs-string">"bDeferRender"</span>
			] );
			_fnMap( oSettings, oInit, [
				<span class="hljs-string">"asStripeClasses"</span>,
				<span class="hljs-string">"ajax"</span>,
				<span class="hljs-string">"fnServerData"</span>,
				<span class="hljs-string">"fnFormatNumber"</span>,
				<span class="hljs-string">"sServerMethod"</span>,
				<span class="hljs-string">"aaSorting"</span>,
				<span class="hljs-string">"aaSortingFixed"</span>,
				<span class="hljs-string">"aLengthMenu"</span>,
				<span class="hljs-string">"sPaginationType"</span>,
				<span class="hljs-string">"sAjaxSource"</span>,
				<span class="hljs-string">"sAjaxDataProp"</span>,
				<span class="hljs-string">"iStateDuration"</span>,
				<span class="hljs-string">"sDom"</span>,
				<span class="hljs-string">"bSortCellsTop"</span>,
				<span class="hljs-string">"iTabIndex"</span>,
				<span class="hljs-string">"fnStateLoadCallback"</span>,
				<span class="hljs-string">"fnStateSaveCallback"</span>,
				<span class="hljs-string">"renderer"</span>,
				[ <span class="hljs-string">"iCookieDuration"</span>, <span class="hljs-string">"iStateDuration"</span> ], <span class="hljs-comment">// backwards compat</span>
				[ <span class="hljs-string">"oSearch"</span>, <span class="hljs-string">"oPreviousSearch"</span> ],
				[ <span class="hljs-string">"aoSearchCols"</span>, <span class="hljs-string">"aoPreSearchCols"</span> ],
				[ <span class="hljs-string">"iDisplayLength"</span>, <span class="hljs-string">"_iDisplayLength"</span> ],
				[ <span class="hljs-string">"bJQueryUI"</span>, <span class="hljs-string">"bJUI"</span> ]
			] );
			_fnMap( oSettings.oScroll, oInit, [
				[ <span class="hljs-string">"sScrollX"</span>, <span class="hljs-string">"sX"</span> ],
				[ <span class="hljs-string">"sScrollXInner"</span>, <span class="hljs-string">"sXInner"</span> ],
				[ <span class="hljs-string">"sScrollY"</span>, <span class="hljs-string">"sY"</span> ],
				[ <span class="hljs-string">"bScrollCollapse"</span>, <span class="hljs-string">"bCollapse"</span> ]
			] );
			_fnMap( oSettings.oLanguage, oInit, <span class="hljs-string">"fnInfoCallback"</span> );
			</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Callback functions which are array driven </p></div></div><div class="code"><div class="wrapper">			_fnCallbackReg( oSettings, <span class="hljs-string">'aoDrawCallback'</span>,       oInit.fnDrawCallback,      <span class="hljs-string">'user'</span> );
			_fnCallbackReg( oSettings, <span class="hljs-string">'aoServerParams'</span>,       oInit.fnServerParams,      <span class="hljs-string">'user'</span> );
			_fnCallbackReg( oSettings, <span class="hljs-string">'aoStateSaveParams'</span>,    oInit.fnStateSaveParams,   <span class="hljs-string">'user'</span> );
			_fnCallbackReg( oSettings, <span class="hljs-string">'aoStateLoadParams'</span>,    oInit.fnStateLoadParams,   <span class="hljs-string">'user'</span> );
			_fnCallbackReg( oSettings, <span class="hljs-string">'aoStateLoaded'</span>,        oInit.fnStateLoaded,       <span class="hljs-string">'user'</span> );
			_fnCallbackReg( oSettings, <span class="hljs-string">'aoRowCallback'</span>,        oInit.fnRowCallback,       <span class="hljs-string">'user'</span> );
			_fnCallbackReg( oSettings, <span class="hljs-string">'aoRowCreatedCallback'</span>, oInit.fnCreatedRow,        <span class="hljs-string">'user'</span> );
			_fnCallbackReg( oSettings, <span class="hljs-string">'aoHeaderCallback'</span>,     oInit.fnHeaderCallback,    <span class="hljs-string">'user'</span> );
			_fnCallbackReg( oSettings, <span class="hljs-string">'aoFooterCallback'</span>,     oInit.fnFooterCallback,    <span class="hljs-string">'user'</span> );
			_fnCallbackReg( oSettings, <span class="hljs-string">'aoInitComplete'</span>,       oInit.fnInitComplete,      <span class="hljs-string">'user'</span> );
			_fnCallbackReg( oSettings, <span class="hljs-string">'aoPreDrawCallback'</span>,    oInit.fnPreDrawCallback,   <span class="hljs-string">'user'</span> );
			
			<span class="hljs-keyword">var</span> oClasses = oSettings.oClasses;
			</div></div></div><div class="segment"><div class="comments doc-section"><div class="wrapper"><p>TODO: Remove in 1.11</p></div></div><div class="code"><div class="wrapper">			<span class="hljs-keyword">if</span> ( oInit.bJQueryUI )
			{</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Use the JUI classes object for display. You could clone the oStdClasses object if
you want to have multiple tables with multiple independent classes</p></div></div><div class="code"><div class="wrapper">				$.extend( oClasses, DataTable.ext.oJUIClasses, oInit.oClasses );
			
				<span class="hljs-keyword">if</span> ( oInit.sDom === defaults.sDom &amp;&amp; defaults.sDom === <span class="hljs-string">"lfrtip"</span> )
				{</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Set the DOM to use a layout suitable for jQuery UI&#39;s theming </p></div></div><div class="code"><div class="wrapper">					oSettings.sDom = <span class="hljs-string">'&lt;"H"lfr&gt;t&lt;"F"ip&gt;'</span>;
				}
			
				<span class="hljs-keyword">if</span> ( ! oSettings.renderer ) {
					oSettings.renderer = <span class="hljs-string">'jqueryui'</span>;
				}
				<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( $.isPlainObject( oSettings.renderer ) &amp;&amp; ! oSettings.renderer.header ) {
					oSettings.renderer.header = <span class="hljs-string">'jqueryui'</span>;
				}
			}
			<span class="hljs-keyword">else</span>
			{
				$.extend( oClasses, DataTable.ext.classes, oInit.oClasses );
			}
			$(<span class="hljs-keyword">this</span>).addClass( oClasses.sTable );
			</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Calculate the scroll bar width and cache it for use later on </p></div></div><div class="code"><div class="wrapper">			<span class="hljs-keyword">if</span> ( oSettings.oScroll.sX !== <span class="hljs-string">""</span> || oSettings.oScroll.sY !== <span class="hljs-string">""</span> )
			{
				oSettings.oScroll.iBarWidth = _fnScrollBarWidth();
			}
			<span class="hljs-keyword">if</span> ( oSettings.oScroll.sX === <span class="hljs-literal">true</span> ) { <span class="hljs-comment">// Easy initialisation of x-scrolling</span>
				oSettings.oScroll.sX = <span class="hljs-string">'100%'</span>;
			}
			
			<span class="hljs-keyword">if</span> ( oSettings.iInitDisplayStart === <span class="hljs-literal">undefined</span> )
			{</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Display start point, taking into account the save saving </p></div></div><div class="code"><div class="wrapper">				oSettings.iInitDisplayStart = oInit.iDisplayStart;
				oSettings._iDisplayStart = oInit.iDisplayStart;
			}
			
			<span class="hljs-keyword">if</span> ( oInit.iDeferLoading !== <span class="hljs-literal">null</span> )
			{
				oSettings.bDeferLoading = <span class="hljs-literal">true</span>;
				<span class="hljs-keyword">var</span> tmp = $.isArray( oInit.iDeferLoading );
				oSettings._iRecordsDisplay = tmp ? oInit.iDeferLoading[<span class="hljs-number">0</span>] : oInit.iDeferLoading;
				oSettings._iRecordsTotal = tmp ? oInit.iDeferLoading[<span class="hljs-number">1</span>] : oInit.iDeferLoading;
			}
			</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Language definitions </p></div></div><div class="code"><div class="wrapper">			<span class="hljs-keyword">if</span> ( oInit.oLanguage.sUrl !== <span class="hljs-string">""</span> )
			{</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Get the language definitions from a file - because this Ajax call makes the language
get async to the remainder of this function we use bInitHandedOff to indicate that
_fnInitialise will be fired by the returned Ajax handler, rather than the constructor</p></div></div><div class="code"><div class="wrapper">				oSettings.oLanguage.sUrl = oInit.oLanguage.sUrl;
				$.getJSON( oSettings.oLanguage.sUrl, <span class="hljs-literal">null</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( json )</span> {</span>
					_fnLanguageCompat( json );
					_fnCamelToHungarian( defaults.oLanguage, json );
					$.extend( <span class="hljs-literal">true</span>, oSettings.oLanguage, oInit.oLanguage, json );
					_fnInitialise( oSettings );
				} );
				bInitHandedOff = <span class="hljs-literal">true</span>;
			}
			<span class="hljs-keyword">else</span>
			{
				$.extend( <span class="hljs-literal">true</span>, oSettings.oLanguage, oInit.oLanguage );
			}
			
			</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Stripes</p></div></div><div class="code"><div class="wrapper">			<span class="hljs-keyword">if</span> ( oInit.asStripeClasses === <span class="hljs-literal">null</span> )
			{
				oSettings.asStripeClasses =[
					oClasses.sStripeOdd,
					oClasses.sStripeEven
				];
			}
			</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Remove row stripe classes if they are already on the table row </p></div></div><div class="code"><div class="wrapper">			<span class="hljs-keyword">var</span> stripeClasses = oSettings.asStripeClasses;
			<span class="hljs-keyword">var</span> rowOne = $(<span class="hljs-string">'tbody tr:eq(0)'</span>, <span class="hljs-keyword">this</span>);
			<span class="hljs-keyword">if</span> ( $.inArray( <span class="hljs-literal">true</span>, $.map( stripeClasses, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(el, i)</span> {</span>
				<span class="hljs-keyword">return</span> rowOne.hasClass(el);
			} ) ) !== -<span class="hljs-number">1</span> ) {
				$(<span class="hljs-string">'tbody tr'</span>, <span class="hljs-keyword">this</span>).removeClass( stripeClasses.join(<span class="hljs-string">' '</span>) );
				oSettings.asDestroyStripes = stripeClasses.slice();
			}
			</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Columns
See if we should load columns automatically or use defined ones</p></div></div><div class="code"><div class="wrapper">			<span class="hljs-keyword">var</span> anThs = [];
			<span class="hljs-keyword">var</span> aoColumnsInit;
			<span class="hljs-keyword">var</span> nThead = <span class="hljs-keyword">this</span>.getElementsByTagName(<span class="hljs-string">'thead'</span>);
			<span class="hljs-keyword">if</span> ( nThead.length !== <span class="hljs-number">0</span> )
			{
				_fnDetectHeader( oSettings.aoHeader, nThead[<span class="hljs-number">0</span>] );
				anThs = _fnGetUniqueThs( oSettings );
			}
			</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>If not given a column array, generate one with nulls </p></div></div><div class="code"><div class="wrapper">			<span class="hljs-keyword">if</span> ( oInit.aoColumns === <span class="hljs-literal">null</span> )
			{
				aoColumnsInit = [];
				<span class="hljs-keyword">for</span> ( i=<span class="hljs-number">0</span>, iLen=anThs.length ; i&lt;iLen ; i++ )
				{
					aoColumnsInit.push( <span class="hljs-literal">null</span> );
				}
			}
			<span class="hljs-keyword">else</span>
			{
				aoColumnsInit = oInit.aoColumns;
			}
			</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Add the columns </p></div></div><div class="code"><div class="wrapper">			<span class="hljs-keyword">for</span> ( i=<span class="hljs-number">0</span>, iLen=aoColumnsInit.length ; i&lt;iLen ; i++ )
			{
				_fnAddColumn( oSettings, anThs ? anThs[i] : <span class="hljs-literal">null</span> );
			}
			</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Apply the column definitions </p></div></div><div class="code"><div class="wrapper">			_fnApplyColumnDefs( oSettings, oInit.aoColumnDefs, aoColumnsInit, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(iCol, oDef)</span> {</span>
				_fnColumnOptions( oSettings, iCol, oDef );
			} );
			</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>HTML5 attribute detection - build an mData object automatically if the
attributes are found</p></div></div><div class="code"><div class="wrapper">			<span class="hljs-keyword">if</span> ( rowOne.length ) {
				<span class="hljs-keyword">var</span> a = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">( cell, name )</span> {</span>
					<span class="hljs-keyword">return</span> cell.getAttribute( <span class="hljs-string">'data-'</span>+name ) ? name : <span class="hljs-literal">null</span>;
				};
			
				$.each( _fnGetRowElements( oSettings, rowOne[<span class="hljs-number">0</span>] ).cells, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(i, cell)</span> {</span>
					<span class="hljs-keyword">var</span> col = oSettings.aoColumns[i];
			
					<span class="hljs-keyword">if</span> ( col.mData === i ) {
						<span class="hljs-keyword">var</span> sort = a( cell, <span class="hljs-string">'sort'</span> ) || a( cell, <span class="hljs-string">'order'</span> );
						<span class="hljs-keyword">var</span> filter = a( cell, <span class="hljs-string">'filter'</span> ) || a( cell, <span class="hljs-string">'search'</span> );
			
						<span class="hljs-keyword">if</span> ( sort !== <span class="hljs-literal">null</span> || filter !== <span class="hljs-literal">null</span> ) {
							col.mData = {
								_:      i+<span class="hljs-string">'.display'</span>,
								sort:   sort !== <span class="hljs-literal">null</span>   ? i+<span class="hljs-string">'.@data-'</span>+sort   : <span class="hljs-literal">undefined</span>,
								type:   sort !== <span class="hljs-literal">null</span>   ? i+<span class="hljs-string">'.@data-'</span>+sort   : <span class="hljs-literal">undefined</span>,
								filter: filter !== <span class="hljs-literal">null</span> ? i+<span class="hljs-string">'.@data-'</span>+filter : <span class="hljs-literal">undefined</span>
							};
			
							_fnColumnOptions( oSettings, i );
						}
					}
				} );
			}
			
			<span class="hljs-keyword">var</span> features = oSettings.oFeatures;
			</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Must be done after everything which can be overridden by the state saving! </p></div></div><div class="code"><div class="wrapper">			<span class="hljs-keyword">if</span> ( oInit.bStateSave )
			{
				features.bStateSave = <span class="hljs-literal">true</span>;
				_fnLoadState( oSettings, oInit );
				_fnCallbackReg( oSettings, <span class="hljs-string">'aoDrawCallback'</span>, _fnSaveState, <span class="hljs-string">'state_save'</span> );
			}
			
			</div></div></div><div class="segment"><div class="comments doc-section"><div class="wrapper"><p>Sorting</p>
<p>TODO: For modularisation (1.11) this needs to do into a sort start up handler</p></div></div><div class="code"><div class="wrapper">			</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>If aaSorting is not defined, then we use the first indicator in asSorting
in case that has been altered, so the default sort reflects that option</p></div></div><div class="code"><div class="wrapper">			<span class="hljs-keyword">if</span> ( oInit.aaSorting === <span class="hljs-literal">undefined</span> )
			{
				<span class="hljs-keyword">var</span> sorting = oSettings.aaSorting;
				<span class="hljs-keyword">for</span> ( i=<span class="hljs-number">0</span>, iLen=sorting.length ; i&lt;iLen ; i++ )
				{
					sorting[i][<span class="hljs-number">1</span>] = oSettings.aoColumns[ i ].asSorting[<span class="hljs-number">0</span>];
				}
			}
			</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Do a first pass on the sorting classes (allows any size changes to be taken into
account, and also will apply sorting disabled classes if disabled</p></div></div><div class="code"><div class="wrapper">			_fnSortingClasses( oSettings );
			
			<span class="hljs-keyword">if</span> ( features.bSort )
			{
				_fnCallbackReg( oSettings, <span class="hljs-string">'aoDrawCallback'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
					<span class="hljs-keyword">if</span> ( oSettings.bSorted ) {
						<span class="hljs-keyword">var</span> aSort = _fnSortFlatten( oSettings );
						<span class="hljs-keyword">var</span> sortedColumns = {};
			
						$.each( aSort, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(i, val)</span> {</span>
							sortedColumns[ val.src ] = val.dir;
						} );
			
						_fnCallbackFire( oSettings, <span class="hljs-literal">null</span>, <span class="hljs-string">'order'</span>, [oSettings, aSort, sortedColumns] );
						_fnSortAria( oSettings );
					}
				} );
			}
			
			_fnCallbackReg( oSettings, <span class="hljs-string">'aoDrawCallback'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
				<span class="hljs-keyword">if</span> ( oSettings.bSorted || _fnDataSource( oSettings ) === <span class="hljs-string">'ssp'</span> || features.bDeferRender ) {
					_fnSortingClasses( oSettings );
				}
			}, <span class="hljs-string">'sc'</span> );
			
			</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Final init
Cache the header, body and footer as required, creating them if needed</p></div></div><div class="code"><div class="wrapper">			</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Browser support detection </p></div></div><div class="code"><div class="wrapper">			_fnBrowserDetect( oSettings );
			</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Work around for Webkit bug 83867 - store the caption-side before removing from doc</p></div></div><div class="code"><div class="wrapper">			<span class="hljs-keyword">var</span> captions = $(<span class="hljs-keyword">this</span>).children(<span class="hljs-string">'caption'</span>).each( <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
				<span class="hljs-keyword">this</span>._captionSide = $(<span class="hljs-keyword">this</span>).css(<span class="hljs-string">'caption-side'</span>);
			} );
			
			<span class="hljs-keyword">var</span> thead = $(<span class="hljs-keyword">this</span>).children(<span class="hljs-string">'thead'</span>);
			<span class="hljs-keyword">if</span> ( thead.length === <span class="hljs-number">0</span> )
			{
				thead = $(<span class="hljs-string">'&lt;thead/&gt;'</span>).appendTo(<span class="hljs-keyword">this</span>);
			}
			oSettings.nTHead = thead[<span class="hljs-number">0</span>];
			
			<span class="hljs-keyword">var</span> tbody = $(<span class="hljs-keyword">this</span>).children(<span class="hljs-string">'tbody'</span>);
			<span class="hljs-keyword">if</span> ( tbody.length === <span class="hljs-number">0</span> )
			{
				tbody = $(<span class="hljs-string">'&lt;tbody/&gt;'</span>).appendTo(<span class="hljs-keyword">this</span>);
			}
			oSettings.nTBody = tbody[<span class="hljs-number">0</span>];
			
			<span class="hljs-keyword">var</span> tfoot = $(<span class="hljs-keyword">this</span>).children(<span class="hljs-string">'tfoot'</span>);
			<span class="hljs-keyword">if</span> ( tfoot.length === <span class="hljs-number">0</span> &amp;&amp; captions.length &gt; <span class="hljs-number">0</span> &amp;&amp; (oSettings.oScroll.sX !== <span class="hljs-string">""</span> || oSettings.oScroll.sY !== <span class="hljs-string">""</span>) )
			{</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>If we are a scrolling table, and no footer has been given, then we need to create
a tfoot element for the caption element to be appended to</p></div></div><div class="code"><div class="wrapper">				tfoot = $(<span class="hljs-string">'&lt;tfoot/&gt;'</span>).appendTo(<span class="hljs-keyword">this</span>);
			}
			
			<span class="hljs-keyword">if</span> ( tfoot.length === <span class="hljs-number">0</span> || tfoot.children().length === <span class="hljs-number">0</span> ) {
				$(<span class="hljs-keyword">this</span>).addClass( oClasses.sNoFooter );
			}
			<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( tfoot.length &gt; <span class="hljs-number">0</span> ) {
				oSettings.nTFoot = tfoot[<span class="hljs-number">0</span>];
				_fnDetectHeader( oSettings.aoFooter, oSettings.nTFoot );
			}
			</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Check if there is data passing into the constructor </p></div></div><div class="code"><div class="wrapper">			<span class="hljs-keyword">if</span> ( oInit.aaData )
			{
				<span class="hljs-keyword">for</span> ( i=<span class="hljs-number">0</span> ; i&lt;oInit.aaData.length ; i++ )
				{
					_fnAddData( oSettings, oInit.aaData[ i ] );
				}
			}
			<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( oSettings.bDeferLoading || _fnDataSource( oSettings ) == <span class="hljs-string">'dom'</span> )
			{</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Grab the data from the page - only do this when deferred loading or no Ajax
source since there is no point in reading the DOM data if we are then going
to replace it with Ajax data</p></div></div><div class="code"><div class="wrapper">				_fnAddTr( oSettings, $(oSettings.nTBody).children(<span class="hljs-string">'tr'</span>) );
			}
			</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Copy the data index array </p></div></div><div class="code"><div class="wrapper">			oSettings.aiDisplay = oSettings.aiDisplayMaster.slice();
			</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Initialisation complete - table can be drawn </p></div></div><div class="code"><div class="wrapper">			oSettings.bInitialised = <span class="hljs-literal">true</span>;
			</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Check if we need to initialise the table (it might not have been handed off to the
language processor)</p></div></div><div class="code"><div class="wrapper">			<span class="hljs-keyword">if</span> ( bInitHandedOff === <span class="hljs-literal">false</span> )
			{
				_fnInitialise( oSettings );
			}
		} );
		_that = <span class="hljs-literal">null</span>;
		<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
	};

	
	</div></div></div><div class="segment"><div class="comments doc-section"><div class="wrapper"><p><span class='doc-section-header'> ignore and of type <em>Array</em></span></p>
<p>Computed structure of the DataTables API, defined by the options passed to
<code>DataTable.Api.register()</code> when building the API.</p>
<p>The structure is built in order to speed creation and extension of the Api
objects since the extensions are effectively pre-parsed.</p>
<p>The array is an array of objects with the following structure, where this
base array represents the Api prototype base:</p>
<pre><code>[
  {
    name:      &#39;data&#39;                -- string   - Property name
    val:       function () {},       -- function - Api method (or undefined if just an object
    methodExt: [ ... ],              -- array    - Array of Api object definitions to extend the method result
    propExt:   [ ... ]               -- array    - Array of Api object definitions to extend the property
  },
  {
    name:     &#39;row&#39;
    val:       {},
    methodExt: [ ... ],
    propExt:   [
      {
        name:      &#39;data&#39;
        val:       function () {},
        methodExt: [ ... ],
        propExt:   [ ... ]
      },
      ...
    ]
  }
]</code></pre></div></div><div class="code"><div class="wrapper">	<span class="hljs-keyword">var</span> __apiStruct = [];
	
	</div></div></div><div class="segment"><div class="comments doc-section"><div class="wrapper"><p><span class='doc-section-header'> ignore and of type <em>object</em></span></p>
<p><code>Array.prototype</code> reference.</p></div></div><div class="code"><div class="wrapper">	<span class="hljs-keyword">var</span> __arrayProto = <span class="hljs-built_in">Array</span>.prototype;
	
	</div></div></div><div class="segment"><div class="comments doc-section"><div class="wrapper"><p><span class='doc-section-header'> ignore</span></p>
<p>Abstraction for <code>context</code> parameter of the <code>Api</code> constructor to allow it to
take several different forms for ease of use.</p>
<p>Each of the input parameter types will be converted to a DataTables settings
object where possible.</p>
<p>Parameters:</p>
<ul>
<li><strong>mixed can be a string, a node, a jQuery, or an object.</strong><br/>(DataTable identifier. Can be one of: <em> <code>string</code> - jQuery selector. Any DataTables&#39; matching the given selector with be found and used. </em> <code>node</code> - <code>TABLE</code> node which has already been formed into a DataTable. <em> <code>jQuery</code> - A jQuery object of <code>TABLE</code> nodes. </em> <code>object</code> - DataTables settings object * <code>DataTables.Api</code> - API instance)</li>
</ul>
<p><strong>Returns an array or a null</strong><br/>(Matching DataTables settings objects. <code>null</code> or <code>undefined</code> is returned if no matching DataTable is found.)</p></div></div><div class="code"><div class="wrapper">	<span class="hljs-keyword">var</span> _toSettings = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">( mixed )</span>
	{</span>
		<span class="hljs-keyword">var</span> idx, jq;
		<span class="hljs-keyword">var</span> settings = DataTable.settings;
		<span class="hljs-keyword">var</span> tables = $.map( settings, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(el, i)</span> {</span>
			<span class="hljs-keyword">return</span> el.nTable;
		} );
	
		<span class="hljs-keyword">if</span> ( ! mixed ) {
			<span class="hljs-keyword">return</span> [];
		}
		<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( mixed.nTable &amp;&amp; mixed.oApi ) {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>DataTables settings object</p></div></div><div class="code"><div class="wrapper">			<span class="hljs-keyword">return</span> [ mixed ];
		}
		<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( mixed.nodeName &amp;&amp; mixed.nodeName.toLowerCase() === <span class="hljs-string">'table'</span> ) {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Table node</p></div></div><div class="code"><div class="wrapper">			idx = $.inArray( mixed, tables );
			<span class="hljs-keyword">return</span> idx !== -<span class="hljs-number">1</span> ? [ settings[idx] ] : <span class="hljs-literal">null</span>;
		}
		<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( mixed &amp;&amp; <span class="hljs-keyword">typeof</span> mixed.settings === <span class="hljs-string">'function'</span> ) {
			<span class="hljs-keyword">return</span> mixed.settings().toArray();
		}
		<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( <span class="hljs-keyword">typeof</span> mixed === <span class="hljs-string">'string'</span> ) {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>jQuery selector</p></div></div><div class="code"><div class="wrapper">			jq = $(mixed);
		}
		<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( mixed <span class="hljs-keyword">instanceof</span> $ ) {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>jQuery object (also DataTables instance)</p></div></div><div class="code"><div class="wrapper">			jq = mixed;
		}
	
		<span class="hljs-keyword">if</span> ( jq ) {
			<span class="hljs-keyword">return</span> jq.map( <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(i)</span> {</span>
				idx = $.inArray( <span class="hljs-keyword">this</span>, tables );
				<span class="hljs-keyword">return</span> idx !== -<span class="hljs-number">1</span> ? settings[idx] : <span class="hljs-literal">null</span>;
			} ).toArray();
		}
	};
	
	</div></div></div><div class="segment"><div class="comments doc-section"><div class="wrapper"><p><span class='doc-section-header'> class DataTable.Api</span></p>
<p>DataTables API class - used to control and interface with  one or more
DataTables enhanced tables.</p>
<p>The API class is heavily based on jQuery, presenting a chainable interface
that you can use to interact with tables. Each instance of the API class has
a &quot;context&quot; - i.e. the tables that it will operate on. This could be a single
table, all tables on a page or a sub-set thereof.</p>
<p>Additionally the API is designed to allow you to easily work with the data in
the tables, retrieving and manipulating it as required. This is done by
presenting the API class as an array like interface. The contents of the
array depend upon the actions requested by each method (for example
<code>rows().nodes()</code> will return an array of nodes, while <code>rows().data()</code> will
return an array of objects or arrays depending upon your table&#39;s
configuration). The API object has a number of array like methods (<code>push</code>,
<code>pop</code>, <code>reverse</code> etc) as well as additional helper methods (<code>each</code>, <code>pluck</code>,
<code>unique</code> etc) to assist your working with the data held in a table.</p>
<p>Most methods (those which return an Api instance) are chainable, which means
the return from a method call also has all of the methods available that the
top level object had. For example, these two calls are equivalent:</p>
<pre><code>// Not chained
api.row.add( {...} );
api.draw();

// Chained
api.row.add( {...} ).draw();</code></pre>
<p>Parameters:</p>
<ul>
<li><p><strong>context can be an array, an object, a string, or a jQuery.</strong><br/>(DataTable identifier. This is used to define which DataTables enhanced tables this API will operate on. Can be one of: <em> <code>string</code> - jQuery selector. Any DataTables&#39; matching the given selector with be found and used. </em> <code>node</code> - <code>TABLE</code> node which has already been formed into a DataTable. <em> <code>jQuery</code> - A jQuery object of <code>TABLE</code> nodes. </em> <code>object</code> - DataTables settings object)</p>
</li>
<li><p><strong>data is optional and must be an array.</strong><br/>(Data to initialise the Api instance with.)</p>
</li>
</ul>
<p>Example:</p>
<pre><code>// Direct initialisation during DataTables construction
var api = $(&#39;#example&#39;).DataTable();</code></pre>
<p>Example:</p>
<pre><code>// Initialisation using a DataTables jQuery object
var api = $(&#39;#example&#39;).dataTable().api();</code></pre>
<p>Example:</p>
<pre><code>// Initialisation as a constructor
var api = new $.fn.DataTable.Api( &#39;table.dataTable&#39; );</code></pre></div></div><div class="code"><div class="wrapper">	_Api = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">( context, data )</span>
	{</span>
		<span class="hljs-keyword">if</span> ( ! <span class="hljs-keyword">this</span> <span class="hljs-keyword">instanceof</span> _Api ) {
			<span class="hljs-keyword">throw</span> <span class="hljs-string">'DT API must be constructed as a new object'</span>;</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>or should it do the &#39;new&#39; for the caller?
return new _Api.apply( this, arguments );</p></div></div><div class="code"><div class="wrapper">		}
	
		<span class="hljs-keyword">var</span> settings = [];
		<span class="hljs-keyword">var</span> ctxSettings = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">( o )</span> {</span>
			<span class="hljs-keyword">var</span> a = _toSettings( o );
			<span class="hljs-keyword">if</span> ( a ) {
				settings.push.apply( settings, a );
			}
		};
	
		<span class="hljs-keyword">if</span> ( $.isArray( context ) ) {
			<span class="hljs-keyword">for</span> ( <span class="hljs-keyword">var</span> i=<span class="hljs-number">0</span>, ien=context.length ; i&lt;ien ; i++ ) {
				ctxSettings( context[i] );
			}
		}
		<span class="hljs-keyword">else</span> {
			ctxSettings( context );
		}
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Remove duplicates</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-keyword">this</span>.context = _unique( settings );
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Initial data</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-keyword">if</span> ( data ) {
			<span class="hljs-keyword">this</span>.push.apply( <span class="hljs-keyword">this</span>, data.toArray ? data.toArray() : data );
		}
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>selector</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-keyword">this</span>.selector = {
			rows: <span class="hljs-literal">null</span>,
			cols: <span class="hljs-literal">null</span>,
			opts: <span class="hljs-literal">null</span>
		};
	
		_Api.extend( <span class="hljs-keyword">this</span>, <span class="hljs-keyword">this</span>, __apiStruct );
	};
	
	DataTable.Api = _Api;
	
	_Api.prototype = <span class="hljs-comment">/** @lends DataTables.Api */</span>{</div></div></div><div class="segment"><div class="comments doc-section"><div class="wrapper"><p><span class='doc-section-header'> of type <em>method</em></span></p>
<p>Return a new Api instance, comprised of the data held in the current
instance, join with the other array(s) and/or value(s).</p>
<p>An alias for <code>Array.prototype.concat</code>.</p>
<p>Parameters:</p>
<ul>
<li><p><strong>value1 must be a *.</strong><br/>(Arrays and/or values to concatenate.)</p>
<ul>
<li><strong>... is optional and must be a *.</strong><br/>(Additional arrays and/or values to concatenate.)</li>
</ul>
</li>
</ul>
<p><strong>Returns a DataTables.Api</strong><br/>(New API instance, comprising of the combined array.)</p></div></div><div class="code"><div class="wrapper">		concat:  __arrayProto.concat,
	
	
		context: [], <span class="hljs-comment">// array of table settings objects</span>
	
	
		each: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">( fn )</span>
		{</span>
			<span class="hljs-keyword">for</span> ( <span class="hljs-keyword">var</span> i=<span class="hljs-number">0</span>, ien=<span class="hljs-keyword">this</span>.length ; i&lt;ien; i++ ) {
				fn.call( <span class="hljs-keyword">this</span>, <span class="hljs-keyword">this</span>[i], i, <span class="hljs-keyword">this</span> );
			}
	
			<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
		},
	
	
		eq: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">( idx )</span>
		{</span>
			<span class="hljs-keyword">var</span> ctx = <span class="hljs-keyword">this</span>.context;
	
			<span class="hljs-keyword">return</span> ctx.length &gt; idx ?
				<span class="hljs-keyword">new</span> _Api( ctx[idx], <span class="hljs-keyword">this</span>[idx] ) :
				<span class="hljs-literal">null</span>;
		},
	
	
		filter: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">( fn )</span>
		{</span>
			<span class="hljs-keyword">var</span> a = [];
	
			<span class="hljs-keyword">if</span> ( __arrayProto.filter ) {
				a = __arrayProto.filter.call( <span class="hljs-keyword">this</span>, fn, <span class="hljs-keyword">this</span> );
			}
			<span class="hljs-keyword">else</span> {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Compatibility for browsers without EMCA-252-5 (JS 1.6)</p></div></div><div class="code"><div class="wrapper">				<span class="hljs-keyword">for</span> ( <span class="hljs-keyword">var</span> i=<span class="hljs-number">0</span>, ien=<span class="hljs-keyword">this</span>.length ; i&lt;ien ; i++ ) {
					<span class="hljs-keyword">if</span> ( fn.call( <span class="hljs-keyword">this</span>, <span class="hljs-keyword">this</span>[i], i, <span class="hljs-keyword">this</span> ) ) {
						a.push( <span class="hljs-keyword">this</span>[i] );
					}
				}
			}
	
			<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> _Api( <span class="hljs-keyword">this</span>.context, a );
		},
	
	
		flatten: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span>
		{</span>
			<span class="hljs-keyword">var</span> a = [];
			<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> _Api( <span class="hljs-keyword">this</span>.context, a.concat.apply( a, <span class="hljs-keyword">this</span>.toArray() ) );
		},
	
	
		join:    __arrayProto.join,
	
	
		indexOf: __arrayProto.indexOf || <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(obj, start)</span>
		{</span>
			<span class="hljs-keyword">for</span> ( <span class="hljs-keyword">var</span> i=(start || <span class="hljs-number">0</span>), ien=<span class="hljs-keyword">this</span>.length ; i&lt;ien ; i++ ) {
				<span class="hljs-keyword">if</span> ( <span class="hljs-keyword">this</span>[i] === obj ) {
					<span class="hljs-keyword">return</span> i;
				}
			}
			<span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;
		},
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Internal only at the moment - relax?</p></div></div><div class="code"><div class="wrapper">		iterator: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">( flatten, type, fn )</span> {</span>
			<span class="hljs-keyword">var</span>
				a = [], ret,
				i, ien, j, jen,
				context = <span class="hljs-keyword">this</span>.context,
				rows, items, item,
				selector = <span class="hljs-keyword">this</span>.selector;
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Argument shifting</p></div></div><div class="code"><div class="wrapper">			<span class="hljs-keyword">if</span> ( <span class="hljs-keyword">typeof</span> flatten === <span class="hljs-string">'string'</span> ) {
				fn = type;
				type = flatten;
				flatten = <span class="hljs-literal">false</span>;
			}
	
			<span class="hljs-keyword">for</span> ( i=<span class="hljs-number">0</span>, ien=context.length ; i&lt;ien ; i++ ) {
				<span class="hljs-keyword">if</span> ( type === <span class="hljs-string">'table'</span> ) {
					ret = fn( context[i], i );
	
					<span class="hljs-keyword">if</span> ( ret !== <span class="hljs-literal">undefined</span> ) {
						a.push( ret );
					}
				}
				<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( type === <span class="hljs-string">'columns'</span> || type === <span class="hljs-string">'rows'</span> ) {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>this has same length as context - one entry for each table</p></div></div><div class="code"><div class="wrapper">					ret = fn( context[i], <span class="hljs-keyword">this</span>[i], i );
	
					<span class="hljs-keyword">if</span> ( ret !== <span class="hljs-literal">undefined</span> ) {
						a.push( ret );
					}
				}
				<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( type === <span class="hljs-string">'column'</span> || type === <span class="hljs-string">'column-rows'</span> || type === <span class="hljs-string">'row'</span> || type === <span class="hljs-string">'cell'</span> ) {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>columns and rows share the same structure.
&#39;this&#39; is an array of column indexes for each context</p></div></div><div class="code"><div class="wrapper">					items = <span class="hljs-keyword">this</span>[i];
	
					<span class="hljs-keyword">if</span> ( type === <span class="hljs-string">'column-rows'</span> ) {
						rows = _selector_row_indexes( context[i], selector.opts );
					}
	
					<span class="hljs-keyword">for</span> ( j=<span class="hljs-number">0</span>, jen=items.length ; j&lt;jen ; j++ ) {
						item = items[j];
	
						<span class="hljs-keyword">if</span> ( type === <span class="hljs-string">'cell'</span> ) {
							ret = fn( context[i], item.row, item.column, i, j );
						}
						<span class="hljs-keyword">else</span> {
							ret = fn( context[i], item, i, j, rows );
						}
	
						<span class="hljs-keyword">if</span> ( ret !== <span class="hljs-literal">undefined</span> ) {
							a.push( ret );
						}
					}
				}
			}
	
			<span class="hljs-keyword">if</span> ( a.length ) {
				<span class="hljs-keyword">var</span> api = <span class="hljs-keyword">new</span> _Api( context, flatten ? a.concat.apply( [], a ) : a );
				<span class="hljs-keyword">var</span> apiSelector = api.selector;
				apiSelector.rows = selector.rows;
				apiSelector.cols = selector.cols;
				apiSelector.opts = selector.opts;
				<span class="hljs-keyword">return</span> api;
			}
			<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
		},
	
	
		lastIndexOf: __arrayProto.lastIndexOf || <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(obj, start)</span>
		{</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Bit cheeky...</p></div></div><div class="code"><div class="wrapper">			<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.indexOf.apply( <span class="hljs-keyword">this</span>.toArray.reverse(), <span class="hljs-built_in">arguments</span> );
		},
	
	
		length:  <span class="hljs-number">0</span>,
	
	
		map: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">( fn )</span>
		{</span>
			<span class="hljs-keyword">var</span> a = [];
	
			<span class="hljs-keyword">if</span> ( __arrayProto.map ) {
				a = __arrayProto.map.call( <span class="hljs-keyword">this</span>, fn, <span class="hljs-keyword">this</span> );
			}
			<span class="hljs-keyword">else</span> {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Compatibility for browsers without EMCA-252-5 (JS 1.6)</p></div></div><div class="code"><div class="wrapper">				<span class="hljs-keyword">for</span> ( <span class="hljs-keyword">var</span> i=<span class="hljs-number">0</span>, ien=<span class="hljs-keyword">this</span>.length ; i&lt;ien ; i++ ) {
					a.push( fn.call( <span class="hljs-keyword">this</span>, <span class="hljs-keyword">this</span>[i], i ) );
				}
			}
	
			<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> _Api( <span class="hljs-keyword">this</span>.context, a );
		},
	
	
		pluck: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">( prop )</span>
		{</span>
			<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.map( <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">( el )</span> {</span>
				<span class="hljs-keyword">return</span> el[ prop ];
			} );
		},
	
		pop:     __arrayProto.pop,
	
	
		push:    __arrayProto.push,
	
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Does not return an API instance</p></div></div><div class="code"><div class="wrapper">		reduce: __arrayProto.reduce || <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">( fn, init )</span>
		{</span>
			<span class="hljs-keyword">return</span> _fnReduce( <span class="hljs-keyword">this</span>, fn, init, <span class="hljs-number">0</span>, <span class="hljs-keyword">this</span>.length, <span class="hljs-number">1</span> );
		},
	
	
		reduceRight: __arrayProto.reduceRight || <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">( fn, init )</span>
		{</span>
			<span class="hljs-keyword">return</span> _fnReduce( <span class="hljs-keyword">this</span>, fn, init, <span class="hljs-keyword">this</span>.length-<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span> );
		},
	
	
		reverse: __arrayProto.reverse,
	
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Object with rows, columns and opts</p></div></div><div class="code"><div class="wrapper">		selector: <span class="hljs-literal">null</span>,
	
	
		shift:   __arrayProto.shift,
	
	
		sort:    __arrayProto.sort, <span class="hljs-comment">// ? name - order?</span>
	
	
		splice:  __arrayProto.splice,
	
	
		toArray: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span>
		{</span>
			<span class="hljs-keyword">return</span> __arrayProto.slice.call( <span class="hljs-keyword">this</span> );
		},
	
	
		to$: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span>
		{</span>
			<span class="hljs-keyword">return</span> $( <span class="hljs-keyword">this</span> );
		},
	
	
		toJQuery: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span>
		{</span>
			<span class="hljs-keyword">return</span> $( <span class="hljs-keyword">this</span> );
		},
	
	
		unique: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span>
		{</span>
			<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> _Api( <span class="hljs-keyword">this</span>.context, _unique(<span class="hljs-keyword">this</span>) );
		},
	
	
		unshift: __arrayProto.unshift
	};
	
	
	_Api.extend = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">( scope, obj, ext )</span>
	{</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Only extend API instances and static properties of the API</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-keyword">if</span> ( ! obj || ( ! (obj <span class="hljs-keyword">instanceof</span> _Api) &amp;&amp; ! obj.__dt_wrapper ) ) {
			<span class="hljs-keyword">return</span>;
		}
	
		<span class="hljs-keyword">var</span>
			i, ien,
			j, jen,
			struct, inner,
			methodScoping = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">( scope, fn, struc )</span> {</span>
				<span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
					<span class="hljs-keyword">var</span> ret = fn.apply( scope, <span class="hljs-built_in">arguments</span> );
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Method extension</p></div></div><div class="code"><div class="wrapper">					_Api.extend( ret, ret, struc.methodExt );
					<span class="hljs-keyword">return</span> ret;
				};
			};
	
		<span class="hljs-keyword">for</span> ( i=<span class="hljs-number">0</span>, ien=ext.length ; i&lt;ien ; i++ ) {
			struct = ext[i];
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Value</p></div></div><div class="code"><div class="wrapper">			obj[ struct.name ] = <span class="hljs-keyword">typeof</span> struct.val === <span class="hljs-string">'function'</span> ?
				methodScoping( scope, struct.val, struct ) :
				$.isPlainObject( struct.val ) ?
					{} :
					struct.val;
	
			obj[ struct.name ].__dt_wrapper = <span class="hljs-literal">true</span>;
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Property extension</p></div></div><div class="code"><div class="wrapper">			_Api.extend( scope, obj[ struct.name ], struct.propExt );
		}
	};
	
	</div></div></div><div class="segment"><div class="comments doc-section"><div class="wrapper"><p>TODO: - Is there need for an augment function?
_Api.augment = function ( inst, name )
{
    // Find src object in the structure from the name
    var parts = name.split(&#39;.&#39;);</p></div></div><div class="code"><div class="wrapper">	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><pre><code>_Api.extend( inst, obj );</code></pre></div></div><div class="code"><div class="wrapper">	<span class="hljs-comment">// ;</span>
	
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><pre><code>[
  {
    name:      &#39;data&#39;                -- string   - Property name
    val:       function () {},       -- function - Api method (or undefined if just an object
    methodExt: [ ... ],              -- array    - Array of Api object definitions to extend the method result
    propExt:   [ ... ]               -- array    - Array of Api object definitions to extend the property
  },
  {
    name:     &#39;row&#39;
    val:       {},
    methodExt: [ ... ],
    propExt:   [
      {
        name:      &#39;data&#39;
        val:       function () {},
        methodExt: [ ... ],
        propExt:   [ ... ]
      },
      ...
    ]
  }
]</code></pre></div></div><div class="code"><div class="wrapper">	
	_Api.register = _api_register = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">( name, val )</span>
	{</span>
		<span class="hljs-keyword">if</span> ( $.isArray( name ) ) {
			<span class="hljs-keyword">for</span> ( <span class="hljs-keyword">var</span> j=<span class="hljs-number">0</span>, jen=name.length ; j&lt;jen ; j++ ) {
				_Api.register( name[j], val );
			}
			<span class="hljs-keyword">return</span>;
		}
	
		<span class="hljs-keyword">var</span>
			i, ien,
			heir = name.split(<span class="hljs-string">'.'</span>),
			struct = __apiStruct,
			key, method;
	
		<span class="hljs-keyword">var</span> find = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">( src, name )</span> {</span>
			<span class="hljs-keyword">for</span> ( <span class="hljs-keyword">var</span> i=<span class="hljs-number">0</span>, ien=src.length ; i&lt;ien ; i++ ) {
				<span class="hljs-keyword">if</span> ( src[i].name === name ) {
					<span class="hljs-keyword">return</span> src[i];
				}
			}
			<span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
		};
	
		<span class="hljs-keyword">for</span> ( i=<span class="hljs-number">0</span>, ien=heir.length ; i&lt;ien ; i++ ) {
			method = heir[i].indexOf(<span class="hljs-string">'()'</span>) !== -<span class="hljs-number">1</span>;
			key = method ?
				heir[i].replace(<span class="hljs-string">'()'</span>, <span class="hljs-string">''</span>) :
				heir[i];
	
			<span class="hljs-keyword">var</span> src = find( struct, key );
			<span class="hljs-keyword">if</span> ( ! src ) {
				src = {
					name:      key,
					val:       {},
					methodExt: [],
					propExt:   []
				};
				struct.push( src );
			}
	
			<span class="hljs-keyword">if</span> ( i === ien-<span class="hljs-number">1</span> ) {
				src.val = val;
			}
			<span class="hljs-keyword">else</span> {
				struct = method ?
					src.methodExt :
					src.propExt;
			}
		}
	};
	
	
	_Api.registerPlural = _api_registerPlural = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">( pluralName, singularName, val )</span> {</span>
		_Api.register( pluralName, val );
	
		_Api.register( singularName, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
			<span class="hljs-keyword">var</span> ret = val.apply( <span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span> );
	
			<span class="hljs-keyword">if</span> ( ret === <span class="hljs-keyword">this</span> ) {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Returned item is the API instance that was passed in, return it</p></div></div><div class="code"><div class="wrapper">				<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
			}
			<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( ret <span class="hljs-keyword">instanceof</span> _Api ) {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>New API instance returned, want the value from the first item
in the returned array for the singular result.</p></div></div><div class="code"><div class="wrapper">				<span class="hljs-keyword">return</span> ret.length ?
					$.isArray( ret[<span class="hljs-number">0</span>] ) ?
						<span class="hljs-keyword">new</span> _Api( ret.context, ret[<span class="hljs-number">0</span>] ) : <span class="hljs-comment">// Array results are 'enhanced'</span>
						ret[<span class="hljs-number">0</span>] :
					<span class="hljs-literal">undefined</span>;
			}
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Non-API return - just fire it back</p></div></div><div class="code"><div class="wrapper">			<span class="hljs-keyword">return</span> ret;
		} );
	};
	
	</div></div></div><div class="segment"><div class="comments doc-section"><div class="wrapper"><p><span class='doc-section-header'> ignore</span></p>
<p>Selector for HTML tables. Apply the given selector to the give array of
DataTables settings objects.</p>
<p>Parameters:</p>
<ul>
<li><p><strong>selector is optional and can be a string or an integer.</strong><br/>(jQuery selector string or integer)</p>
</li>
<li><p><strong>Array must be an array.</strong><br/>(of DataTables settings objects to be filtered)</p>
</li>
</ul>
<p><strong>Returns an array</strong></p></div></div><div class="code"><div class="wrapper">	<span class="hljs-keyword">var</span> __table_selector = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">( selector, a )</span>
	{</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Integer is used to pick out a table by index</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-keyword">if</span> ( <span class="hljs-keyword">typeof</span> selector === <span class="hljs-string">'number'</span> ) {
			<span class="hljs-keyword">return</span> [ a[ selector ] ];
		}
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Perform a jQuery selector on the table nodes</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-keyword">var</span> nodes = $.map( a, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(el, i)</span> {</span>
			<span class="hljs-keyword">return</span> el.nTable;
		} );
	
		<span class="hljs-keyword">return</span> $(nodes)
			.filter( selector )
			.map( <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(i)</span> {</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Need to translate back from the table node to the settings</p></div></div><div class="code"><div class="wrapper">				<span class="hljs-keyword">var</span> idx = $.inArray( <span class="hljs-keyword">this</span>, nodes );
				<span class="hljs-keyword">return</span> a[ idx ];
			} )
			.toArray();
	};
	
	
	</div></div></div><div class="segment"><div class="comments doc-section"><div class="wrapper"><p><span class='doc-section-header'> name DataTable.Api#tables</span></p>
<p>Context selector for the API&#39;s context (i.e. the tables the API instance
refers to.</p>
<p>Parameters:</p>
<ul>
<li><strong>selector is optional and can be a string or an integer.</strong><br/>(Selector to pick which tables the iterator should operate on. If not given, all tables in the current context are used. This can be given as a jQuery selector (for example <code>&#39;:gt(0)&#39;</code>) to select multiple tables or as an integer to select a single table.)</li>
</ul>
<p><strong>Returns a DataTable.Api</strong><br/>(Returns a new API instance if a selector is given.)</p></div></div><div class="code"><div class="wrapper">	_api_register( <span class="hljs-string">'tables()'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">( selector )</span> {</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>A new instance is created if there was a selector specified</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-keyword">return</span> selector ?
			<span class="hljs-keyword">new</span> _Api( __table_selector( selector, <span class="hljs-keyword">this</span>.context ) ) :
			<span class="hljs-keyword">this</span>;
	} );
	
	
	_api_register( <span class="hljs-string">'table()'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">( selector )</span> {</span>
		<span class="hljs-keyword">var</span> tables = <span class="hljs-keyword">this</span>.tables( selector );
		<span class="hljs-keyword">var</span> ctx = tables.context;
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Truncate to the first matched table</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-keyword">return</span> ctx.length ?
			<span class="hljs-keyword">new</span> _Api( ctx[<span class="hljs-number">0</span>] ) :
			tables;
	} );
	
	
	_api_registerPlural( <span class="hljs-string">'tables().nodes()'</span>, <span class="hljs-string">'table().node()'</span> , <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
		<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.iterator( <span class="hljs-string">'table'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">( ctx )</span> {</span>
			<span class="hljs-keyword">return</span> ctx.nTable;
		} );
	} );
	
	
	_api_registerPlural( <span class="hljs-string">'tables().body()'</span>, <span class="hljs-string">'table().body()'</span> , <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
		<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.iterator( <span class="hljs-string">'table'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">( ctx )</span> {</span>
			<span class="hljs-keyword">return</span> ctx.nTBody;
		} );
	} );
	
	
	_api_registerPlural( <span class="hljs-string">'tables().header()'</span>, <span class="hljs-string">'table().header()'</span> , <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
		<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.iterator( <span class="hljs-string">'table'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">( ctx )</span> {</span>
			<span class="hljs-keyword">return</span> ctx.nTHead;
		} );
	} );
	
	
	_api_registerPlural( <span class="hljs-string">'tables().footer()'</span>, <span class="hljs-string">'table().footer()'</span> , <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
		<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.iterator( <span class="hljs-string">'table'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">( ctx )</span> {</span>
			<span class="hljs-keyword">return</span> ctx.nTFoot;
		} );
	} );
	
	
	_api_registerPlural( <span class="hljs-string">'tables().containers()'</span>, <span class="hljs-string">'table().container()'</span> , <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
		<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.iterator( <span class="hljs-string">'table'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">( ctx )</span> {</span>
			<span class="hljs-keyword">return</span> ctx.nTableWrapper;
		} );
	} );
	
	
	</div></div></div><div class="segment"><div class="comments doc-section"><div class="wrapper"><p>Redraw the tables in the current context.</p>
<p>Parameters:</p>
<ul>
<li><strong>reset is optional, must be a boolean, and has a default value of true.</strong><br/>(Reset (default) or hold the current paging position. A full re-sort and re-filter is performed when this method is called, which is why the pagination reset is the default action.)</li>
</ul>
<p><strong>Returns a DataTables.Api</strong><br/>(this)</p></div></div><div class="code"><div class="wrapper">	_api_register( <span class="hljs-string">'draw()'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">( resetPaging )</span> {</span>
		<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.iterator( <span class="hljs-string">'table'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">( settings )</span> {</span>
			_fnReDraw( settings, resetPaging===<span class="hljs-literal">false</span> );
		} );
	} );
	
	
	</div></div></div><div class="segment"><div class="comments doc-section"><div class="wrapper"><p>Get the current page index.</p>
<p><strong>Returns an integer</strong><br/>(Current page index (zero based))</p></div></div><div class="code"><div class="wrapper"><span class="hljs-comment">/**
	 * Set the current page.
	 *
	 * Note that if you attempt to show a page which does not exist, DataTables will
	 * not throw an error, but rather reset the paging.
	 *
	 * @param {integer|string} action The paging action to take. This can be one of:
	 *  * `integer` - The page index to jump to
	 *  * `string` - An action to take:
	 *    * `first` - Jump to first page.
	 *    * `next` - Jump to the next page
	 *    * `previous` - Jump to previous page
	 *    * `last` - Jump to the last page.
	 * @returns {DataTables.Api} this
	 */</span>
	_api_register( <span class="hljs-string">'page()'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">( action )</span> {</span>
		<span class="hljs-keyword">if</span> ( action === <span class="hljs-literal">undefined</span> ) {
			<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.page.info().page; <span class="hljs-comment">// not an expensive call</span>
		}
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>else, have an action to take on all tables</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.iterator( <span class="hljs-string">'table'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">( settings )</span> {</span>
			_fnPageChange( settings, action );
		} );
	} );
	
	</div></div></div><div class="segment"><div class="comments doc-section"><div class="wrapper"><p>Paging information for the first table in the current context.</p>
<p>If you require paging information for another table, use the <code>table()</code> method
with a suitable selector.</p>
<p><strong>Returns an object</strong><br/>(Object with the following properties set: <em> <code>page</code> - Current page index (zero based - i.e. the first page is <code>0</code>) </em> <code>pages</code> - Total number of pages <em> <code>start</code> - Display index for the first record shown on the current page </em> <code>end</code> - Display index for the last record shown on the current page <em> <code>length</code> - Display length (number of records). Note that generally <code>start + length = end</code>, but this is not always true, for example if there are only 2 records to show on the final page, with a length of 10. </em> <code>recordsTotal</code> - Full data set length * <code>recordsDisplay</code> - Data set length once the current filtering criterion are applied.)</p></div></div><div class="code"><div class="wrapper">	_api_register( <span class="hljs-string">'page.info()'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">( action )</span> {</span>
		<span class="hljs-keyword">if</span> ( <span class="hljs-keyword">this</span>.context.length === <span class="hljs-number">0</span> ) {
			<span class="hljs-keyword">return</span> <span class="hljs-literal">undefined</span>;
		}
	
		<span class="hljs-keyword">var</span>
			settings   = <span class="hljs-keyword">this</span>.context[<span class="hljs-number">0</span>],
			start      = settings._iDisplayStart,
			len        = settings._iDisplayLength,
			visRecords = settings.fnRecordsDisplay(),
			all        = len === -<span class="hljs-number">1</span>;
	
		<span class="hljs-keyword">return</span> {
			<span class="hljs-string">"page"</span>:           all ? <span class="hljs-number">0</span> : <span class="hljs-built_in">Math</span>.floor( start / len ),
			<span class="hljs-string">"pages"</span>:          all ? <span class="hljs-number">1</span> : <span class="hljs-built_in">Math</span>.ceil( visRecords / len ),
			<span class="hljs-string">"start"</span>:          start,
			<span class="hljs-string">"end"</span>:            settings.fnDisplayEnd(),
			<span class="hljs-string">"length"</span>:         len,
			<span class="hljs-string">"recordsTotal"</span>:   settings.fnRecordsTotal(),
			<span class="hljs-string">"recordsDisplay"</span>: visRecords
		};
	} );
	
	</div></div></div><div class="segment"><div class="comments doc-section"><div class="wrapper"><p>Get the current page length.</p>
<p><strong>Returns an integer</strong><br/>(Current page length. Note <code>-1</code> indicates that all records are to be shown.)</p></div></div><div class="code"><div class="wrapper"><span class="hljs-comment">/**
	 * Set the current page length.
	 *
	 * @param {integer} Page length to set. Use `-1` to show all records.
	 * @returns {DataTables.Api} this
	 */</span>
	_api_register( <span class="hljs-string">'page.len()'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">( len )</span> {</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Note that we can&#39;t call this function &#39;length()&#39; because <code>length</code>
is a Javascript property of functions which defines how many arguments
the function expects.</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-keyword">if</span> ( len === <span class="hljs-literal">undefined</span> ) {
			<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.context.length !== <span class="hljs-number">0</span> ?
				<span class="hljs-keyword">this</span>.context[<span class="hljs-number">0</span>]._iDisplayLength :
				<span class="hljs-literal">undefined</span>;
		}
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>else, set the page length</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.iterator( <span class="hljs-string">'table'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">( settings )</span> {</span>
			_fnLengthChange( settings, len );
		} );
	} );
	
	
	
	<span class="hljs-keyword">var</span> __reload = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">( settings, holdPosition, callback )</span> {</span>
		<span class="hljs-keyword">if</span> ( _fnDataSource( settings ) == <span class="hljs-string">'ssp'</span> ) {
			_fnReDraw( settings, holdPosition );
		}
		<span class="hljs-keyword">else</span> {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Trigger xhr</p></div></div><div class="code"><div class="wrapper">			_fnProcessingDisplay( settings, <span class="hljs-literal">true</span> );
	
			_fnBuildAjax( settings, [], <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( json )</span> {</span>
				_fnClearTable( settings );
	
				<span class="hljs-keyword">var</span> data = _fnAjaxDataSrc( settings, json );
				<span class="hljs-keyword">for</span> ( <span class="hljs-keyword">var</span> i=<span class="hljs-number">0</span>, ien=data.length ; i&lt;ien ; i++ ) {
					_fnAddData( settings, data[i] );
				}
	
				_fnReDraw( settings, holdPosition );
				_fnProcessingDisplay( settings, <span class="hljs-literal">false</span> );
			} );
		}
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Use the draw event to trigger a callback, regardless of if it is an async
or sync draw</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-keyword">if</span> ( callback ) {
			<span class="hljs-keyword">var</span> api = <span class="hljs-keyword">new</span> _Api( settings );
	
			api.one( <span class="hljs-string">'draw'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
				callback( api.ajax.json() );
			} );
		}
	};
	
	</div></div></div><div class="segment"><div class="comments doc-section"><div class="wrapper"><p>Get the JSON response from the last Ajax request that DataTables made to the
server. Note that this returns the JSON from the first table in the current
context.</p>
<p><strong>Returns an object</strong><br/>(JSON received from the server.)</p></div></div><div class="code"><div class="wrapper">	_api_register( <span class="hljs-string">'ajax.json()'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
		<span class="hljs-keyword">var</span> ctx = <span class="hljs-keyword">this</span>.context;
	
		<span class="hljs-keyword">if</span> ( ctx.length &gt; <span class="hljs-number">0</span> ) {
			<span class="hljs-keyword">return</span> ctx[<span class="hljs-number">0</span>].json;
		}
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>else return undefined;</p></div></div><div class="code"><div class="wrapper">	} );
	
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Get the data submitted in the last Ajax request</p></div></div><div class="code"><div class="wrapper">	_api_register( <span class="hljs-string">'ajax.params()'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
		<span class="hljs-keyword">var</span> ctx = <span class="hljs-keyword">this</span>.context;
	
		<span class="hljs-keyword">if</span> ( ctx.length &gt; <span class="hljs-number">0</span> ) {
			<span class="hljs-keyword">return</span> ctx[<span class="hljs-number">0</span>].oAjaxData;
		}
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>else return undefined;</p></div></div><div class="code"><div class="wrapper">	} );
	
	</div></div></div><div class="segment"><div class="comments doc-section"><div class="wrapper"><p>Reload tables from the Ajax data source. Note that this function will
automatically re-draw the table when the remote data has been loaded.</p>
<p>Parameters:</p>
<ul>
<li><strong>reset is optional, must be a boolean, and has a default value of true.</strong><br/>(Reset (default) or hold the current paging position. A full re-sort and re-filter is performed when this method is called, which is why the pagination reset is the default action.)</li>
</ul>
<p><strong>Returns a DataTables.Api</strong><br/>(this)</p></div></div><div class="code"><div class="wrapper">	_api_register( <span class="hljs-string">'ajax.reload()'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">( callback, resetPaging )</span> {</span>
		<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.iterator( <span class="hljs-string">'table'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(settings)</span> {</span>
			__reload( settings, resetPaging===<span class="hljs-literal">false</span>, callback );
		} );
	} );
	
	</div></div></div><div class="segment"><div class="comments doc-section"><div class="wrapper"><p>Get the current Ajax URL. Note that this returns the URL from the first
table in the current context.</p>
<p><strong>Returns a string</strong><br/>(Current Ajax source URL)</p></div></div><div class="code"><div class="wrapper"><span class="hljs-comment">/**
	 * Set the Ajax URL. Note that this will set the URL for all tables in the
	 * current context.
	 *
	 * @param {string} url URL to set.
	 * @returns {DataTables.Api} this
	 */</span>
	_api_register( <span class="hljs-string">'ajax.url()'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">( url )</span> {</span>
		<span class="hljs-keyword">var</span> ctx = <span class="hljs-keyword">this</span>.context;
	
		<span class="hljs-keyword">if</span> ( url === <span class="hljs-literal">undefined</span> ) {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>get</p></div></div><div class="code"><div class="wrapper">			<span class="hljs-keyword">if</span> ( ctx.length === <span class="hljs-number">0</span> ) {
				<span class="hljs-keyword">return</span> <span class="hljs-literal">undefined</span>;
			}
			ctx = ctx[<span class="hljs-number">0</span>];
	
			<span class="hljs-keyword">return</span> ctx.ajax ?
				$.isPlainObject( ctx.ajax ) ?
					ctx.ajax.url :
					ctx.ajax :
				ctx.sAjaxSource;
		}
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>set</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.iterator( <span class="hljs-string">'table'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">( settings )</span> {</span>
			<span class="hljs-keyword">if</span> ( $.isPlainObject( settings.ajax ) ) {
				settings.ajax.url = url;
			}
			<span class="hljs-keyword">else</span> {
				settings.ajax = url;
			}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>No need to consider sAjaxSource here since DataTables gives priority
to <code>ajax</code> over <code>sAjaxSource</code>. So setting <code>ajax</code> here, renders any
value of <code>sAjaxSource</code> redundant.</p></div></div><div class="code"><div class="wrapper">		} );
	} );
	
	</div></div></div><div class="segment"><div class="comments doc-section"><div class="wrapper"><p>Load data from the newly set Ajax URL. Note that this method is only
available when <code>ajax.url()</code> is used to set a URL. Additionally, this method
has the same effect as calling <code>ajax.reload()</code> but is provided for
convenience when setting a new URL. Like <code>ajax.reload()</code> it will
automatically redraw the table once the remote data has been loaded.</p>
<p><strong>Returns a DataTables.Api</strong><br/>(this)</p></div></div><div class="code"><div class="wrapper">	_api_register( <span class="hljs-string">'ajax.url().load()'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">( callback, resetPaging )</span> {</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Same as a reload, but makes sense to present it for easy access after a
url change</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.iterator( <span class="hljs-string">'table'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">( ctx )</span> {</span>
			__reload( ctx, resetPaging===<span class="hljs-literal">false</span>, callback );
		} );
	} );
	
	
	
	
	<span class="hljs-keyword">var</span> _selector_run = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">( selector, select )</span>
	{</span>
		<span class="hljs-keyword">var</span>
			out = [], res,
			a, i, ien, j, jen;
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Can&#39;t just check for isArray here, as an API or jQuery instance might be
given with their array like look</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-keyword">if</span> ( ! selector || <span class="hljs-keyword">typeof</span> selector === <span class="hljs-string">'string'</span> || selector.length === <span class="hljs-literal">undefined</span> ) {
			selector = [ selector ];
		}
	
		<span class="hljs-keyword">for</span> ( i=<span class="hljs-number">0</span>, ien=selector.length ; i&lt;ien ; i++ ) {
			a = selector[i] &amp;&amp; selector[i].split ?
				selector[i].split(<span class="hljs-string">','</span>) :
				[ selector[i] ];
	
			<span class="hljs-keyword">for</span> ( j=<span class="hljs-number">0</span>, jen=a.length ; j&lt;jen ; j++ ) {
				res = select( <span class="hljs-keyword">typeof</span> a[j] === <span class="hljs-string">'string'</span> ? $.trim(a[j]) : a[j] );
	
				<span class="hljs-keyword">if</span> ( res &amp;&amp; res.length ) {
					out.push.apply( out, res );
				}
			}
		}
	
		<span class="hljs-keyword">return</span> out;
	};
	
	
	<span class="hljs-keyword">var</span> _selector_opts = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">( opts )</span>
	{</span>
		<span class="hljs-keyword">if</span> ( ! opts ) {
			opts = {};
		}
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Backwards compatibility for 1.9- which used the terminology filter rather
than search</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-keyword">if</span> ( opts.filter &amp;&amp; ! opts.search ) {
			opts.search = opts.filter;
		}
	
		<span class="hljs-keyword">return</span> {
			search: opts.search || <span class="hljs-string">'none'</span>,
			order:  opts.order  || <span class="hljs-string">'current'</span>,
			page:   opts.page   || <span class="hljs-string">'all'</span>
		};
	};
	
	
	<span class="hljs-keyword">var</span> _selector_first = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">( inst )</span>
	{</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Reduce the API instance to the first item found</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-keyword">for</span> ( <span class="hljs-keyword">var</span> i=<span class="hljs-number">0</span>, ien=inst.length ; i&lt;ien ; i++ ) {
			<span class="hljs-keyword">if</span> ( inst[i].length &gt; <span class="hljs-number">0</span> ) {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Assign the first element to the first item in the instance
and truncate the instance and context</p></div></div><div class="code"><div class="wrapper">				inst[<span class="hljs-number">0</span>] = inst[i];
				inst.length = <span class="hljs-number">1</span>;
				inst.context = [ inst.context[i] ];
	
				<span class="hljs-keyword">return</span> inst;
			}
		}
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Not found - return an empty instance</p></div></div><div class="code"><div class="wrapper">		inst.length = <span class="hljs-number">0</span>;
		<span class="hljs-keyword">return</span> inst;
	};
	
	
	<span class="hljs-keyword">var</span> _selector_row_indexes = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">( settings, opts )</span>
	{</span>
		<span class="hljs-keyword">var</span>
			i, ien, tmp, a=[],
			displayFiltered = settings.aiDisplay,
			displayMaster = settings.aiDisplayMaster;
	
		<span class="hljs-keyword">var</span>
			search = opts.search,  <span class="hljs-comment">// none, applied, removed</span>
			order  = opts.order,   <span class="hljs-comment">// applied, current, index (original - compatibility with 1.9)</span>
			page   = opts.page;    <span class="hljs-comment">// all, current</span>
	
		<span class="hljs-keyword">if</span> ( _fnDataSource( settings ) == <span class="hljs-string">'ssp'</span> ) {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>In server-side processing mode, most options are irrelevant since
rows not shown don&#39;t exist and the index order is the applied order
Removed is a special case - for consistency just return an empty
array</p></div></div><div class="code"><div class="wrapper">			<span class="hljs-keyword">return</span> search === <span class="hljs-string">'removed'</span> ?
				[] :
				_range( <span class="hljs-number">0</span>, displayMaster.length );
		}
		<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( page == <span class="hljs-string">'current'</span> ) {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Current page implies that order=current and fitler=applied, since it is
fairly senseless otherwise, regardless of what order and search actually
are</p></div></div><div class="code"><div class="wrapper">			<span class="hljs-keyword">for</span> ( i=settings._iDisplayStart, ien=settings.fnDisplayEnd() ; i&lt;ien ; i++ ) {
				a.push( displayFiltered[i] );
			}
		}
		<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( order == <span class="hljs-string">'current'</span> || order == <span class="hljs-string">'applied'</span> ) {
			a = search == <span class="hljs-string">'none'</span> ?
				displayMaster.slice() :                      <span class="hljs-comment">// no search</span>
				search == <span class="hljs-string">'applied'</span> ?
					displayFiltered.slice() :                <span class="hljs-comment">// applied search</span>
					$.map( displayMaster, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(el, i)</span> {</span> <span class="hljs-comment">// removed search</span>
						<span class="hljs-keyword">return</span> $.inArray( el, displayFiltered ) === -<span class="hljs-number">1</span> ? el : <span class="hljs-literal">null</span>;
					} );
		}
		<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( order == <span class="hljs-string">'index'</span> || order == <span class="hljs-string">'original'</span> ) {
			<span class="hljs-keyword">for</span> ( i=<span class="hljs-number">0</span>, ien=settings.aoData.length ; i&lt;ien ; i++ ) {
				<span class="hljs-keyword">if</span> ( search == <span class="hljs-string">'none'</span> ) {
					a.push( i );
				}
				<span class="hljs-keyword">else</span> { <span class="hljs-comment">// applied | removed</span>
					tmp = $.inArray( i, displayFiltered );
	
					<span class="hljs-keyword">if</span> ((tmp === -<span class="hljs-number">1</span> &amp;&amp; search == <span class="hljs-string">'removed'</span>) ||
						(tmp &gt;= <span class="hljs-number">0</span>   &amp;&amp; search == <span class="hljs-string">'applied'</span>) )
					{
						a.push( i );
					}
				}
			}
		}
	
		<span class="hljs-keyword">return</span> a;
	};
	
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><hr>
<p>Rows</p>
<p>{}          - no selector - use all available rows
{integer}   - row aoData index
{node}      - TR node
{string}    - jQuery selector to apply to the TR elements
{array}     - jQuery array of nodes, or simply an array of TR nodes</p></div></div><div class="code"><div class="wrapper">	
	
	<span class="hljs-keyword">var</span> __row_selector = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">( settings, selector, opts )</span>
	{</span>
		<span class="hljs-keyword">return</span> _selector_run( selector, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">( sel )</span> {</span>
			<span class="hljs-keyword">var</span> selInt = _intVal( sel );
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Short cut - selector is a number and no options provided (default is
all records, so no need to check if the index is in there, since it
must be - dev error if the index doesn&#39;t exist).</p></div></div><div class="code"><div class="wrapper">			<span class="hljs-keyword">if</span> ( selInt !== <span class="hljs-literal">null</span> &amp;&amp; ! opts ) {
				<span class="hljs-keyword">return</span> [ selInt ];
			}
	
			<span class="hljs-keyword">var</span> rows = _selector_row_indexes( settings, opts );
	
			<span class="hljs-keyword">if</span> ( selInt !== <span class="hljs-literal">null</span> &amp;&amp; $.inArray( selInt, rows ) !== -<span class="hljs-number">1</span> ) {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Selector - integer</p></div></div><div class="code"><div class="wrapper">				<span class="hljs-keyword">return</span> [ selInt ];
			}
			<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( ! sel ) {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Selector - none</p></div></div><div class="code"><div class="wrapper">				<span class="hljs-keyword">return</span> rows;
			}
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Get nodes in the order from the <code>rows</code> array (can&#39;t use <code>pluck</code>) @todo - use pluck_order</p></div></div><div class="code"><div class="wrapper">			<span class="hljs-keyword">var</span> nodes = [];
			<span class="hljs-keyword">for</span> ( <span class="hljs-keyword">var</span> i=<span class="hljs-number">0</span>, ien=rows.length ; i&lt;ien ; i++ ) {
				nodes.push( settings.aoData[ rows[i] ].nTr );
			}
	
			<span class="hljs-keyword">if</span> ( sel.nodeName ) {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Selector - node</p></div></div><div class="code"><div class="wrapper">				<span class="hljs-keyword">if</span> ( $.inArray( sel, nodes ) !== -<span class="hljs-number">1</span> ) {
					<span class="hljs-keyword">return</span> [ sel._DT_RowIndex ];<span class="hljs-comment">// sel is a TR node that is in the table</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>and DataTables adds a prop for fast lookup</p></div></div><div class="code"><div class="wrapper">				}
			}
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Selector - jQuery selector string, array of nodes or jQuery object/
As jQuery&#39;s .filter() allows jQuery objects to be passed in filter,
it also allows arrays, so this will cope with all three options</p></div></div><div class="code"><div class="wrapper">			<span class="hljs-keyword">return</span> $(nodes)
				.filter( sel )
				.map( <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
					<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._DT_RowIndex;
				} )
				.toArray();
		} );
	};
	
	</div></div></div><div class="segment"><div class="code"><div class="wrapper">	_api_register( <span class="hljs-string">'rows()'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">( selector, opts )</span> {</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>argument shifting</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-keyword">if</span> ( selector === <span class="hljs-literal">undefined</span> ) {
			selector = <span class="hljs-string">''</span>;
		}
		<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( $.isPlainObject( selector ) ) {
			opts = selector;
			selector = <span class="hljs-string">''</span>;
		}
	
		opts = _selector_opts( opts );
	
		<span class="hljs-keyword">var</span> inst = <span class="hljs-keyword">this</span>.iterator( <span class="hljs-string">'table'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">( settings )</span> {</span>
			<span class="hljs-keyword">return</span> __row_selector( settings, selector, opts );
		} );
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Want argument shifting here and in __row_selector?</p></div></div><div class="code"><div class="wrapper">		inst.selector.rows = selector;
		inst.selector.opts = opts;
	
		<span class="hljs-keyword">return</span> inst;
	} );
	
	
	_api_register( <span class="hljs-string">'rows().nodes()'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
		<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.iterator( <span class="hljs-string">'row'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">( settings, row )</span> {</span>
			<span class="hljs-keyword">return</span> settings.aoData[ row ].nTr || <span class="hljs-literal">undefined</span>;
		} );
	} );
	
	_api_register( <span class="hljs-string">'rows().data()'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
		<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.iterator( <span class="hljs-literal">true</span>, <span class="hljs-string">'rows'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">( settings, rows )</span> {</span>
			<span class="hljs-keyword">return</span> _pluck_order( settings.aoData, rows, <span class="hljs-string">'_aData'</span> );
		} );
	} );
	
	_api_registerPlural( <span class="hljs-string">'rows().cache()'</span>, <span class="hljs-string">'row().cache()'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">( type )</span> {</span>
		<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.iterator( <span class="hljs-string">'row'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">( settings, row )</span> {</span>
			<span class="hljs-keyword">var</span> r = settings.aoData[ row ];
			<span class="hljs-keyword">return</span> type === <span class="hljs-string">'search'</span> ? r._aFilterData : r._aSortData;
		} );
	} );
	
	_api_registerPlural( <span class="hljs-string">'rows().invalidate()'</span>, <span class="hljs-string">'row().invalidate()'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">( src )</span> {</span>
		<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.iterator( <span class="hljs-string">'row'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">( settings, row )</span> {</span>
			_fnInvalidateRow( settings, row, src );
		} );
	} );
	
	_api_registerPlural( <span class="hljs-string">'rows().indexes()'</span>, <span class="hljs-string">'row().index()'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
		<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.iterator( <span class="hljs-string">'row'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">( settings, row )</span> {</span>
			<span class="hljs-keyword">return</span> row;
		} );
	} );
	
	_api_registerPlural( <span class="hljs-string">'rows().remove()'</span>, <span class="hljs-string">'row().remove()'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
		<span class="hljs-keyword">var</span> that = <span class="hljs-keyword">this</span>;
	
		<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.iterator( <span class="hljs-string">'row'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">( settings, row, thatIdx )</span> {</span>
			<span class="hljs-keyword">var</span> data = settings.aoData;
	
			data.splice( row, <span class="hljs-number">1</span> );
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Update the _DT_RowIndex parameter on all rows in the table</p></div></div><div class="code"><div class="wrapper">			<span class="hljs-keyword">for</span> ( <span class="hljs-keyword">var</span> i=<span class="hljs-number">0</span>, ien=data.length ; i&lt;ien ; i++ ) {
				<span class="hljs-keyword">if</span> ( data[i].nTr !== <span class="hljs-literal">null</span> ) {
					data[i].nTr._DT_RowIndex = i;
				}
			}
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Remove the target row from the search array</p></div></div><div class="code"><div class="wrapper">			<span class="hljs-keyword">var</span> displayIndex = $.inArray( row, settings.aiDisplay );
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Delete from the display arrays</p></div></div><div class="code"><div class="wrapper">			_fnDeleteIndex( settings.aiDisplayMaster, row );
			_fnDeleteIndex( settings.aiDisplay, row );
			_fnDeleteIndex( that[ thatIdx ], row, <span class="hljs-literal">false</span> ); <span class="hljs-comment">// maintain local indexes</span>
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Check for an &#39;overflow&#39; they case for displaying the table</p></div></div><div class="code"><div class="wrapper">			_fnLengthOverflow( settings );
		} );
	} );
	
	
	_api_register( <span class="hljs-string">'rows.add()'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">( rows )</span> {</span>
		<span class="hljs-keyword">var</span> newRows = <span class="hljs-keyword">this</span>.iterator( <span class="hljs-string">'table'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">( settings )</span> {</span>
				<span class="hljs-keyword">var</span> row, i, ien;
				<span class="hljs-keyword">var</span> out = [];
	
				<span class="hljs-keyword">for</span> ( i=<span class="hljs-number">0</span>, ien=rows.length ; i&lt;ien ; i++ ) {
					row = rows[i];
	
					<span class="hljs-keyword">if</span> ( row.nodeName &amp;&amp; row.nodeName.toUpperCase() === <span class="hljs-string">'TR'</span> ) {
						out.push( _fnAddTr( settings, row )[<span class="hljs-number">0</span>] );
					}
					<span class="hljs-keyword">else</span> {
						out.push( _fnAddData( settings, row ) );
					}
				}
	
				<span class="hljs-keyword">return</span> out;
			} );
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Return an Api.rows() extended instance, so rows().nodes() etc can be used</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-keyword">var</span> modRows = <span class="hljs-keyword">this</span>.rows( -<span class="hljs-number">1</span> );
		modRows.pop();
		modRows.push.apply( modRows, newRows.toArray() );
	
		<span class="hljs-keyword">return</span> modRows;
	} );
	
	
	
	
	</div></div></div><div class="segment"><div class="code"><div class="wrapper">	_api_register( <span class="hljs-string">'row()'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">( selector, opts )</span> {</span>
		<span class="hljs-keyword">return</span> _selector_first( <span class="hljs-keyword">this</span>.rows( selector, opts ) );
	} );
	
	
	_api_register( <span class="hljs-string">'row().data()'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">( data )</span> {</span>
		<span class="hljs-keyword">var</span> ctx = <span class="hljs-keyword">this</span>.context;
	
		<span class="hljs-keyword">if</span> ( data === <span class="hljs-literal">undefined</span> ) {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Get</p></div></div><div class="code"><div class="wrapper">			<span class="hljs-keyword">return</span> ctx.length &amp;&amp; <span class="hljs-keyword">this</span>.length ?
				ctx[<span class="hljs-number">0</span>].aoData[ <span class="hljs-keyword">this</span>[<span class="hljs-number">0</span>] ]._aData :
				<span class="hljs-literal">undefined</span>;
		}
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Set</p></div></div><div class="code"><div class="wrapper">		ctx[<span class="hljs-number">0</span>].aoData[ <span class="hljs-keyword">this</span>[<span class="hljs-number">0</span>] ]._aData = data;
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Automatically invalidate</p></div></div><div class="code"><div class="wrapper">		_fnInvalidateRow( ctx[<span class="hljs-number">0</span>], <span class="hljs-keyword">this</span>[<span class="hljs-number">0</span>], <span class="hljs-string">'data'</span> );
	
		<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
	} );
	
	
	_api_register( <span class="hljs-string">'row().node()'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
		<span class="hljs-keyword">var</span> ctx = <span class="hljs-keyword">this</span>.context;
	
		<span class="hljs-keyword">return</span> ctx.length &amp;&amp; <span class="hljs-keyword">this</span>.length ?
			ctx[<span class="hljs-number">0</span>].aoData[ <span class="hljs-keyword">this</span>[<span class="hljs-number">0</span>] ].nTr || <span class="hljs-literal">null</span> :
			<span class="hljs-literal">null</span>;
	} );
	
	
	_api_register( <span class="hljs-string">'row.add()'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">( row )</span> {</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Allow a jQuery object to be passed in - only a single row is added from
it though - the first element in the set</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-keyword">if</span> ( row <span class="hljs-keyword">instanceof</span> $ &amp;&amp; row.length ) {
			row = row[<span class="hljs-number">0</span>];
		}
	
		<span class="hljs-keyword">var</span> rows = <span class="hljs-keyword">this</span>.iterator( <span class="hljs-string">'table'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">( settings )</span> {</span>
			<span class="hljs-keyword">if</span> ( row.nodeName &amp;&amp; row.nodeName.toUpperCase() === <span class="hljs-string">'TR'</span> ) {
				<span class="hljs-keyword">return</span> _fnAddTr( settings, row )[<span class="hljs-number">0</span>];
			}
			<span class="hljs-keyword">return</span> _fnAddData( settings, row );
		} );
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Return an Api.rows() extended instance, with the newly added row selected</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.row( rows[<span class="hljs-number">0</span>] );
	} );
	
	
	
	<span class="hljs-keyword">var</span> __details_add = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">( ctx, row, data, klass )</span>
	{</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Convert to array of TR elements</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-keyword">var</span> rows = [];
		<span class="hljs-keyword">var</span> addRow = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">( r, k )</span> {</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>If we get a TR element, then just add it directly - up to the dev
to add the correct number of columns etc</p></div></div><div class="code"><div class="wrapper">			<span class="hljs-keyword">if</span> ( r.nodeName &amp;&amp; r.nodeName.toLowerCase() === <span class="hljs-string">'tr'</span> ) {
				rows.push( r );
			}
			<span class="hljs-keyword">else</span> {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Otherwise create a row with a wrapper</p></div></div><div class="code"><div class="wrapper">				<span class="hljs-keyword">var</span> created = $(<span class="hljs-string">'&lt;tr&gt;&lt;td/&gt;&lt;/tr&gt;'</span>).addClass( k );
				$(<span class="hljs-string">'td'</span>, created)
					.addClass( k )
					.html( r )
					[<span class="hljs-number">0</span>].colSpan = _fnVisbleColumns( ctx );
	
				rows.push( created[<span class="hljs-number">0</span>] );
			}
		};
	
		<span class="hljs-keyword">if</span> ( $.isArray( data ) || data <span class="hljs-keyword">instanceof</span> $ ) {
			<span class="hljs-keyword">for</span> ( <span class="hljs-keyword">var</span> i=<span class="hljs-number">0</span>, ien=data.length ; i&lt;ien ; i++ ) {
				addRow( data[i], klass );
			}
		}
		<span class="hljs-keyword">else</span> {
			addRow( data, klass );
		}
	
		<span class="hljs-keyword">if</span> ( row._details ) {
			row._details.remove();
		}
	
		row._details = $(rows);
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>If the children were already shown, that state should be retained</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-keyword">if</span> ( row._detailsShow ) {
			row._details.insertAfter( row.nTr );
		}
	};
	
	
	<span class="hljs-keyword">var</span> __details_remove = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">( api )</span>
	{</span>
		<span class="hljs-keyword">var</span> ctx = api.context;
	
		<span class="hljs-keyword">if</span> ( ctx.length &amp;&amp; api.length ) {
			<span class="hljs-keyword">var</span> row = ctx[<span class="hljs-number">0</span>].aoData[ api[<span class="hljs-number">0</span>] ];
	
			<span class="hljs-keyword">if</span> ( row._details ) {
				row._details.remove();
	
				row._detailsShow = <span class="hljs-literal">undefined</span>;
				row._details = <span class="hljs-literal">undefined</span>;
			}
		}
	};
	
	
	<span class="hljs-keyword">var</span> __details_display = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">( api, show )</span> {</span>
		<span class="hljs-keyword">var</span> ctx = api.context;
	
		<span class="hljs-keyword">if</span> ( ctx.length &amp;&amp; api.length ) {
			<span class="hljs-keyword">var</span> row = ctx[<span class="hljs-number">0</span>].aoData[ api[<span class="hljs-number">0</span>] ];
	
			<span class="hljs-keyword">if</span> ( row._details ) {
				row._detailsShow = show;
	
				<span class="hljs-keyword">if</span> ( show ) {
					row._details.insertAfter( row.nTr );
				}
				<span class="hljs-keyword">else</span> {
					row._details.detach();
				}
	
				__details_events( ctx[<span class="hljs-number">0</span>] );
			}
		}
	};
	
	
	<span class="hljs-keyword">var</span> __details_events = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">( settings )</span>
	{</span>
		<span class="hljs-keyword">var</span> api = <span class="hljs-keyword">new</span> _Api( settings );
		<span class="hljs-keyword">var</span> namespace = <span class="hljs-string">'.dt.DT_details'</span>;
		<span class="hljs-keyword">var</span> drawEvent = <span class="hljs-string">'draw'</span>+namespace;
		<span class="hljs-keyword">var</span> colvisEvent = <span class="hljs-string">'column-visibility'</span>+namespace;
		<span class="hljs-keyword">var</span> destroyEvent = <span class="hljs-string">'destroy'</span>+namespace;
		<span class="hljs-keyword">var</span> data = settings.aoData;
	
		api.off( drawEvent +<span class="hljs-string">' '</span>+ colvisEvent +<span class="hljs-string">' '</span>+ destroyEvent );
	
		<span class="hljs-keyword">if</span> ( _pluck( data, <span class="hljs-string">'_details'</span> ).length &gt; <span class="hljs-number">0</span> ) {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>On each draw, insert the required elements into the document</p></div></div><div class="code"><div class="wrapper">			api.on( drawEvent, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">( e, ctx )</span> {</span>
				<span class="hljs-keyword">if</span> ( settings !== ctx ) {
					<span class="hljs-keyword">return</span>;
				}
	
				api.rows( {page:<span class="hljs-string">'current'</span>} ).eq(<span class="hljs-number">0</span>).each( <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(idx)</span> {</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Internal data grab</p></div></div><div class="code"><div class="wrapper">					<span class="hljs-keyword">var</span> row = data[ idx ];
	
					<span class="hljs-keyword">if</span> ( row._detailsShow ) {
						row._details.insertAfter( row.nTr );
					}
				} );
			} );
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Column visibility change - update the colspan</p></div></div><div class="code"><div class="wrapper">			api.on( colvisEvent, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">( e, ctx, idx, vis )</span> {</span>
				<span class="hljs-keyword">if</span> ( settings !== ctx ) {
					<span class="hljs-keyword">return</span>;
				}
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Update the colspan for the details rows (note, only if it already has
a colspan)</p></div></div><div class="code"><div class="wrapper">				<span class="hljs-keyword">var</span> row, visible = _fnVisbleColumns( ctx );
	
				<span class="hljs-keyword">for</span> ( <span class="hljs-keyword">var</span> i=<span class="hljs-number">0</span>, ien=data.length ; i&lt;ien ; i++ ) {
					row = data[i];
	
					<span class="hljs-keyword">if</span> ( row._details ) {
						row._details.children(<span class="hljs-string">'td[colspan]'</span>).attr(<span class="hljs-string">'colspan'</span>, visible );
					}
				}
			} );
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Table destroyed - nuke any child rows</p></div></div><div class="code"><div class="wrapper">			api.on( destroyEvent, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">( e, ctx )</span> {</span>
				<span class="hljs-keyword">if</span> ( settings !== ctx ) {
					<span class="hljs-keyword">return</span>;
				}
	
				<span class="hljs-keyword">for</span> ( <span class="hljs-keyword">var</span> i=<span class="hljs-number">0</span>, ien=data.length ; i&lt;ien ; i++ ) {
					<span class="hljs-keyword">if</span> ( data[i]._details ) {
						__details_remove( data[i] );
					}
				}
			} );
		}
	};
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Strings for the method names to help minification</p></div></div><div class="code"><div class="wrapper">	<span class="hljs-keyword">var</span> _emp = <span class="hljs-string">''</span>;
	<span class="hljs-keyword">var</span> _child_obj = _emp+<span class="hljs-string">'row().child'</span>;
	<span class="hljs-keyword">var</span> _child_mth = _child_obj+<span class="hljs-string">'()'</span>;
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>data can be:
 tr
 string
 jQuery or array of any of the above</p></div></div><div class="code"><div class="wrapper">	_api_register( _child_mth, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">( data, klass )</span> {</span>
		<span class="hljs-keyword">var</span> ctx = <span class="hljs-keyword">this</span>.context;
	
		<span class="hljs-keyword">if</span> ( data === <span class="hljs-literal">undefined</span> ) {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>get</p></div></div><div class="code"><div class="wrapper">			<span class="hljs-keyword">return</span> ctx.length &amp;&amp; <span class="hljs-keyword">this</span>.length ?
				ctx[<span class="hljs-number">0</span>].aoData[ <span class="hljs-keyword">this</span>[<span class="hljs-number">0</span>] ]._details :
				<span class="hljs-literal">undefined</span>;
		}
		<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( data === <span class="hljs-literal">true</span> ) {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>show</p></div></div><div class="code"><div class="wrapper">			<span class="hljs-keyword">this</span>.child.show();
		}
		<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( data === <span class="hljs-literal">false</span> ) {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>remove</p></div></div><div class="code"><div class="wrapper">			__details_remove( <span class="hljs-keyword">this</span> );
		}
		<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( ctx.length &amp;&amp; <span class="hljs-keyword">this</span>.length ) {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>set</p></div></div><div class="code"><div class="wrapper">			__details_add( ctx[<span class="hljs-number">0</span>], ctx[<span class="hljs-number">0</span>].aoData[ <span class="hljs-keyword">this</span>[<span class="hljs-number">0</span>] ], data, klass );
		}
	
		<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
	} );
	
	
	_api_register( [
		_child_obj+<span class="hljs-string">'.show()'</span>,
		_child_mth+<span class="hljs-string">'.show()'</span> <span class="hljs-comment">// only when `child()` was called with parameters (without</span>
	], <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">( show )</span> {</span>   <span class="hljs-comment">// it returns an object and this method is not executed)</span>
		__details_display( <span class="hljs-keyword">this</span>, <span class="hljs-literal">true</span> );
		<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
	} );
	
	
	_api_register( [
		_child_obj+<span class="hljs-string">'.hide()'</span>,
		_child_mth+<span class="hljs-string">'.hide()'</span> <span class="hljs-comment">// only when `child()` was called with parameters (without</span>
	], <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>         <span class="hljs-comment">// it returns an object and this method is not executed)</span>
		__details_display( <span class="hljs-keyword">this</span>, <span class="hljs-literal">false</span> );
		<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
	} );
	
	
	_api_register( [
		_child_obj+<span class="hljs-string">'.remove()'</span>,
		_child_mth+<span class="hljs-string">'.remove()'</span> <span class="hljs-comment">// only when `child()` was called with parameters (without</span>
	], <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>           <span class="hljs-comment">// it returns an object and this method is not executed)</span>
		__details_remove( <span class="hljs-keyword">this</span> );
		<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
	} );
	
	
	_api_register( _child_obj+<span class="hljs-string">'.isShown()'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
		<span class="hljs-keyword">var</span> ctx = <span class="hljs-keyword">this</span>.context;
	
		<span class="hljs-keyword">if</span> ( ctx.length &amp;&amp; <span class="hljs-keyword">this</span>.length ) {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>_detailsShown as false or undefined will fall through to return false</p></div></div><div class="code"><div class="wrapper">			<span class="hljs-keyword">return</span> ctx[<span class="hljs-number">0</span>].aoData[ <span class="hljs-keyword">this</span>[<span class="hljs-number">0</span>] ]._detailsShow || <span class="hljs-literal">false</span>;
		}
		<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
	} );
	
	
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><hr>
<p>Columns</p>
<p>{integer}           - column index (&gt;=0 count from left, <0 count from right)
"{integer}:visIdx"  - visible column index (i.e. translate to column index)  (>=0 count from left, <0 count from right)
"{integer}:visible" - alias for {integer}:visIdx  (>=0 count from left, &lt;0 count from right)
&quot;{string}:name&quot;     - column name
&quot;{string}&quot;          - jQuery selector on column header nodes</p></div></div><div class="code"><div class="wrapper">	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>can be an array of these items, comma separated list, or an array of comma
separated lists</p></div></div><div class="code"><div class="wrapper">	
	<span class="hljs-keyword">var</span> __re_column_selector = <span class="hljs-regexp">/^(.*):(name|visIdx|visible)$/</span>;
	
	<span class="hljs-keyword">var</span> __column_selector = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">( settings, selector, opts )</span>
	{</span>
		<span class="hljs-keyword">var</span>
			columns = settings.aoColumns,
			names = _pluck( columns, <span class="hljs-string">'sName'</span> ),
			nodes = _pluck( columns, <span class="hljs-string">'nTh'</span> );
	
		<span class="hljs-keyword">return</span> _selector_run( selector, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">( s )</span> {</span>
			<span class="hljs-keyword">var</span> selInt = _intVal( s );
	
			<span class="hljs-keyword">if</span> ( s === <span class="hljs-string">''</span> ) {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>All columns</p></div></div><div class="code"><div class="wrapper">				<span class="hljs-keyword">return</span> _range( columns.length );
			}
			<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( selInt !== <span class="hljs-literal">null</span> ) {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Integer selector</p></div></div><div class="code"><div class="wrapper">				<span class="hljs-keyword">return</span> [ selInt &gt;= <span class="hljs-number">0</span> ?
					selInt : <span class="hljs-comment">// Count from left</span>
					columns.length + selInt <span class="hljs-comment">// Count from right (+ because its a negative value)</span>
				];
			}
			<span class="hljs-keyword">else</span> {
				<span class="hljs-keyword">var</span> match = <span class="hljs-keyword">typeof</span> s === <span class="hljs-string">'string'</span> ?
					s.match( __re_column_selector ) :
					<span class="hljs-string">''</span>;
	
				<span class="hljs-keyword">if</span> ( match ) {
					<span class="hljs-keyword">switch</span>( match[<span class="hljs-number">2</span>] ) {
						<span class="hljs-keyword">case</span> <span class="hljs-string">'visIdx'</span>:
						<span class="hljs-keyword">case</span> <span class="hljs-string">'visible'</span>:
							<span class="hljs-keyword">var</span> idx = <span class="hljs-built_in">parseInt</span>( match[<span class="hljs-number">1</span>], <span class="hljs-number">10</span> );</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Visible index given, convert to column index</p></div></div><div class="code"><div class="wrapper">							<span class="hljs-keyword">if</span> ( idx &lt; <span class="hljs-number">0</span> ) {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Counting from the right</p></div></div><div class="code"><div class="wrapper">								<span class="hljs-keyword">var</span> visColumns = $.map( columns, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(col,i)</span> {</span>
									<span class="hljs-keyword">return</span> col.bVisible ? i : <span class="hljs-literal">null</span>;
								} );
								<span class="hljs-keyword">return</span> [ visColumns[ visColumns.length + idx ] ];
							}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Counting from the left</p></div></div><div class="code"><div class="wrapper">							<span class="hljs-keyword">return</span> [ _fnVisibleToColumnIndex( settings, idx ) ];
	
						<span class="hljs-keyword">case</span> <span class="hljs-string">'name'</span>:</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>match by name. <code>names</code> is column index complete and in order</p></div></div><div class="code"><div class="wrapper">							<span class="hljs-keyword">return</span> $.map( names, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(name, i)</span> {</span>
								<span class="hljs-keyword">return</span> name === match[<span class="hljs-number">1</span>] ? i : <span class="hljs-literal">null</span>;
							} );
					}
				}
				<span class="hljs-keyword">else</span> {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>jQuery selector on the TH elements for the columns</p></div></div><div class="code"><div class="wrapper">					<span class="hljs-keyword">return</span> $( nodes )
						.filter( s )
						.map( <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
							<span class="hljs-keyword">return</span> $.inArray( <span class="hljs-keyword">this</span>, nodes ); <span class="hljs-comment">// `nodes` is column index complete and in order</span>
						} )
						.toArray();
				}
			}
		} );
	};
	
	
	
	
	
	<span class="hljs-keyword">var</span> __setColumnVis = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">( settings, column, vis )</span> {</span>
		<span class="hljs-keyword">var</span>
			cols = settings.aoColumns,
			col  = cols[ column ],
			data = settings.aoData,
			row, cells, i, ien, tr;
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Get</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-keyword">if</span> ( vis === <span class="hljs-literal">undefined</span> ) {
			<span class="hljs-keyword">return</span> col.bVisible;
		}
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Set
No change</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-keyword">if</span> ( col.bVisible === vis ) {
			<span class="hljs-keyword">return</span>;
		}
	
		<span class="hljs-keyword">if</span> ( vis ) {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Insert column
Need to decide if we should use appendChild or insertBefore</p></div></div><div class="code"><div class="wrapper">			<span class="hljs-keyword">var</span> insertBefore = $.inArray( <span class="hljs-literal">true</span>, _pluck(cols, <span class="hljs-string">'bVisible'</span>), column+<span class="hljs-number">1</span> );
	
			<span class="hljs-keyword">for</span> ( i=<span class="hljs-number">0</span>, ien=data.length ; i&lt;ien ; i++ ) {
				tr = data[i].nTr;
				cells = data[i].anCells;
	
				<span class="hljs-keyword">if</span> ( tr ) {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>insertBefore can act like appendChild if 2nd arg is null</p></div></div><div class="code"><div class="wrapper">					tr.insertBefore( cells[ column ], cells[ insertBefore ] || <span class="hljs-literal">null</span> );
				}
			}
		}
		<span class="hljs-keyword">else</span> {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Remove column</p></div></div><div class="code"><div class="wrapper">			$( _pluck( settings.aoData, <span class="hljs-string">'anCells'</span>, column ) ).detach();
		}
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Common actions</p></div></div><div class="code"><div class="wrapper">		col.bVisible = vis;
		_fnDrawHead( settings, settings.aoHeader );
		_fnDrawHead( settings, settings.aoFooter );
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Automatically adjust column sizing</p></div></div><div class="code"><div class="wrapper">		_fnAdjustColumnSizing( settings );
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Realign columns for scrolling</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-keyword">if</span> ( settings.oScroll.sX || settings.oScroll.sY ) {
			_fnScrollDraw( settings );
		}
	
		_fnCallbackFire( settings, <span class="hljs-literal">null</span>, <span class="hljs-string">'column-visibility'</span>, [settings, column, vis] );
	
		_fnSaveState( settings );
	};
	
	</div></div></div><div class="segment"><div class="code"><div class="wrapper">	_api_register( <span class="hljs-string">'columns()'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">( selector, opts )</span> {</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>argument shifting</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-keyword">if</span> ( selector === <span class="hljs-literal">undefined</span> ) {
			selector = <span class="hljs-string">''</span>;
		}
		<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( $.isPlainObject( selector ) ) {
			opts = selector;
			selector = <span class="hljs-string">''</span>;
		}
	
		opts = _selector_opts( opts );
	
		<span class="hljs-keyword">var</span> inst = <span class="hljs-keyword">this</span>.iterator( <span class="hljs-string">'table'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">( settings )</span> {</span>
			<span class="hljs-keyword">return</span> __column_selector( settings, selector, opts );
		} );
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Want argument shifting here and in _row_selector?</p></div></div><div class="code"><div class="wrapper">		inst.selector.cols = selector;
		inst.selector.opts = opts;
	
		<span class="hljs-keyword">return</span> inst;
	} );
	
	</div></div></div><div class="segment"><div class="code"><div class="wrapper">	_api_registerPlural( <span class="hljs-string">'columns().header()'</span>, <span class="hljs-string">'column().header()'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">( selector, opts )</span> {</span>
		<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.iterator( <span class="hljs-string">'column'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">( settings, column )</span> {</span>
			<span class="hljs-keyword">return</span> settings.aoColumns[column].nTh;
		} );
	} );
	
	</div></div></div><div class="segment"><div class="code"><div class="wrapper">	_api_registerPlural( <span class="hljs-string">'columns().footer()'</span>, <span class="hljs-string">'column().footer()'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">( selector, opts )</span> {</span>
		<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.iterator( <span class="hljs-string">'column'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">( settings, column )</span> {</span>
			<span class="hljs-keyword">return</span> settings.aoColumns[column].nTf;
		} );
	} );
	
	</div></div></div><div class="segment"><div class="code"><div class="wrapper">	_api_registerPlural( <span class="hljs-string">'columns().data()'</span>, <span class="hljs-string">'column().data()'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
		<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.iterator( <span class="hljs-string">'column-rows'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">( settings, column, i, j, rows )</span> {</span>
			<span class="hljs-keyword">var</span> a = [];
			<span class="hljs-keyword">for</span> ( <span class="hljs-keyword">var</span> row=<span class="hljs-number">0</span>, ien=rows.length ; row&lt;ien ; row++ ) {
				a.push( _fnGetCellData( settings, rows[row], column, <span class="hljs-string">''</span> ) );
			}
			<span class="hljs-keyword">return</span> a;
		} );
	} );
	
	
	_api_registerPlural( <span class="hljs-string">'columns().cache()'</span>, <span class="hljs-string">'column().cache()'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">( type )</span> {</span>
		<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.iterator( <span class="hljs-string">'column-rows'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">( settings, column, i, j, rows )</span> {</span>
			<span class="hljs-keyword">return</span> _pluck_order( settings.aoData, rows,
				type === <span class="hljs-string">'search'</span> ? <span class="hljs-string">'_aFilterData'</span> : <span class="hljs-string">'_aSortData'</span>, column
			);
		} );
	} );
	
	
	_api_registerPlural( <span class="hljs-string">'columns().nodes()'</span>, <span class="hljs-string">'column().nodes()'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
		<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.iterator( <span class="hljs-string">'column-rows'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">( settings, column, i, j, rows )</span> {</span>
			<span class="hljs-keyword">return</span> _pluck_order( settings.aoData, rows, <span class="hljs-string">'anCells'</span>, column ) ;
		} );
	} );
	
	
	
	_api_registerPlural( <span class="hljs-string">'columns().visible()'</span>, <span class="hljs-string">'column().visible()'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">( vis )</span> {</span>
		<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.iterator( <span class="hljs-string">'column'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">( settings, column )</span> {</span>
			<span class="hljs-keyword">return</span> vis === <span class="hljs-literal">undefined</span> ?
				settings.aoColumns[ column ].bVisible :
				__setColumnVis( settings, column, vis );
		} );
	} );
	
	
	
	_api_registerPlural( <span class="hljs-string">'columns().indexes()'</span>, <span class="hljs-string">'column().index()'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">( type )</span> {</span>
		<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.iterator( <span class="hljs-string">'column'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">( settings, column )</span> {</span>
			<span class="hljs-keyword">return</span> type === <span class="hljs-string">'visible'</span> ?
				_fnColumnIndexToVisible( settings, column ) :
				column;
		} );
	} );
	
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>_api_register( &#39;columns().show()&#39;, function () {
    var selector = this.selector;
    return this.columns( selector.cols, selector.opts ).visible( true );</p></div></div><div class="code"><div class="wrapper">	<span class="hljs-comment">// );</span>
	
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>_api_register( &#39;columns().hide()&#39;, function () {
    var selector = this.selector;
    return this.columns( selector.cols, selector.opts ).visible( false );</p></div></div><div class="code"><div class="wrapper">	<span class="hljs-comment">// );</span>
	
	
	
	_api_register( <span class="hljs-string">'columns.adjust()'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
		<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.iterator( <span class="hljs-string">'table'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">( settings )</span> {</span>
			_fnAdjustColumnSizing( settings );
		} );
	} );
	
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Convert from one column index type, to another type</p></div></div><div class="code"><div class="wrapper">	_api_register( <span class="hljs-string">'column.index()'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">( type, idx )</span> {</span>
		<span class="hljs-keyword">if</span> ( <span class="hljs-keyword">this</span>.context.length !== <span class="hljs-number">0</span> ) {
			<span class="hljs-keyword">var</span> ctx = <span class="hljs-keyword">this</span>.context[<span class="hljs-number">0</span>];
	
			<span class="hljs-keyword">if</span> ( type === <span class="hljs-string">'fromVisible'</span> || type === <span class="hljs-string">'toData'</span> ) {
				<span class="hljs-keyword">return</span> _fnVisibleToColumnIndex( ctx, idx );
			}
			<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( type === <span class="hljs-string">'fromData'</span> || type === <span class="hljs-string">'toVisible'</span> ) {
				<span class="hljs-keyword">return</span> _fnColumnIndexToVisible( ctx, idx );
			}
		}
	} );
	
	
	_api_register( <span class="hljs-string">'column()'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">( selector, opts )</span> {</span>
		<span class="hljs-keyword">return</span> _selector_first( <span class="hljs-keyword">this</span>.columns( selector, opts ) );
	} );
	
	
	
	
	<span class="hljs-keyword">var</span> __cell_selector = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">( settings, selector, opts )</span>
	{</span>
		<span class="hljs-keyword">var</span> data = settings.aoData;
		<span class="hljs-keyword">var</span> rows = _selector_row_indexes( settings, opts );
		<span class="hljs-keyword">var</span> cells = _pluck_order( data, rows, <span class="hljs-string">'anCells'</span> );
		<span class="hljs-keyword">var</span> allCells = $( [].concat.apply([], cells) );
		<span class="hljs-keyword">var</span> row;
		<span class="hljs-keyword">var</span> columns = settings.aoColumns.length;
		<span class="hljs-keyword">var</span> a, i, ien, j;
	
		<span class="hljs-keyword">return</span> _selector_run( selector, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">( s )</span> {</span>
			<span class="hljs-keyword">if</span> ( s === <span class="hljs-literal">null</span> || s === <span class="hljs-literal">undefined</span> ) {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>All cells</p></div></div><div class="code"><div class="wrapper">				a = [];
	
				<span class="hljs-keyword">for</span> ( i=<span class="hljs-number">0</span>, ien=rows.length ; i&lt;ien ; i++ ) {
					row = rows[i];
	
					<span class="hljs-keyword">for</span> ( j=<span class="hljs-number">0</span> ; j&lt;columns ; j++ ) {
						a.push( {
							row: row,
							column: j
						} );
					}
				}
	
				<span class="hljs-keyword">return</span> a;
			}
			<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( $.isPlainObject( s ) ) {
				<span class="hljs-keyword">return</span> [s];
			}
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>jQuery filtered cells</p></div></div><div class="code"><div class="wrapper">			<span class="hljs-keyword">return</span> allCells
				.filter( s )
				.map( <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(i, el)</span> {</span>
					row = el.parentNode._DT_RowIndex;
	
					<span class="hljs-keyword">return</span> {
						row: row,
						column: $.inArray( el, data[ row ].anCells )
					};
				} )
				.toArray();
		} );
	};
	
	
	
	
	_api_register( <span class="hljs-string">'cells()'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">( rowSelector, columnSelector, opts )</span> {</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Argument shifting</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-keyword">if</span> ( $.isPlainObject( rowSelector ) ) {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Indexes</p></div></div><div class="code"><div class="wrapper">			<span class="hljs-keyword">if</span> ( <span class="hljs-keyword">typeof</span> rowSelector.row !== <span class="hljs-literal">undefined</span> ) {
				opts = columnSelector;
				columnSelector = <span class="hljs-literal">null</span>;
			}
			<span class="hljs-keyword">else</span> {
				opts = rowSelector;
				rowSelector = <span class="hljs-literal">null</span>;
			}
		}
		<span class="hljs-keyword">if</span> ( $.isPlainObject( columnSelector ) ) {
			opts = columnSelector;
			columnSelector = <span class="hljs-literal">null</span>;
		}
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Cell selector</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-keyword">if</span> ( columnSelector === <span class="hljs-literal">null</span> || columnSelector === <span class="hljs-literal">undefined</span> ) {
			<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.iterator( <span class="hljs-string">'table'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">( settings )</span> {</span>
				<span class="hljs-keyword">return</span> __cell_selector( settings, rowSelector, _selector_opts( opts ) );
			} );
		}
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Row + column selector</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-keyword">var</span> columns = <span class="hljs-keyword">this</span>.columns( columnSelector, opts );
		<span class="hljs-keyword">var</span> rows = <span class="hljs-keyword">this</span>.rows( rowSelector, opts );
		<span class="hljs-keyword">var</span> a, i, ien, j, jen;
	
		<span class="hljs-keyword">var</span> cells = <span class="hljs-keyword">this</span>.iterator( <span class="hljs-string">'table'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">( settings, idx )</span> {</span>
			a = [];
	
			<span class="hljs-keyword">for</span> ( i=<span class="hljs-number">0</span>, ien=rows[idx].length ; i&lt;ien ; i++ ) {
				<span class="hljs-keyword">for</span> ( j=<span class="hljs-number">0</span>, jen=columns[idx].length ; j&lt;jen ; j++ ) {
					a.push( {
						row:    rows[idx][i],
						column: columns[idx][j]
					} );
				}
			}
	
			<span class="hljs-keyword">return</span> a;
		} );
	
		$.extend( cells.selector, {
			cols: columnSelector,
			rows: rowSelector,
			opts: opts
		} );
	
		<span class="hljs-keyword">return</span> cells;
	} );
	
	
	_api_registerPlural( <span class="hljs-string">'cells().nodes()'</span>, <span class="hljs-string">'cell().node()'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
		<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.iterator( <span class="hljs-string">'cell'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">( settings, row, column )</span> {</span>
			<span class="hljs-keyword">return</span> settings.aoData[ row ].anCells[ column ];
		} );
	} );
	
	
	_api_register( <span class="hljs-string">'cells().data()'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
		<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.iterator( <span class="hljs-string">'cell'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">( settings, row, column )</span> {</span>
			<span class="hljs-keyword">return</span> _fnGetCellData( settings, row, column );
		} );
	} );
	
	
	_api_registerPlural( <span class="hljs-string">'cells().cache()'</span>, <span class="hljs-string">'cell().cache()'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">( type )</span> {</span>
		type = type === <span class="hljs-string">'search'</span> ? <span class="hljs-string">'_aFilterData'</span> : <span class="hljs-string">'_aSortData'</span>;
	
		<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.iterator( <span class="hljs-string">'cell'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">( settings, row, column )</span> {</span>
			<span class="hljs-keyword">return</span> settings.aoData[ row ][ type ][ column ];
		} );
	} );
	
	
	_api_registerPlural( <span class="hljs-string">'cells().indexes()'</span>, <span class="hljs-string">'cell().index()'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
		<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.iterator( <span class="hljs-string">'cell'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">( settings, row, column )</span> {</span>
			<span class="hljs-keyword">return</span> {
				row: row,
				column: column,
				columnVisible: _fnColumnIndexToVisible( settings, column )
			};
		} );
	} );
	
	
	_api_register( [
		<span class="hljs-string">'cells().invalidate()'</span>,
		<span class="hljs-string">'cell().invalidate()'</span>
	], <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">( src )</span> {</span>
		<span class="hljs-keyword">var</span> selector = <span class="hljs-keyword">this</span>.selector;
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Use the rows method of the instance to perform the invalidation, rather
than doing it here. This avoids needing to handle duplicate rows from
the cells.</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-keyword">this</span>.rows( selector.rows, selector.opts ).invalidate( src );
	
		<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
	} );
	
	
	
	
	_api_register( <span class="hljs-string">'cell()'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">( rowSelector, columnSelector, opts )</span> {</span>
		<span class="hljs-keyword">return</span> _selector_first( <span class="hljs-keyword">this</span>.cells( rowSelector, columnSelector, opts ) );
	} );
	
	
	
	_api_register( <span class="hljs-string">'cell().data()'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">( data )</span> {</span>
		<span class="hljs-keyword">var</span> ctx = <span class="hljs-keyword">this</span>.context;
		<span class="hljs-keyword">var</span> cell = <span class="hljs-keyword">this</span>[<span class="hljs-number">0</span>];
	
		<span class="hljs-keyword">if</span> ( data === <span class="hljs-literal">undefined</span> ) {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Get</p></div></div><div class="code"><div class="wrapper">			<span class="hljs-keyword">return</span> ctx.length &amp;&amp; cell.length ?
				_fnGetCellData( ctx[<span class="hljs-number">0</span>], cell[<span class="hljs-number">0</span>].row, cell[<span class="hljs-number">0</span>].column ) :
				<span class="hljs-literal">undefined</span>;
		}
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Set</p></div></div><div class="code"><div class="wrapper">		_fnSetCellData( ctx[<span class="hljs-number">0</span>], cell[<span class="hljs-number">0</span>].row, cell[<span class="hljs-number">0</span>].column, data );
		_fnInvalidateRow( ctx[<span class="hljs-number">0</span>], cell[<span class="hljs-number">0</span>].row, <span class="hljs-string">'data'</span>, cell[<span class="hljs-number">0</span>].column );
	
		<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
	} );
	
	
	</div></div></div><div class="segment"><div class="comments doc-section"><div class="wrapper"><p>Get current ordering (sorting) that has been applied to the table.</p>
<p><strong>Returns an array</strong><br/>(2D array containing the sorting information for the first table in the current context. Each element in the parent array represents a column being sorted upon (i.e. multi-sorting with two columns would have 2 inner arrays). The inner arrays may have 2 or 3 elements. The first is the column index that the sorting condition applies to, the second is the direction of the sort (<code>desc</code> or <code>asc</code>) and, optionally, the third is the index of the sorting order from the <code>column.sorting</code> initialisation array.)</p></div></div><div class="code"><div class="wrapper"><span class="hljs-comment">/**
	 * Set the ordering for the table.
	 *
	 * @param {integer} order Column index to sort upon.
	 * @param {string} direction Direction of the sort to be applied (`asc` or `desc`)
	 * @returns {DataTables.Api} this
	 */</span><span class="hljs-comment">/**
	 * Set the ordering for the table.
	 *
	 * @param {array} order 1D array of sorting information to be applied.
	 * @param {array} [...] Optional additional sorting conditions
	 * @returns {DataTables.Api} this
	 */</span><span class="hljs-comment">/**
	 * Set the ordering for the table.
	 *
	 * @param {array} order 2D array of sorting information to be applied.
	 * @returns {DataTables.Api} this
	 */</span>
	_api_register( <span class="hljs-string">'order()'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">( order, dir )</span> {</span>
		<span class="hljs-keyword">var</span> ctx = <span class="hljs-keyword">this</span>.context;
	
		<span class="hljs-keyword">if</span> ( order === <span class="hljs-literal">undefined</span> ) {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>get</p></div></div><div class="code"><div class="wrapper">			<span class="hljs-keyword">return</span> ctx.length !== <span class="hljs-number">0</span> ?
				ctx[<span class="hljs-number">0</span>].aaSorting :
				<span class="hljs-literal">undefined</span>;
		}
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>set</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-keyword">if</span> ( <span class="hljs-keyword">typeof</span> order === <span class="hljs-string">'number'</span> ) {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Simple column / direction passed in</p></div></div><div class="code"><div class="wrapper">			order = [ [ order, dir ] ];
		}
		<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( ! $.isArray( order[<span class="hljs-number">0</span>] ) ) {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Arguments passed in (list of 1D arrays)</p></div></div><div class="code"><div class="wrapper">			order = <span class="hljs-built_in">Array</span>.prototype.slice.call( <span class="hljs-built_in">arguments</span> );
		}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>otherwise a 2D array was passed in</p></div></div><div class="code"><div class="wrapper">	
		<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.iterator( <span class="hljs-string">'table'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">( settings )</span> {</span>
			settings.aaSorting = order.slice();
		} );
	} );
	
	</div></div></div><div class="segment"><div class="comments doc-section"><div class="wrapper"><p>Attach a sort listener to an element for a given column</p>
<p>Parameters:</p>
<ul>
<li><p><strong>node can be a node, a jQuery, or a string.</strong><br/>(Identifier for the element(s) to attach the listener to. This can take the form of a single DOM node, a jQuery collection of nodes or a jQuery selector which will identify the node(s).)</p>
</li>
<li><p><strong>column must be an integer.</strong><br/>(the column that a click on this node will sort on)</p>
</li>
<li><p><strong>callback is optional and must be a function.</strong><br/>(callback function when sort is run)</p>
</li>
</ul>
<p><strong>Returns a DataTables.Api</strong><br/>(this)</p></div></div><div class="code"><div class="wrapper">	_api_register( <span class="hljs-string">'order.listener()'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">( node, column, callback )</span> {</span>
		<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.iterator( <span class="hljs-string">'table'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">( settings )</span> {</span>
			_fnSortAttachListener( settings, node, column, callback );
		} );
	} );
	
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Order by the selected column(s)</p></div></div><div class="code"><div class="wrapper">	_api_register( [
		<span class="hljs-string">'columns().order()'</span>,
		<span class="hljs-string">'column().order()'</span>
	], <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">( dir )</span> {</span>
		<span class="hljs-keyword">var</span> that = <span class="hljs-keyword">this</span>;
	
		<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.iterator( <span class="hljs-string">'table'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">( settings, i )</span> {</span>
			<span class="hljs-keyword">var</span> sort = [];
	
			$.each( that[i], <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(j, col)</span> {</span>
				sort.push( [ col, dir ] );
			} );
	
			settings.aaSorting = sort;
		} );
	} );
	
	
	
	_api_register( <span class="hljs-string">'search()'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">( input, regex, smart, caseInsen )</span> {</span>
		<span class="hljs-keyword">var</span> ctx = <span class="hljs-keyword">this</span>.context;
	
		<span class="hljs-keyword">if</span> ( input === <span class="hljs-literal">undefined</span> ) {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>get</p></div></div><div class="code"><div class="wrapper">			<span class="hljs-keyword">return</span> ctx.length !== <span class="hljs-number">0</span> ?
				ctx[<span class="hljs-number">0</span>].oPreviousSearch.sSearch :
				<span class="hljs-literal">undefined</span>;
		}
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>set</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.iterator( <span class="hljs-string">'table'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">( settings )</span> {</span>
			<span class="hljs-keyword">if</span> ( ! settings.oFeatures.bFilter ) {
				<span class="hljs-keyword">return</span>;
			}
	
			_fnFilterComplete( settings, $.extend( {}, settings.oPreviousSearch, {
				<span class="hljs-string">"sSearch"</span>: input+<span class="hljs-string">""</span>,
				<span class="hljs-string">"bRegex"</span>:  regex === <span class="hljs-literal">null</span> ? <span class="hljs-literal">false</span> : regex,
				<span class="hljs-string">"bSmart"</span>:  smart === <span class="hljs-literal">null</span> ? <span class="hljs-literal">true</span>  : smart,
				<span class="hljs-string">"bCaseInsensitive"</span>: caseInsen === <span class="hljs-literal">null</span> ? <span class="hljs-literal">true</span> : caseInsen
			} ), <span class="hljs-number">1</span> );
		} );
	} );
	
	
	_api_register( [
		<span class="hljs-string">'columns().search()'</span>,
		<span class="hljs-string">'column().search()'</span>
	], <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">( input, regex, smart, caseInsen )</span> {</span>
		<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.iterator( <span class="hljs-string">'column'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">( settings, column )</span> {</span>
			<span class="hljs-keyword">var</span> preSearch = settings.aoPreSearchCols;
	
			<span class="hljs-keyword">if</span> ( input === <span class="hljs-literal">undefined</span> ) {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>get</p></div></div><div class="code"><div class="wrapper">				<span class="hljs-keyword">return</span> preSearch[ column ].sSearch;
			}
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>set</p></div></div><div class="code"><div class="wrapper">			<span class="hljs-keyword">if</span> ( ! settings.oFeatures.bFilter ) {
				<span class="hljs-keyword">return</span>;
			}
	
			$.extend( preSearch[ column ], {
				<span class="hljs-string">"sSearch"</span>: input+<span class="hljs-string">""</span>,
				<span class="hljs-string">"bRegex"</span>:  regex === <span class="hljs-literal">null</span> ? <span class="hljs-literal">false</span> : regex,
				<span class="hljs-string">"bSmart"</span>:  smart === <span class="hljs-literal">null</span> ? <span class="hljs-literal">true</span>  : smart,
				<span class="hljs-string">"bCaseInsensitive"</span>: caseInsen === <span class="hljs-literal">null</span> ? <span class="hljs-literal">true</span> : caseInsen
			} );
	
			_fnFilterComplete( settings, settings.oPreviousSearch, <span class="hljs-number">1</span> );
		} );
	} );
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>State API methods</p></div></div><div class="code"><div class="wrapper">	
	_api_register( <span class="hljs-string">'state()'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
		<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.context.length ?
			<span class="hljs-keyword">this</span>.context[<span class="hljs-number">0</span>].oSavedState :
			<span class="hljs-literal">null</span>;
	} );
	
	
	_api_register( <span class="hljs-string">'state.clear()'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
		<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.iterator( <span class="hljs-string">'table'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">( settings )</span> {</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Save an empty object</p></div></div><div class="code"><div class="wrapper">			settings.fnStateSaveCallback.call( settings.oInstance, settings, {} );
		} );
	} );
	
	
	_api_register( <span class="hljs-string">'state.loaded()'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
		<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.context.length ?
			<span class="hljs-keyword">this</span>.context[<span class="hljs-number">0</span>].oLoadedState :
			<span class="hljs-literal">null</span>;
	} );
	
	
	_api_register( <span class="hljs-string">'state.save()'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
		<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.iterator( <span class="hljs-string">'table'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">( settings )</span> {</span>
			_fnSaveState( settings );
		} );
	} );
	
	
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Provide a common method for plug-ins to check the version of DataTables being
used, in order to ensure compatibility.</p>
<p> @param {string} version Version string to check for, in the format &quot;X.Y.Z&quot;.
   Note that the formats &quot;X&quot; and &quot;X.Y&quot; are also acceptable.
 @returns {boolean} true if this version of DataTables is greater or equal to
   the required version, or false if this version of DataTales is not
   suitable
 @static
 @dtopt API-Static</p>
<p> @example
   alert( $.fn.dataTable.versionCheck( &#39;1.9.0&#39; ) );</p></div></div><div class="code"><div class="wrapper">	DataTable.versionCheck = DataTable.fnVersionCheck = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( version )</span>
	{</span>
		<span class="hljs-keyword">var</span> aThis = DataTable.version.split(<span class="hljs-string">'.'</span>);
		<span class="hljs-keyword">var</span> aThat = version.split(<span class="hljs-string">'.'</span>);
		<span class="hljs-keyword">var</span> iThis, iThat;
	
		<span class="hljs-keyword">for</span> ( <span class="hljs-keyword">var</span> i=<span class="hljs-number">0</span>, iLen=aThat.length ; i&lt;iLen ; i++ ) {
			iThis = <span class="hljs-built_in">parseInt</span>( aThis[i], <span class="hljs-number">10</span> ) || <span class="hljs-number">0</span>;
			iThat = <span class="hljs-built_in">parseInt</span>( aThat[i], <span class="hljs-number">10</span> ) || <span class="hljs-number">0</span>;
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Parts are the same, keep comparing</p></div></div><div class="code"><div class="wrapper">			<span class="hljs-keyword">if</span> (iThis === iThat) {
				<span class="hljs-keyword">continue</span>;
			}
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Parts are different, return immediately</p></div></div><div class="code"><div class="wrapper">			<span class="hljs-keyword">return</span> iThis &gt; iThat;
		}
	
		<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
	};
	
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Check if a <code>&lt;table&gt;</code> node is a DataTable table already or not.</p>
<p> @param {node|jquery|string} table Table node, jQuery object or jQuery
     selector for the table to test. Note that if more than more than one
     table is passed on, only the first will be checked
 @returns {boolean} true the table given is a DataTable, or false otherwise
 @static
 @dtopt API-Static</p>
<p> @example
   if ( ! $.fn.DataTable.isDataTable( &#39;#example&#39; ) ) {
     $(&#39;#example&#39;).dataTable();
   }</p></div></div><div class="code"><div class="wrapper">	DataTable.isDataTable = DataTable.fnIsDataTable = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">( table )</span>
	{</span>
		<span class="hljs-keyword">var</span> t = $(table).get(<span class="hljs-number">0</span>);
		<span class="hljs-keyword">var</span> is = <span class="hljs-literal">false</span>;
	
		$.each( DataTable.settings, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(i, o)</span> {</span>
			<span class="hljs-keyword">if</span> ( o.nTable === t || o.nScrollHead === t || o.nScrollFoot === t ) {
				is = <span class="hljs-literal">true</span>;
			}
		} );
	
		<span class="hljs-keyword">return</span> is;
	};
	
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Get all DataTable tables that have been initialised - optionally you can
select to get only currently visible tables.</p>
<p> @param {boolean} [visible=false] Flag to indicate if you want all (default)
   or visible tables only.
 @returns {array} Array of <code>table</code> nodes (not DataTable instances) which are
   DataTables
 @static
 @dtopt API-Static</p>
<p> @example
   $.each( $.fn.dataTable.tables(true), function () {
     $(table).DataTable().columns.adjust();
   } );</p></div></div><div class="code"><div class="wrapper">	DataTable.tables = DataTable.fnTables = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">( visible )</span>
	{</span>
		<span class="hljs-keyword">return</span> jQuery.map( DataTable.settings, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(o)</span> {</span>
			<span class="hljs-keyword">if</span> ( !visible || (visible &amp;&amp; $(o.nTable).is(<span class="hljs-string">':visible'</span>)) ) {
				<span class="hljs-keyword">return</span> o.nTable;
			}
		} );
	};
	
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Convert from camel case parameters to Hungarian notation. This is made public
for the extensions to provide the same ability as DataTables core to accept
either the 1.9 style Hungarian notation, or the 1.10+ style camelCase
parameters.</p>
<p> @param {object} src The model object which holds all parameters that can be
   mapped.
 @param {object} user The object to convert from camel case to Hungarian.
 @param {boolean} force When set to <code>true</code>, properties which already have a
   Hungarian value in the <code>user</code> object will be overwritten. Otherwise they
   won&#39;t be.</p></div></div><div class="code"><div class="wrapper">	DataTable.camelToHungarian = _fnCamelToHungarian;
	
	
	</div></div></div><div class="segment"><div class="code"><div class="wrapper">	_api_register( <span class="hljs-string">'$()'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">( selector, opts )</span> {</span>
		<span class="hljs-keyword">var</span>
			rows   = <span class="hljs-keyword">this</span>.rows( opts ).nodes(), <span class="hljs-comment">// Get all rows</span>
			jqRows = $(rows);
	
		<span class="hljs-keyword">return</span> $( [].concat(
			jqRows.filter( selector ).toArray(),
			jqRows.find( selector ).toArray()
		) );
	} );
	
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>jQuery functions to operate on the tables</p></div></div><div class="code"><div class="wrapper">	$.each( [ <span class="hljs-string">'on'</span>, <span class="hljs-string">'one'</span>, <span class="hljs-string">'off'</span> ], <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(i, key)</span> {</span>
		_api_register( key+<span class="hljs-string">'()'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">( <span class="hljs-comment">/* event, handler */</span> )</span> {</span>
			<span class="hljs-keyword">var</span> args = <span class="hljs-built_in">Array</span>.prototype.slice.call(<span class="hljs-built_in">arguments</span>);
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Add the <code>dt</code> namespace automatically if it isn&#39;t already present</p></div></div><div class="code"><div class="wrapper">			<span class="hljs-keyword">if</span> ( ! args[<span class="hljs-number">0</span>].match(<span class="hljs-regexp">/\.dt\b/</span>) ) {
				args[<span class="hljs-number">0</span>] += <span class="hljs-string">'.dt'</span>;
			}
	
			<span class="hljs-keyword">var</span> inst = $( <span class="hljs-keyword">this</span>.tables().nodes() );
			inst[key].apply( inst, args );
			<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
		} );
	} );
	
	
	_api_register( <span class="hljs-string">'clear()'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
		<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.iterator( <span class="hljs-string">'table'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">( settings )</span> {</span>
			_fnClearTable( settings );
		} );
	} );
	
	
	_api_register( <span class="hljs-string">'settings()'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
		<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> _Api( <span class="hljs-keyword">this</span>.context, <span class="hljs-keyword">this</span>.context );
	} );
	
	
	_api_register( <span class="hljs-string">'data()'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
		<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.iterator( <span class="hljs-string">'table'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">( settings )</span> {</span>
			<span class="hljs-keyword">return</span> _pluck( settings.aoData, <span class="hljs-string">'_aData'</span> );
		} ).flatten();
	} );
	
	
	_api_register( <span class="hljs-string">'destroy()'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">( remove )</span> {</span>
		remove = remove || <span class="hljs-literal">false</span>;
	
		<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.iterator( <span class="hljs-string">'table'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">( settings )</span> {</span>
			<span class="hljs-keyword">var</span> orig      = settings.nTableWrapper.parentNode;
			<span class="hljs-keyword">var</span> classes   = settings.oClasses;
			<span class="hljs-keyword">var</span> table     = settings.nTable;
			<span class="hljs-keyword">var</span> tbody     = settings.nTBody;
			<span class="hljs-keyword">var</span> thead     = settings.nTHead;
			<span class="hljs-keyword">var</span> tfoot     = settings.nTFoot;
			<span class="hljs-keyword">var</span> jqTable   = $(table);
			<span class="hljs-keyword">var</span> jqTbody   = $(tbody);
			<span class="hljs-keyword">var</span> jqWrapper = $(settings.nTableWrapper);
			<span class="hljs-keyword">var</span> rows      = $.map( settings.aoData, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(r)</span> {</span> <span class="hljs-keyword">return</span> r.nTr; } );
			<span class="hljs-keyword">var</span> i, ien;
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Flag to note that the table is currently being destroyed - no action
should be taken</p></div></div><div class="code"><div class="wrapper">			settings.bDestroying = <span class="hljs-literal">true</span>;
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Fire off the destroy callbacks for plug-ins etc</p></div></div><div class="code"><div class="wrapper">			_fnCallbackFire( settings, <span class="hljs-string">"aoDestroyCallback"</span>, <span class="hljs-string">"destroy"</span>, [settings] );
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>If not being removed from the document, make all columns visible</p></div></div><div class="code"><div class="wrapper">			<span class="hljs-keyword">if</span> ( ! remove ) {
				<span class="hljs-keyword">new</span> _Api( settings ).columns().visible( <span class="hljs-literal">true</span> );
			}
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Blitz all <code>DT</code> namespaced events (these are internal events, the
lowercase, <code>dt</code> events are user subscribed and they are responsible
for removing them</p></div></div><div class="code"><div class="wrapper">			jqWrapper.unbind(<span class="hljs-string">'.DT'</span>).find(<span class="hljs-string">':not(tbody *)'</span>).unbind(<span class="hljs-string">'.DT'</span>);
			$(window).unbind(<span class="hljs-string">'.DT-'</span>+settings.sInstance);
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>When scrolling we had to break the table up - restore it</p></div></div><div class="code"><div class="wrapper">			<span class="hljs-keyword">if</span> ( table != thead.parentNode ) {
				jqTable.children(<span class="hljs-string">'thead'</span>).detach();
				jqTable.append( thead );
			}
	
			<span class="hljs-keyword">if</span> ( tfoot &amp;&amp; table != tfoot.parentNode ) {
				jqTable.children(<span class="hljs-string">'tfoot'</span>).detach();
				jqTable.append( tfoot );
			}
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Remove the DataTables generated nodes, events and classes</p></div></div><div class="code"><div class="wrapper">			jqTable.detach();
			jqWrapper.detach();
	
			settings.aaSorting = [];
			settings.aaSortingFixed = [];
			_fnSortingClasses( settings );
	
			$( rows ).removeClass( settings.asStripeClasses.join(<span class="hljs-string">' '</span>) );
	
			$(<span class="hljs-string">'th, td'</span>, thead).removeClass( classes.sSortable+<span class="hljs-string">' '</span>+
				classes.sSortableAsc+<span class="hljs-string">' '</span>+classes.sSortableDesc+<span class="hljs-string">' '</span>+classes.sSortableNone
			);
	
			<span class="hljs-keyword">if</span> ( settings.bJUI ) {
				$(<span class="hljs-string">'th span.'</span>+classes.sSortIcon+ <span class="hljs-string">', td span.'</span>+classes.sSortIcon, thead).detach();
				$(<span class="hljs-string">'th, td'</span>, thead).each( <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
					<span class="hljs-keyword">var</span> wrapper = $(<span class="hljs-string">'div.'</span>+classes.sSortJUIWrapper, <span class="hljs-keyword">this</span>);
					$(<span class="hljs-keyword">this</span>).append( wrapper.contents() );
					wrapper.detach();
				} );
			}
	
			<span class="hljs-keyword">if</span> ( ! remove &amp;&amp; orig ) {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>insertBefore acts like appendChild if !arg[1]</p></div></div><div class="code"><div class="wrapper">				orig.insertBefore( table, settings.nTableReinsertBefore );
			}
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Add the TR elements back into the table in their original order</p></div></div><div class="code"><div class="wrapper">			jqTbody.children().detach();
			jqTbody.append( rows );
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Restore the width of the original table - was read from the style property,
so we can restore directly to that</p></div></div><div class="code"><div class="wrapper">			jqTable
				.css( <span class="hljs-string">'width'</span>, settings.sDestroyWidth )
				.removeClass( classes.sTable );
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>If the were originally stripe classes - then we add them back here.
Note this is not fool proof (for example if not all rows had stripe
classes - but it&#39;s a good effort without getting carried away</p></div></div><div class="code"><div class="wrapper">			ien = settings.asDestroyStripes.length;
	
			<span class="hljs-keyword">if</span> ( ien ) {
				jqTbody.children().each( <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(i)</span> {</span>
					$(<span class="hljs-keyword">this</span>).addClass( settings.asDestroyStripes[i % ien] );
				} );
			}
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Remove the settings object from the settings array </p></div></div><div class="code"><div class="wrapper">			<span class="hljs-keyword">var</span> idx = $.inArray( settings, DataTable.settings );
			<span class="hljs-keyword">if</span> ( idx !== -<span class="hljs-number">1</span> ) {
				DataTable.settings.splice( idx, <span class="hljs-number">1</span> );
			}
		} );
	} );
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Version string for plug-ins to check compatibility. Allowed format is
<code>a.b.c-d</code> where: a:int, b:int, c:int, d:string(dev|beta|alpha). <code>d</code> is used
only for non-release builds. See <a href="http://semver.org/">http://semver.org/</a> for more information.
 @member
 @type string
 @default Version number</p></div></div><div class="code"><div class="wrapper">	DataTable.version = <span class="hljs-string">"1.10.1"</span>;</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Private data store, containing all of the settings objects that are
created for the tables on a given page.</p>
<p>Note that the <code>DataTable.settings</code> object is aliased to
<code>jQuery.fn.dataTableExt</code> through which it may be accessed and
manipulated, or <code>jQuery.fn.dataTable.settings</code>.
 @member
 @type array
 @default []
 @private</p></div></div><div class="code"><div class="wrapper">	DataTable.settings = [];</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Object models container, for the various models that DataTables has
available to it. These models define the objects that are used to hold
the active state and configuration of the table.
 @namespace</p></div></div><div class="code"><div class="wrapper">	DataTable.models = {};
	
	
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Template object for the way in which DataTables holds information about
search information for the global filter and individual column filters.
 @namespace</p></div></div><div class="code"><div class="wrapper">	DataTable.models.oSearch = {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Flag to indicate if the filtering should be case insensitive or not
 @type boolean
 @default true</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-string">"bCaseInsensitive"</span>: <span class="hljs-literal">true</span>,
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Applied search term
 @type string
 @default <i>Empty string</i></p></div></div><div class="code"><div class="wrapper">		<span class="hljs-string">"sSearch"</span>: <span class="hljs-string">""</span>,
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Flag to indicate if the search term should be interpreted as a
regular expression (true) or not (false) and therefore and special
regex characters escaped.
 @type boolean
 @default false</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-string">"bRegex"</span>: <span class="hljs-literal">false</span>,
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Flag to indicate if DataTables is to use its smart filtering or not.
 @type boolean
 @default true</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-string">"bSmart"</span>: <span class="hljs-literal">true</span>
	};
	
	
	
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Template object for the way in which DataTables holds information about
each individual row. This is the object format used for the settings
aoData array.
 @namespace</p></div></div><div class="code"><div class="wrapper">	DataTable.models.oRow = {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>TR element for the row
 @type node
 @default null</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-string">"nTr"</span>: <span class="hljs-literal">null</span>,
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Array of TD elements for each row. This is null until the row has been
created.
 @type array nodes
 @default []</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-string">"anCells"</span>: <span class="hljs-literal">null</span>,
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Data object from the original data source for the row. This is either
an array if using the traditional form of DataTables, or an object if
using mData options. The exact type will depend on the passed in
data from the data source, or will be an array if using DOM a data
source.
 @type array|object
 @default []</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-string">"_aData"</span>: [],
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Sorting data cache - this array is ostensibly the same length as the
number of columns (although each index is generated only as it is
needed), and holds the data that is used for sorting each column in the
row. We do this cache generation at the start of the sort in order that
the formatting of the sort data need be done only once for each cell
per sort. This array should not be read from or written to by anything
other than the master sorting methods.
 @type array
 @default null
 @private</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-string">"_aSortData"</span>: <span class="hljs-literal">null</span>,
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Per cell filtering data cache. As per the sort data cache, used to
increase the performance of the filtering in DataTables
 @type array
 @default null
 @private</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-string">"_aFilterData"</span>: <span class="hljs-literal">null</span>,
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Filtering data cache. This is the same as the cell filtering cache, but
in this case a string rather than an array. This is easily computed with
a join on <code>_aFilterData</code>, but is provided as a cache so the join isn&#39;t
needed on every search (memory traded for performance)
 @type array
 @default null
 @private</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-string">"_sFilterRow"</span>: <span class="hljs-literal">null</span>,
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Cache of the class name that DataTables has applied to the row, so we
can quickly look at this variable rather than needing to do a DOM check
on className for the nTr property.
 @type string
 @default <i>Empty string</i>
 @private</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-string">"_sRowStripe"</span>: <span class="hljs-string">""</span>,
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Denote if the original data source was from the DOM, or the data source
object. This is used for invalidating data, so DataTables can
automatically read data from the original source, unless uninstructed
otherwise.
 @type string
 @default null
 @private</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-string">"src"</span>: <span class="hljs-literal">null</span>
	};
	
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Template object for the column information object in DataTables. This object
is held in the settings aoColumns array and contains all the information that
DataTables needs about each individual column.</p>
<p>Note that this object is related to {@link DataTable.defaults.column}
but this one is the internal data store for DataTables&#39;s cache of columns.
It should NOT be manipulated outside of DataTables. Any configuration should
be done through the initialisation options.
 @namespace</p></div></div><div class="code"><div class="wrapper">	DataTable.models.oColumn = {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Column index. This could be worked out on-the-fly with $.inArray, but it
is faster to just hold it as a variable
 @type integer
 @default null</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-string">"idx"</span>: <span class="hljs-literal">null</span>,
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>A list of the columns that sorting should occur on when this column
is sorted. That this property is an array allows multi-column sorting
to be defined for a column (for example first name / last name columns
would benefit from this). The values are integers pointing to the
columns to be sorted on (typically it will be a single integer pointing
at itself, but that doesn&#39;t need to be the case).
 @type array</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-string">"aDataSort"</span>: <span class="hljs-literal">null</span>,
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Define the sorting directions that are applied to the column, in sequence
as the column is repeatedly sorted upon - i.e. the first value is used
as the sorting direction when the column if first sorted (clicked on).
Sort it again (click again) and it will move on to the next index.
Repeat until loop.
 @type array</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-string">"asSorting"</span>: <span class="hljs-literal">null</span>,
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Flag to indicate if the column is searchable, and thus should be included
in the filtering or not.
 @type boolean</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-string">"bSearchable"</span>: <span class="hljs-literal">null</span>,
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Flag to indicate if the column is sortable or not.
 @type boolean</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-string">"bSortable"</span>: <span class="hljs-literal">null</span>,
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Flag to indicate if the column is currently visible in the table or not
 @type boolean</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-string">"bVisible"</span>: <span class="hljs-literal">null</span>,
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Store for manual type assignment using the <code>column.type</code> option. This
is held in store so we can manipulate the column&#39;s <code>sType</code> property.
 @type string
 @default null
 @private</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-string">"_sManualType"</span>: <span class="hljs-literal">null</span>,
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Flag to indicate if HTML5 data attributes should be used as the data
source for filtering or sorting. True is either are.
 @type boolean
 @default false
 @private</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-string">"_bAttrSrc"</span>: <span class="hljs-literal">false</span>,
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Developer definable function that is called whenever a cell is created (Ajax source,
etc) or processed for input (DOM source). This can be used as a compliment to mRender
allowing you to modify the DOM element (add background colour for example) when the
element is available.
 @type function
 @param {element} nTd The TD node that has been created
 @param {*} sData The Data for the cell
 @param {array|object} oData The data for the whole row
 @param {int} iRow The row index for the aoData data store
 @default null</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-string">"fnCreatedCell"</span>: <span class="hljs-literal">null</span>,
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Function to get data from a cell in a column. You should <b>never</b>
access data directly through _aData internally in DataTables - always use
the method attached to this property. It allows mData to function as
required. This function is automatically assigned by the column
initialisation method
 @type function
 @param {array|object} oData The data array/object for the array
   (i.e. aoData[]._aData)
 @param {string} sSpecific The specific data type you want to get -
   &#39;display&#39;, &#39;type&#39; &#39;filter&#39; &#39;sort&#39;
 @returns {*} The data for the cell from the given row&#39;s data
 @default null</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-string">"fnGetData"</span>: <span class="hljs-literal">null</span>,
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Function to set data for a cell in the column. You should <b>never</b>
set the data directly to _aData internally in DataTables - always use
this method. It allows mData to function as required. This function
is automatically assigned by the column initialisation method
 @type function
 @param {array|object} oData The data array/object for the array
   (i.e. aoData[]._aData)
 @param {*} sValue Value to set
 @default null</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-string">"fnSetData"</span>: <span class="hljs-literal">null</span>,
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Property to read the value for the cells in the column from the data
source array / object. If null, then the default content is used, if a
function is given then the return from the function is used.
 @type function|int|string|null
 @default null</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-string">"mData"</span>: <span class="hljs-literal">null</span>,
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Partner property to mData which is used (only when defined) to get
the data - i.e. it is basically the same as mData, but without the
&#39;set&#39; option, and also the data fed to it is the result from mData.
This is the rendering method to match the data method of mData.
 @type function|int|string|null
 @default null</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-string">"mRender"</span>: <span class="hljs-literal">null</span>,
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Unique header TH/TD element for this column - this is what the sorting
listener is attached to (if sorting is enabled.)
 @type node
 @default null</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-string">"nTh"</span>: <span class="hljs-literal">null</span>,
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Unique footer TH/TD element for this column (if there is one). Not used
in DataTables as such, but can be used for plug-ins to reference the
footer for each column.
 @type node
 @default null</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-string">"nTf"</span>: <span class="hljs-literal">null</span>,
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>The class to apply to all TD elements in the table&#39;s TBODY for the column
 @type string
 @default null</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-string">"sClass"</span>: <span class="hljs-literal">null</span>,
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>When DataTables calculates the column widths to assign to each column,
it finds the longest string in each column and then constructs a
temporary table and reads the widths from that. The problem with this
is that &quot;mmm&quot; is much wider then &quot;iiii&quot;, but the latter is a longer
string - thus the calculation can go wrong (doing it properly and putting
it into an DOM object and measuring that is horribly(!) slow). Thus as
a &quot;work around&quot; we provide this option. It will append its value to the
text that is found to be the longest string for the column - i.e. padding.
 @type string</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-string">"sContentPadding"</span>: <span class="hljs-literal">null</span>,
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Allows a default value to be given for a column&#39;s data, and will be used
whenever a null data source is encountered (this can be because mData
is set to null, or because the data source itself is null).
 @type string
 @default null</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-string">"sDefaultContent"</span>: <span class="hljs-literal">null</span>,
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Name for the column, allowing reference to the column by name as well as
by index (needs a lookup to work by name).
 @type string</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-string">"sName"</span>: <span class="hljs-literal">null</span>,
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Custom sorting data type - defines which of the available plug-ins in
afnSortData the custom sorting will use - if any is defined.
 @type string
 @default std</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-string">"sSortDataType"</span>: <span class="hljs-string">'std'</span>,
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Class to be applied to the header element when sorting on this column
 @type string
 @default null</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-string">"sSortingClass"</span>: <span class="hljs-literal">null</span>,
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Class to be applied to the header element when sorting on this column -
when jQuery UI theming is used.
 @type string
 @default null</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-string">"sSortingClassJUI"</span>: <span class="hljs-literal">null</span>,
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Title of the column - what is seen in the TH element (nTh).
 @type string</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-string">"sTitle"</span>: <span class="hljs-literal">null</span>,
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Column sorting and filtering type
 @type string
 @default null</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-string">"sType"</span>: <span class="hljs-literal">null</span>,
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Width of the column
 @type string
 @default null</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-string">"sWidth"</span>: <span class="hljs-literal">null</span>,
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Width of the column when it was first &quot;encountered&quot;
 @type string
 @default null</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-string">"sWidthOrig"</span>: <span class="hljs-literal">null</span>
	};
	
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Developer note: The properties of the object below are given in Hungarian
notation, that was used as the interface for DataTables prior to v1.10, however
from v1.10 onwards the primary interface is camel case. In order to avoid
breaking backwards compatibility utterly with this change, the Hungarian
version is still, internally the primary interface, but is is not documented</p>
<ul>
<li>hence the @name tags in each doc comment. This allows a Javascript function
to create a map from Hungarian notation to camel case (going the other direction
would require each property to be listed, which would at around 3K to the size
of DataTables, while this method is about a 0.5K hit.</li>
</ul>
<p>Ultimately this does pave the way for Hungarian notation to be dropped
completely, but that is a massive amount of work and will break current
installs (therefore is on-hold until v2).</p></div></div><div class="code"><div class="wrapper">	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Initialisation options that can be given to DataTables at initialisation
time.
 @namespace</p></div></div><div class="code"><div class="wrapper">	DataTable.defaults = {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>An array of data to use for the table, passed in at initialisation which
will be used in preference to any data which is already in the DOM. This is
particularly useful for constructing tables purely in Javascript, for
example with a custom Ajax call.
 @type array
 @default null</p>
<p> @dtopt Option
 @name DataTable.defaults.data</p>
<p> @example
   // Using a 2D array data source
   $(document).ready( function () {
     $(&#39;#example&#39;).dataTable( {
       &quot;data&quot;: [
         [&#39;Trident&#39;, &#39;Internet Explorer 4.0&#39;, &#39;Win 95+&#39;, 4, &#39;X&#39;],
         [&#39;Trident&#39;, &#39;Internet Explorer 5.0&#39;, &#39;Win 95+&#39;, 5, &#39;C&#39;],
       ],
       &quot;columns&quot;: [
         { &quot;title&quot;: &quot;Engine&quot; },
         { &quot;title&quot;: &quot;Browser&quot; },
         { &quot;title&quot;: &quot;Platform&quot; },
         { &quot;title&quot;: &quot;Version&quot; },
         { &quot;title&quot;: &quot;Grade&quot; }
       ]
     } );
   } );</p>
<p> @example
   // Using an array of objects as a data source (<code>data</code>)
   $(document).ready( function () {
     $(&#39;#example&#39;).dataTable( {
       &quot;data&quot;: [
         {
           &quot;engine&quot;:   &quot;Trident&quot;,
           &quot;browser&quot;:  &quot;Internet Explorer 4.0&quot;,
           &quot;platform&quot;: &quot;Win 95+&quot;,
           &quot;version&quot;:  4,
           &quot;grade&quot;:    &quot;X&quot;
         },
         {
           &quot;engine&quot;:   &quot;Trident&quot;,
           &quot;browser&quot;:  &quot;Internet Explorer 5.0&quot;,
           &quot;platform&quot;: &quot;Win 95+&quot;,
           &quot;version&quot;:  5,
           &quot;grade&quot;:    &quot;C&quot;
         }
       ],
       &quot;columns&quot;: [
         { &quot;title&quot;: &quot;Engine&quot;,   &quot;data&quot;: &quot;engine&quot; },
         { &quot;title&quot;: &quot;Browser&quot;,  &quot;data&quot;: &quot;browser&quot; },
         { &quot;title&quot;: &quot;Platform&quot;, &quot;data&quot;: &quot;platform&quot; },
         { &quot;title&quot;: &quot;Version&quot;,  &quot;data&quot;: &quot;version&quot; },
         { &quot;title&quot;: &quot;Grade&quot;,    &quot;data&quot;: &quot;grade&quot; }
       ]
     } );
   } );</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-string">"aaData"</span>: <span class="hljs-literal">null</span>,
	
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>If ordering is enabled, then DataTables will perform a first pass sort on
initialisation. You can define which column(s) the sort is performed
upon, and the sorting direction, with this variable. The <code>sorting</code> array
should contain an array for each column to be sorted initially containing
the column&#39;s index and a direction string (&#39;asc&#39; or &#39;desc&#39;).
 @type array
 @default [[0,&#39;asc&#39;]]</p>
<p> @dtopt Option
 @name DataTable.defaults.order</p>
<p> @example
   // Sort by 3rd column first, and then 4th column
   $(document).ready( function() {
     $(&#39;#example&#39;).dataTable( {
       &quot;order&quot;: [[2,&#39;asc&#39;], [3,&#39;desc&#39;]]
     } );
   } );</p>
<p>   // No initial sorting
   $(document).ready( function() {
     $(&#39;#example&#39;).dataTable( {
       &quot;order&quot;: []
     } );
   } );</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-string">"aaSorting"</span>: [[<span class="hljs-number">0</span>,<span class="hljs-string">'asc'</span>]],
	
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>This parameter is basically identical to the <code>sorting</code> parameter, but
cannot be overridden by user interaction with the table. What this means
is that you could have a column (visible or hidden) which the sorting
will always be forced on first - any sorting after that (from the user)
will then be performed as required. This can be useful for grouping rows
together.
 @type array
 @default null</p>
<p> @dtopt Option
 @name DataTable.defaults.orderFixed</p>
<p> @example
   $(document).ready( function() {
     $(&#39;#example&#39;).dataTable( {
       &quot;orderFixed&quot;: [[0,&#39;asc&#39;]]
     } );
   } )</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-string">"aaSortingFixed"</span>: [],
	
	</div></div></div><div class="segment"><div class="comments doc-section"><div class="wrapper"><p>DataTables can be instructed to load data to display in the table from a
Ajax source. This option defines how that Ajax call is made and where to.</p>
<p>The <code>ajax</code> property has three different modes of operation, depending on
how it is defined. These are:</p>
<ul>
<li><code>string</code> - Set the URL from where the data should be loaded from.</li>
<li><code>object</code> - Define properties for <code>jQuery.ajax</code>.</li>
<li><code>function</code> - Custom data get function</li>
</ul>
<h2 id="-string-"><code>string</code></h2>
<p>As a string, the <code>ajax</code> property simply defines the URL from which
DataTables will load data.</p>
<h2 id="-object-"><code>object</code></h2>
<p>As an object, the parameters in the object are passed to
<a href="http://api.jquery.com/jQuery.ajax/">jQuery.ajax</a> allowing fine control
of the Ajax request. DataTables has a number of default parameters which
you can override using this option. Please refer to the jQuery
documentation for a full description of the options available, although
the following parameters provide additional options in DataTables or
require special consideration:</p>
<ul>
<li><p><code>data</code> - As with jQuery, <code>data</code> can be provided as an object, but it
can also be used as a function to manipulate the data DataTables sends
to the server. The function takes a single parameter, an object of
parameters with the values that DataTables has readied for sending. An
object may be returned which will be merged into the DataTables
defaults, or you can add the items to the object that was passed in and
not return anything from the function. This supersedes <code>fnServerParams</code>
from DataTables 1.9-.</p>
</li>
<li><p><code>dataSrc</code> - By default DataTables will look for the property <code>data</code> (or
<code>aaData</code> for compatibility with DataTables 1.9-) when obtaining data
from an Ajax source or for server-side processing - this parameter
allows that property to be changed. You can use Javascript dotted
object notation to get a data source for multiple levels of nesting, or
it my be used as a function. As a function it takes a single parameter,
the JSON returned from the server, which can be manipulated as
required, with the returned value being that used by DataTables as the
data source for the table. This supersedes <code>sAjaxDataProp</code> from
DataTables 1.9-.</p>
</li>
<li><p><code>success</code> - Should not be overridden it is used internally in
DataTables. To manipulate / transform the data returned by the server
use <code>ajax.dataSrc</code>, or use <code>ajax</code> as a function (see below).</p>
</li>
</ul>
<h2 id="-function-"><code>function</code></h2>
<p>As a function, making the Ajax call is left up to yourself allowing
complete control of the Ajax request. Indeed, if desired, a method other
than Ajax could be used to obtain the required data, such as Web storage
or an AIR database.</p>
<p>The function is given four parameters and no return is required. The
parameters are:</p>
<ol>
<li><em>object</em> - Data to send to the server</li>
<li><em>function</em> - Callback function that must be executed when the required
data has been obtained. That data should be passed into the callback
as the only parameter</li>
<li><em>object</em> - DataTables settings object for the table</li>
</ol>
<p>Note that this supersedes <code>fnServerData</code> from DataTables 1.9-.</p>
<p> @type string|object|function
 @default null</p>
<p> @dtopt Option
 @name DataTable.defaults.ajax
 @since 1.10.0</p>
<p>Example:</p>
<pre><code>// Get JSON data from a file via Ajax.
// Note DataTables expects data in the form `{ data: [ ...data... ] }` by default).
$(&#39;#example&#39;).dataTable( {
  &quot;ajax&quot;: &quot;data.json&quot;
} );</code></pre>
<p>Example:</p>
<pre><code>// Get JSON data from a file via Ajax, using `dataSrc` to change
// `data` to `tableData` (i.e. `{ tableData: [ ...data... ] }`)
$(&#39;#example&#39;).dataTable( {
  &quot;ajax&quot;: {
    &quot;url&quot;: &quot;data.json&quot;,
    &quot;dataSrc&quot;: &quot;tableData&quot;
  }
} );</code></pre>
<p>Example:</p>
<pre><code>// Get JSON data from a file via Ajax, using `dataSrc` to read data
// from a plain array rather than an array in an object
$(&#39;#example&#39;).dataTable( {
  &quot;ajax&quot;: {
    &quot;url&quot;: &quot;data.json&quot;,
    &quot;dataSrc&quot;: &quot;&quot;
  }
} );</code></pre>
<p>Example:</p>
<pre><code>// Manipulate the data returned from the server - add a link to data
// (note this can, should, be done using `render` for the column - this
// is just a simple example of how the data can be manipulated).
$(&#39;#example&#39;).dataTable( {
  &quot;ajax&quot;: {
    &quot;url&quot;: &quot;data.json&quot;,
    &quot;dataSrc&quot;: function ( json ) {
      for ( var i=0, ien=json.length ; i&lt;ien ; i++ ) {
        json[i][0] = &#39;&lt;a href=&quot;/message/&#39;+json[i][0]+&#39;&gt;View message&lt;/a&gt;&#39;;
      }
      return json;
    }
  }
} );</code></pre>
<p>Example:</p>
<pre><code>// Add data to the request
$(&#39;#example&#39;).dataTable( {
  &quot;ajax&quot;: {
    &quot;url&quot;: &quot;data.json&quot;,
    &quot;data&quot;: function ( d ) {
      return {
        &quot;extra_search&quot;: $(&#39;#extra&#39;).val()
      };
    }
  }
} );</code></pre>
<p>Example:</p>
<pre><code>// Send request as POST
$(&#39;#example&#39;).dataTable( {
  &quot;ajax&quot;: {
    &quot;url&quot;: &quot;data.json&quot;,
    &quot;type&quot;: &quot;POST&quot;
  }
} );</code></pre>
<p>Example:</p>
<pre><code>// Get the data from localStorage (could interface with a form for
// adding, editing and removing rows).
$(&#39;#example&#39;).dataTable( {
  &quot;ajax&quot;: function (data, callback, settings) {
    callback(
      JSON.parse( localStorage.getItem(&#39;dataTablesData&#39;) )
    );
  }
} );</code></pre></div></div><div class="code"><div class="wrapper">		<span class="hljs-string">"ajax"</span>: <span class="hljs-literal">null</span>,
	
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>This parameter allows you to readily specify the entries in the length drop
down menu that DataTables shows when pagination is enabled. It can be
either a 1D array of options which will be used for both the displayed
option and the value, or a 2D array which will use the array in the first
position as the value, and the array in the second position as the
displayed options (useful for language strings such as &#39;All&#39;).</p>
<p>Note that the <code>pageLength</code> property will be automatically set to the
first value given in this array, unless <code>pageLength</code> is also provided.
 @type array
 @default [ 10, 25, 50, 100 ]</p>
<p> @dtopt Option
 @name DataTable.defaults.lengthMenu</p>
<p> @example
   $(document).ready( function() {
     $(&#39;#example&#39;).dataTable( {
       &quot;lengthMenu&quot;: [[10, 25, 50, -1], [10, 25, 50, &quot;All&quot;]]
     } );
   } );</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-string">"aLengthMenu"</span>: [ <span class="hljs-number">10</span>, <span class="hljs-number">25</span>, <span class="hljs-number">50</span>, <span class="hljs-number">100</span> ],
	
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>The <code>columns</code> option in the initialisation parameter allows you to define
details about the way individual columns behave. For a full list of
column options that can be set, please see
{@link DataTable.defaults.column}. Note that if you use <code>columns</code> to
define your columns, you must have an entry in the array for every single
column that you have in your table (these can be null if you don&#39;t which
to specify any options).
 @member</p>
<p> @name DataTable.defaults.column</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-string">"aoColumns"</span>: <span class="hljs-literal">null</span>,
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Very similar to <code>columns</code>, <code>columnDefs</code> allows you to target a specific
column, multiple columns, or all columns, using the <code>targets</code> property of
each object in the array. This allows great flexibility when creating
tables, as the <code>columnDefs</code> arrays can be of any length, targeting the
columns you specifically want. <code>columnDefs</code> may use any of the column
options available: {@link DataTable.defaults.column}, but it <em>must</em>
have <code>targets</code> defined in each object in the array. Values in the <code>targets</code>
array may be:
  <ul>
    <li>a string - class name will be matched on the TH for the column</li>
    <li>0 or a positive integer - column index counting from the left</li>
    <li>a negative integer - column index counting from the right</li>
    <li>the string &quot;_all&quot; - all columns (i.e. assign a default)</li>
  </ul>
 @member</p>
<p> @name DataTable.defaults.columnDefs</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-string">"aoColumnDefs"</span>: <span class="hljs-literal">null</span>,
	
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Basically the same as <code>search</code>, this parameter defines the individual column
filtering state at initialisation time. The array must be of the same size
as the number of columns, and each element be an object with the parameters
<code>search</code> and <code>escapeRegex</code> (the latter is optional). &#39;null&#39; is also
accepted and the default will be used.
 @type array
 @default []</p>
<p> @dtopt Option
 @name DataTable.defaults.searchCols</p>
<p> @example
   $(document).ready( function() {
     $(&#39;#example&#39;).dataTable( {
       &quot;searchCols&quot;: [
         null,
         { &quot;search&quot;: &quot;My filter&quot; },
         null,
         { &quot;search&quot;: &quot;^[0-9]&quot;, &quot;escapeRegex&quot;: false }
       ]
     } );
   } )</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-string">"aoSearchCols"</span>: [],
	
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>An array of CSS classes that should be applied to displayed rows. This
array may be of any length, and DataTables will apply each class
sequentially, looping when required.
 @type array
 @default null <i>Will take the values determined by the <code>oClasses.stripe*</code>
   options</i></p>
<p> @dtopt Option
 @name DataTable.defaults.stripeClasses</p>
<p> @example
   $(document).ready( function() {
     $(&#39;#example&#39;).dataTable( {
       &quot;stripeClasses&quot;: [ &#39;strip1&#39;, &#39;strip2&#39;, &#39;strip3&#39; ]
     } );
   } )</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-string">"asStripeClasses"</span>: <span class="hljs-literal">null</span>,
	
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Enable or disable automatic column width calculation. This can be disabled
as an optimisation (it takes some time to calculate the widths) if the
tables widths are passed in using <code>columns</code>.
 @type boolean
 @default true</p>
<p> @dtopt Features
 @name DataTable.defaults.autoWidth</p>
<p> @example
   $(document).ready( function () {
     $(&#39;#example&#39;).dataTable( {
       &quot;autoWidth&quot;: false
     } );
   } );</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-string">"bAutoWidth"</span>: <span class="hljs-literal">true</span>,
	
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Deferred rendering can provide DataTables with a huge speed boost when you
are using an Ajax or JS data source for the table. This option, when set to
true, will cause DataTables to defer the creation of the table elements for
each row until they are needed for a draw - saving a significant amount of
time.
 @type boolean
 @default false</p>
<p> @dtopt Features
 @name DataTable.defaults.deferRender</p>
<p> @example
   $(document).ready( function() {
     $(&#39;#example&#39;).dataTable( {
       &quot;ajax&quot;: &quot;sources/arrays.txt&quot;,
       &quot;deferRender&quot;: true
     } );
   } );</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-string">"bDeferRender"</span>: <span class="hljs-literal">false</span>,
	
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Replace a DataTable which matches the given selector and replace it with
one which has the properties of the new initialisation object passed. If no
table matches the selector, then the new DataTable will be constructed as
per normal.
 @type boolean
 @default false</p>
<p> @dtopt Options
 @name DataTable.defaults.destroy</p>
<p> @example
   $(document).ready( function() {
     $(&#39;#example&#39;).dataTable( {
       &quot;srollY&quot;: &quot;200px&quot;,
       &quot;paginate&quot;: false
     } );</p>
<pre><code> // Some time later....
 $(&#39;#example&#39;).dataTable( {
   &quot;filter&quot;: false,
   &quot;destroy&quot;: true
 } );</code></pre>
<p>   } );</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-string">"bDestroy"</span>: <span class="hljs-literal">false</span>,
	
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Enable or disable filtering of data. Filtering in DataTables is &quot;smart&quot; in
that it allows the end user to input multiple words (space separated) and
will match a row containing those words, even if not in the order that was
specified (this allow matching across multiple columns). Note that if you
wish to use filtering in DataTables this must remain &#39;true&#39; - to remove the
default filtering input box and retain filtering abilities, please use
{@link DataTable.defaults.dom}.
 @type boolean
 @default true</p>
<p> @dtopt Features
 @name DataTable.defaults.searching</p>
<p> @example
   $(document).ready( function () {
     $(&#39;#example&#39;).dataTable( {
       &quot;searching&quot;: false
     } );
   } );</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-string">"bFilter"</span>: <span class="hljs-literal">true</span>,
	
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Enable or disable the table information display. This shows information
about the data that is currently visible on the page, including information
about filtered data if that action is being performed.
 @type boolean
 @default true</p>
<p> @dtopt Features
 @name DataTable.defaults.info</p>
<p> @example
   $(document).ready( function () {
     $(&#39;#example&#39;).dataTable( {
       &quot;info&quot;: false
     } );
   } );</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-string">"bInfo"</span>: <span class="hljs-literal">true</span>,
	
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Enable jQuery UI ThemeRoller support (required as ThemeRoller requires some
slightly different and additional mark-up from what DataTables has
traditionally used).
 @type boolean
 @default false</p>
<p> @dtopt Features
 @name DataTable.defaults.jQueryUI</p>
<p> @example
   $(document).ready( function() {
     $(&#39;#example&#39;).dataTable( {
       &quot;jQueryUI&quot;: true
     } );
   } );</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-string">"bJQueryUI"</span>: <span class="hljs-literal">false</span>,
	
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Allows the end user to select the size of a formatted page from a select
menu (sizes are 10, 25, 50 and 100). Requires pagination (<code>paginate</code>).
 @type boolean
 @default true</p>
<p> @dtopt Features
 @name DataTable.defaults.lengthChange</p>
<p> @example
   $(document).ready( function () {
     $(&#39;#example&#39;).dataTable( {
       &quot;lengthChange&quot;: false
     } );
   } );</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-string">"bLengthChange"</span>: <span class="hljs-literal">true</span>,
	
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Enable or disable pagination.
 @type boolean
 @default true</p>
<p> @dtopt Features
 @name DataTable.defaults.paging</p>
<p> @example
   $(document).ready( function () {
     $(&#39;#example&#39;).dataTable( {
       &quot;paging&quot;: false
     } );
   } );</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-string">"bPaginate"</span>: <span class="hljs-literal">true</span>,
	
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Enable or disable the display of a &#39;processing&#39; indicator when the table is
being processed (e.g. a sort). This is particularly useful for tables with
large amounts of data where it can take a noticeable amount of time to sort
the entries.
 @type boolean
 @default false</p>
<p> @dtopt Features
 @name DataTable.defaults.processing</p>
<p> @example
   $(document).ready( function () {
     $(&#39;#example&#39;).dataTable( {
       &quot;processing&quot;: true
     } );
   } );</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-string">"bProcessing"</span>: <span class="hljs-literal">false</span>,
	
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Retrieve the DataTables object for the given selector. Note that if the
table has already been initialised, this parameter will cause DataTables
to simply return the object that has already been set up - it will not take
account of any changes you might have made to the initialisation object
passed to DataTables (setting this parameter to true is an acknowledgement
that you understand this). <code>destroy</code> can be used to reinitialise a table if
you need.
 @type boolean
 @default false</p>
<p> @dtopt Options
 @name DataTable.defaults.retrieve</p>
<p> @example
   $(document).ready( function() {
     initTable();
     tableActions();
   } );</p>
<p>   function initTable ()
   {
     return $(&#39;#example&#39;).dataTable( {
       &quot;scrollY&quot;: &quot;200px&quot;,
       &quot;paginate&quot;: false,
       &quot;retrieve&quot;: true
     } );
   }</p>
<p>   function tableActions ()
   {
     var table = initTable();
     // perform API operations with oTable
   }</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-string">"bRetrieve"</span>: <span class="hljs-literal">false</span>,
	
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>When vertical (y) scrolling is enabled, DataTables will force the height of
the table&#39;s viewport to the given height at all times (useful for layout).
However, this can look odd when filtering data down to a small data set,
and the footer is left &quot;floating&quot; further down. This parameter (when
enabled) will cause DataTables to collapse the table&#39;s viewport down when
the result set will fit within the given Y height.
 @type boolean
 @default false</p>
<p> @dtopt Options
 @name DataTable.defaults.scrollCollapse</p>
<p> @example
   $(document).ready( function() {
     $(&#39;#example&#39;).dataTable( {
       &quot;scrollY&quot;: &quot;200&quot;,
       &quot;scrollCollapse&quot;: true
     } );
   } );</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-string">"bScrollCollapse"</span>: <span class="hljs-literal">false</span>,
	
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Configure DataTables to use server-side processing. Note that the
<code>ajax</code> parameter must also be given in order to give DataTables a
source to obtain the required data for each draw.
 @type boolean
 @default false</p>
<p> @dtopt Features
 @dtopt Server-side
 @name DataTable.defaults.serverSide</p>
<p> @example
   $(document).ready( function () {
     $(&#39;#example&#39;).dataTable( {
       &quot;serverSide&quot;: true,
       &quot;ajax&quot;: &quot;xhr.php&quot;
     } );
   } );</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-string">"bServerSide"</span>: <span class="hljs-literal">false</span>,
	
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Enable or disable sorting of columns. Sorting of individual columns can be
disabled by the <code>sortable</code> option for each column.
 @type boolean
 @default true</p>
<p> @dtopt Features
 @name DataTable.defaults.ordering</p>
<p> @example
   $(document).ready( function () {
     $(&#39;#example&#39;).dataTable( {
       &quot;ordering&quot;: false
     } );
   } );</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-string">"bSort"</span>: <span class="hljs-literal">true</span>,
	
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Enable or display DataTables&#39; ability to sort multiple columns at the
same time (activated by shift-click by the user).
 @type boolean
 @default true</p>
<p> @dtopt Options
 @name DataTable.defaults.orderMulti</p>
<p> @example
   // Disable multiple column sorting ability
   $(document).ready( function () {
     $(&#39;#example&#39;).dataTable( {
       &quot;orderMulti&quot;: false
     } );
   } );</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-string">"bSortMulti"</span>: <span class="hljs-literal">true</span>,
	
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Allows control over whether DataTables should use the top (true) unique
cell that is found for a single column, or the bottom (false - default).
This is useful when using complex headers.
 @type boolean
 @default false</p>
<p> @dtopt Options
 @name DataTable.defaults.orderCellsTop</p>
<p> @example
   $(document).ready( function() {
     $(&#39;#example&#39;).dataTable( {
       &quot;orderCellsTop&quot;: true
     } );
   } );</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-string">"bSortCellsTop"</span>: <span class="hljs-literal">false</span>,
	
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Enable or disable the addition of the classes <code>sorting\_1</code>, <code>sorting\_2</code> and
<code>sorting\_3</code> to the columns which are currently being sorted on. This is
presented as a feature switch as it can increase processing time (while
classes are removed and added) so for large data sets you might want to
turn this off.
 @type boolean
 @default true</p>
<p> @dtopt Features
 @name DataTable.defaults.orderClasses</p>
<p> @example
   $(document).ready( function () {
     $(&#39;#example&#39;).dataTable( {
       &quot;orderClasses&quot;: false
     } );
   } );</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-string">"bSortClasses"</span>: <span class="hljs-literal">true</span>,
	
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Enable or disable state saving. When enabled HTML5 <code>localStorage</code> will be
used to save table display information such as pagination information,
display length, filtering and sorting. As such when the end user reloads
the page the display display will match what thy had previously set up.</p>
<p>Due to the use of <code>localStorage</code> the default state saving is not supported
in IE6 or 7. If state saving is required in those browsers, use
<code>stateSaveCallback</code> to provide a storage solution such as cookies.
 @type boolean
 @default false</p>
<p> @dtopt Features
 @name DataTable.defaults.stateSave</p>
<p> @example
   $(document).ready( function () {
     $(&#39;#example&#39;).dataTable( {
       &quot;stateSave&quot;: true
     } );
   } );</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-string">"bStateSave"</span>: <span class="hljs-literal">false</span>,
	
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>This function is called when a TR element is created (and all TD child
elements have been inserted), or registered if using a DOM source, allowing
manipulation of the TR element (adding classes etc).
 @type function
 @param {node} row &quot;TR&quot; element for the current row
 @param {array} data Raw data array for this row
 @param {int} dataIndex The index of this row in the internal aoData array</p>
<p> @dtopt Callbacks
 @name DataTable.defaults.createdRow</p>
<p> @example
   $(document).ready( function() {
     $(&#39;#example&#39;).dataTable( {
       &quot;createdRow&quot;: function( row, data, dataIndex ) {
         // Bold the grade for all &#39;A&#39; grade browsers
         if ( data[4] == &quot;A&quot; )
         {
           $(&#39;td:eq(4)&#39;, row).html( &#39;<b>A</b>&#39; );
         }
       }
     } );
   } );</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-string">"fnCreatedRow"</span>: <span class="hljs-literal">null</span>,
	
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>This function is called on every &#39;draw&#39; event, and allows you to
dynamically modify any aspect you want about the created DOM.
 @type function
 @param {object} settings DataTables settings object</p>
<p> @dtopt Callbacks
 @name DataTable.defaults.drawCallback</p>
<p> @example
   $(document).ready( function() {
     $(&#39;#example&#39;).dataTable( {
       &quot;drawCallback&quot;: function( settings ) {
         alert( &#39;DataTables has redrawn the table&#39; );
       }
     } );
   } );</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-string">"fnDrawCallback"</span>: <span class="hljs-literal">null</span>,
	
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Identical to fnHeaderCallback() but for the table footer this function
allows you to modify the table footer on every &#39;draw&#39; event.
 @type function
 @param {node} foot &quot;TR&quot; element for the footer
 @param {array} data Full table data (as derived from the original HTML)
 @param {int} start Index for the current display starting point in the
   display array
 @param {int} end Index for the current display ending point in the
   display array
 @param {array int} display Index array to translate the visual position
   to the full data array</p>
<p> @dtopt Callbacks
 @name DataTable.defaults.footerCallback</p>
<p> @example
   $(document).ready( function() {
     $(&#39;#example&#39;).dataTable( {
       &quot;footerCallback&quot;: function( tfoot, data, start, end, display ) {
         tfoot.getElementsByTagName(&#39;th&#39;)[0].innerHTML = &quot;Starting index is &quot;+start;
       }
     } );
   } )</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-string">"fnFooterCallback"</span>: <span class="hljs-literal">null</span>,
	
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>When rendering large numbers in the information element for the table
(i.e. &quot;Showing 1 to 10 of 57 entries&quot;) DataTables will render large numbers
to have a comma separator for the &#39;thousands&#39; units (e.g. 1 million is
rendered as &quot;1,000,000&quot;) to help readability for the end user. This
function will override the default method DataTables uses.
 @type function
 @member
 @param {int} toFormat number to be formatted
 @returns {string} formatted string for DataTables to show the number</p>
<p> @dtopt Callbacks
 @name DataTable.defaults.formatNumber</p>
<p> @example
   // Format a number using a single quote for the separator (note that
   // this can also be done with the language.thousands option)
   $(document).ready( function() {
     $(&#39;#example&#39;).dataTable( {
       &quot;formatNumber&quot;: function ( toFormat ) {
         return toFormat.toString().replace(
           /\B(?=(\d{3})+(?!\d))/g, &quot;&#39;&quot;
         );
       };
     } );
   } );</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-string">"fnFormatNumber"</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">( toFormat )</span> {</span>
			<span class="hljs-keyword">return</span> toFormat.toString().replace(
				<span class="hljs-regexp">/\B(?=(\d{3})+(?!\d))/g</span>,
				<span class="hljs-keyword">this</span>.oLanguage.sThousands
			);
		},
	
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>This function is called on every &#39;draw&#39; event, and allows you to
dynamically modify the header row. This can be used to calculate and
display useful information about the table.
 @type function
 @param {node} head &quot;TR&quot; element for the header
 @param {array} data Full table data (as derived from the original HTML)
 @param {int} start Index for the current display starting point in the
   display array
 @param {int} end Index for the current display ending point in the
   display array
 @param {array int} display Index array to translate the visual position
   to the full data array</p>
<p> @dtopt Callbacks
 @name DataTable.defaults.headerCallback</p>
<p> @example
   $(document).ready( function() {
     $(&#39;#example&#39;).dataTable( {
       &quot;fheaderCallback&quot;: function( head, data, start, end, display ) {
         head.getElementsByTagName(&#39;th&#39;)[0].innerHTML = &quot;Displaying &quot;+(end-start)+&quot; records&quot;;
       }
     } );
   } )</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-string">"fnHeaderCallback"</span>: <span class="hljs-literal">null</span>,
	
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>The information element can be used to convey information about the current
state of the table. Although the internationalisation options presented by
DataTables are quite capable of dealing with most customisations, there may
be times where you wish to customise the string further. This callback
allows you to do exactly that.
 @type function
 @param {object} oSettings DataTables settings object
 @param {int} start Starting position in data for the draw
 @param {int} end End position in data for the draw
 @param {int} max Total number of rows in the table (regardless of
   filtering)
 @param {int} total Total number of rows in the data set, after filtering
 @param {string} pre The string that DataTables has formatted using it&#39;s
   own rules
 @returns {string} The string to be displayed in the information element.</p>
<p> @dtopt Callbacks
 @name DataTable.defaults.infoCallback</p>
<p> @example
   $(&#39;#example&#39;).dataTable( {
     &quot;infoCallback&quot;: function( settings, start, end, max, total, pre ) {
       return start +&quot; to &quot;+ end;
     }
   } );</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-string">"fnInfoCallback"</span>: <span class="hljs-literal">null</span>,
	
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Called when the table has been initialised. Normally DataTables will
initialise sequentially and there will be no need for this function,
however, this does not hold true when using external language information
since that is obtained using an async XHR call.
 @type function
 @param {object} settings DataTables settings object
 @param {object} json The JSON object request from the server - only
   present if client-side Ajax sourced data is used</p>
<p> @dtopt Callbacks
 @name DataTable.defaults.initComplete</p>
<p> @example
   $(document).ready( function() {
     $(&#39;#example&#39;).dataTable( {
       &quot;initComplete&quot;: function(settings, json) {
         alert( &#39;DataTables has finished its initialisation.&#39; );
       }
     } );
   } )</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-string">"fnInitComplete"</span>: <span class="hljs-literal">null</span>,
	
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Called at the very start of each table draw and can be used to cancel the
draw by returning false, any other return (including undefined) results in
the full draw occurring).
 @type function
 @param {object} settings DataTables settings object
 @returns {boolean} False will cancel the draw, anything else (including no
   return) will allow it to complete.</p>
<p> @dtopt Callbacks
 @name DataTable.defaults.preDrawCallback</p>
<p> @example
   $(document).ready( function() {
     $(&#39;#example&#39;).dataTable( {
       &quot;preDrawCallback&quot;: function( settings ) {
         if ( $(&#39;#test&#39;).val() == 1 ) {
           return false;
         }
       }
     } );
   } );</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-string">"fnPreDrawCallback"</span>: <span class="hljs-literal">null</span>,
	
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>This function allows you to &#39;post process&#39; each row after it have been
generated for each table draw, but before it is rendered on screen. This
function might be used for setting the row class name etc.
 @type function
 @param {node} row &quot;TR&quot; element for the current row
 @param {array} data Raw data array for this row
 @param {int} displayIndex The display index for the current table draw
 @param {int} displayIndexFull The index of the data in the full list of
   rows (after filtering)</p>
<p> @dtopt Callbacks
 @name DataTable.defaults.rowCallback</p>
<p> @example
   $(document).ready( function() {
     $(&#39;#example&#39;).dataTable( {
       &quot;rowCallback&quot;: function( row, data, displayIndex, displayIndexFull ) {
         // Bold the grade for all &#39;A&#39; grade browsers
         if ( data[4] == &quot;A&quot; ) {
           $(&#39;td:eq(4)&#39;, row).html( &#39;<b>A</b>&#39; );
         }
       }
     } );
   } );</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-string">"fnRowCallback"</span>: <span class="hljs-literal">null</span>,
	
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p><strong>Deprecated</strong> The functionality provided by this parameter has now been
superseded by that provided through <code>ajax</code>, which should be used instead.</p>
<p>This parameter allows you to override the default function which obtains
the data from the server so something more suitable for your application.
For example you could use POST data, or pull information from a Gears or
AIR database.
 @type function
 @member
 @param {string} source HTTP source to obtain the data from (<code>ajax</code>)
 @param {array} data A key/value pair object containing the data to send
   to the server
 @param {function} callback to be called on completion of the data get
   process that will draw the data on the page.
 @param {object} settings DataTables settings object</p>
<p> @dtopt Callbacks
 @dtopt Server-side
 @name DataTable.defaults.serverData</p>
<p> @deprecated 1.10. Please use <code>ajax</code> for this functionality now.</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-string">"fnServerData"</span>: <span class="hljs-literal">null</span>,
	
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p><strong>Deprecated</strong> The functionality provided by this parameter has now been
superseded by that provided through <code>ajax</code>, which should be used instead.</p>
<p> It is often useful to send extra data to the server when making an Ajax
request - for example custom filtering information, and this callback
function makes it trivial to send extra information to the server. The
passed in parameter is the data set that has been constructed by
DataTables, and you can add to this or modify it as you require.
 @type function
 @param {array} data Data array (array of objects which are name/value
   pairs) that has been constructed by DataTables and will be sent to the
   server. In the case of Ajax sourced data with server-side processing
   this will be an empty array, for server-side processing there will be a
   significant number of parameters!
 @returns {undefined} Ensure that you modify the data array passed in,
   as this is passed by reference.</p>
<p> @dtopt Callbacks
 @dtopt Server-side
 @name DataTable.defaults.serverParams</p>
<p> @deprecated 1.10. Please use <code>ajax</code> for this functionality now.</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-string">"fnServerParams"</span>: <span class="hljs-literal">null</span>,
	
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Load the table state. With this function you can define from where, and how, the
state of a table is loaded. By default DataTables will load from <code>localStorage</code>
but you might wish to use a server-side database or cookies.
 @type function
 @member
 @param {object} settings DataTables settings object
 @return {object} The DataTables state object to be loaded</p>
<p> @dtopt Callbacks
 @name DataTable.defaults.stateLoadCallback</p>
<p> @example
   $(document).ready( function() {
     $(&#39;#example&#39;).dataTable( {
       &quot;stateSave&quot;: true,
       &quot;stateLoadCallback&quot;: function (settings) {
         var o;</p>
<pre><code>     // Send an Ajax request to the server to get the data. Note that
     // this is a synchronous request.
     $.ajax( {
       &quot;url&quot;: &quot;/state_load&quot;,
       &quot;async&quot;: false,
       &quot;dataType&quot;: &quot;json&quot;,
       &quot;success&quot;: function (json) {
         o = json;
       }
     } );

     return o;
   }
 } );</code></pre>
<p>   } );</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-string">"fnStateLoadCallback"</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">( settings )</span> {</span>
			<span class="hljs-keyword">try</span> {
				<span class="hljs-keyword">return</span> <span class="hljs-built_in">JSON</span>.parse(
					(settings.iStateDuration === -<span class="hljs-number">1</span> ? sessionStorage : localStorage).getItem(
						<span class="hljs-string">'DataTables_'</span>+settings.sInstance+<span class="hljs-string">'_'</span>+location.pathname
					)
				);
			} <span class="hljs-keyword">catch</span> (e) {}
		},
	
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Callback which allows modification of the saved state prior to loading that state.
This callback is called when the table is loading state from the stored data, but
prior to the settings object being modified by the saved state. Note that for
plug-in authors, you should use the <code>stateLoadParams</code> event to load parameters for
a plug-in.
 @type function
 @param {object} settings DataTables settings object
 @param {object} data The state object that is to be loaded</p>
<p> @dtopt Callbacks
 @name DataTable.defaults.stateLoadParams</p>
<p> @example
   // Remove a saved filter, so filtering is never loaded
   $(document).ready( function() {
     $(&#39;#example&#39;).dataTable( {
       &quot;stateSave&quot;: true,
       &quot;stateLoadParams&quot;: function (settings, data) {
         data.oSearch.sSearch = &quot;&quot;;
       }
     } );
   } );</p>
<p> @example
   // Disallow state loading by returning false
   $(document).ready( function() {
     $(&#39;#example&#39;).dataTable( {
       &quot;stateSave&quot;: true,
       &quot;stateLoadParams&quot;: function (settings, data) {
         return false;
       }
     } );
   } );</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-string">"fnStateLoadParams"</span>: <span class="hljs-literal">null</span>,
	
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Callback that is called when the state has been loaded from the state saving method
and the DataTables settings object has been modified as a result of the loaded state.
 @type function
 @param {object} settings DataTables settings object
 @param {object} data The state object that was loaded</p>
<p> @dtopt Callbacks
 @name DataTable.defaults.stateLoaded</p>
<p> @example
   // Show an alert with the filtering value that was saved
   $(document).ready( function() {
     $(&#39;#example&#39;).dataTable( {
       &quot;stateSave&quot;: true,
       &quot;stateLoaded&quot;: function (settings, data) {
         alert( &#39;Saved filter was: &#39;+data.oSearch.sSearch );
       }
     } );
   } );</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-string">"fnStateLoaded"</span>: <span class="hljs-literal">null</span>,
	
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Save the table state. This function allows you to define where and how the state
information for the table is stored By default DataTables will use <code>localStorage</code>
but you might wish to use a server-side database or cookies.
 @type function
 @member
 @param {object} settings DataTables settings object
 @param {object} data The state object to be saved</p>
<p> @dtopt Callbacks
 @name DataTable.defaults.stateSaveCallback</p>
<p> @example
   $(document).ready( function() {
     $(&#39;#example&#39;).dataTable( {
       &quot;stateSave&quot;: true,
       &quot;stateSaveCallback&quot;: function (settings, data) {
         // Send an Ajax request to the server with the state object
         $.ajax( {
           &quot;url&quot;: &quot;/state_save&quot;,
           &quot;data&quot;: data,
           &quot;dataType&quot;: &quot;json&quot;,
           &quot;method&quot;: &quot;POST&quot;
           &quot;success&quot;: function () {}
         } );
       }
     } );
   } );</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-string">"fnStateSaveCallback"</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">( settings, data )</span> {</span>
			<span class="hljs-keyword">try</span> {
				(settings.iStateDuration === -<span class="hljs-number">1</span> ? sessionStorage : localStorage).setItem(
					<span class="hljs-string">'DataTables_'</span>+settings.sInstance+<span class="hljs-string">'_'</span>+location.pathname,
					<span class="hljs-built_in">JSON</span>.stringify( data )
				);
			} <span class="hljs-keyword">catch</span> (e) {}
		},
	
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Callback which allows modification of the state to be saved. Called when the table
has changed state a new state save is required. This method allows modification of
the state saving object prior to actually doing the save, including addition or
other state properties or modification. Note that for plug-in authors, you should
use the <code>stateSaveParams</code> event to save parameters for a plug-in.
 @type function
 @param {object} settings DataTables settings object
 @param {object} data The state object to be saved</p>
<p> @dtopt Callbacks
 @name DataTable.defaults.stateSaveParams</p>
<p> @example
   // Remove a saved filter, so filtering is never saved
   $(document).ready( function() {
     $(&#39;#example&#39;).dataTable( {
       &quot;stateSave&quot;: true,
       &quot;stateSaveParams&quot;: function (settings, data) {
         data.oSearch.sSearch = &quot;&quot;;
       }
     } );
   } );</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-string">"fnStateSaveParams"</span>: <span class="hljs-literal">null</span>,
	
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Duration for which the saved state information is considered valid. After this period
has elapsed the state will be returned to the default.
Value is given in seconds.
 @type int
 @default 7200 <i>(2 hours)</i></p>
<p> @dtopt Options
 @name DataTable.defaults.stateDuration</p>
<p> @example
   $(document).ready( function() {
     $(&#39;#example&#39;).dataTable( {
       &quot;stateDuration&quot;: 60<em>60</em>24; // 1 day
     } );
   } )</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-string">"iStateDuration"</span>: <span class="hljs-number">7200</span>,
	
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>When enabled DataTables will not make a request to the server for the first
page draw - rather it will use the data already on the page (no sorting etc
will be applied to it), thus saving on an XHR at load time. <code>deferLoading</code>
is used to indicate that deferred loading is required, but it is also used
to tell DataTables how many records there are in the full table (allowing
the information element and pagination to be displayed correctly). In the case
where a filtering is applied to the table on initial load, this can be
indicated by giving the parameter as an array, where the first element is
the number of records available after filtering and the second element is the
number of records without filtering (allowing the table information element
to be shown correctly).
 @type int | array
 @default null</p>
<p> @dtopt Options
 @name DataTable.defaults.deferLoading</p>
<p> @example
   // 57 records available in the table, no filtering applied
   $(document).ready( function() {
     $(&#39;#example&#39;).dataTable( {
       &quot;serverSide&quot;: true,
       &quot;ajax&quot;: &quot;scripts/server_processing.php&quot;,
       &quot;deferLoading&quot;: 57
     } );
   } );</p>
<p> @example
   // 57 records after filtering, 100 without filtering (an initial filter applied)
   $(document).ready( function() {
     $(&#39;#example&#39;).dataTable( {
       &quot;serverSide&quot;: true,
       &quot;ajax&quot;: &quot;scripts/server_processing.php&quot;,
       &quot;deferLoading&quot;: [ 57, 100 ],
       &quot;search&quot;: {
         &quot;search&quot;: &quot;my_filter&quot;
       }
     } );
   } );</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-string">"iDeferLoading"</span>: <span class="hljs-literal">null</span>,
	
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Number of rows to display on a single page when using pagination. If
feature enabled (<code>lengthChange</code>) then the end user will be able to override
this to a custom setting using a pop-up menu.
 @type int
 @default 10</p>
<p> @dtopt Options
 @name DataTable.defaults.pageLength</p>
<p> @example
   $(document).ready( function() {
     $(&#39;#example&#39;).dataTable( {
       &quot;pageLength&quot;: 50
     } );
   } )</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-string">"iDisplayLength"</span>: <span class="hljs-number">50</span>,
	
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Define the starting point for data display when using DataTables with
pagination. Note that this parameter is the number of records, rather than
the page number, so if you have 10 records per page and want to start on
the third page, it should be &quot;20&quot;.
 @type int
 @default 0</p>
<p> @dtopt Options
 @name DataTable.defaults.displayStart</p>
<p> @example
   $(document).ready( function() {
     $(&#39;#example&#39;).dataTable( {
       &quot;displayStart&quot;: 20
     } );
   } )</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-string">"iDisplayStart"</span>: <span class="hljs-number">0</span>,
	
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>By default DataTables allows keyboard navigation of the table (sorting, paging,
and filtering) by adding a <code>tabindex</code> attribute to the required elements. This
allows you to tab through the controls and press the enter key to activate them.
The tabindex is default 0, meaning that the tab follows the flow of the document.
You can overrule this using this parameter if you wish. Use a value of -1 to
disable built-in keyboard navigation.
 @type int
 @default 0</p>
<p> @dtopt Options
 @name DataTable.defaults.tabIndex</p>
<p> @example
   $(document).ready( function() {
     $(&#39;#example&#39;).dataTable( {
       &quot;tabIndex&quot;: 1
     } );
   } );</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-string">"iTabIndex"</span>: <span class="hljs-number">0</span>,
	
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Classes that DataTables assigns to the various components and features
that it adds to the HTML table. This allows classes to be configured
during initialisation in addition to through the static
{@link DataTable.ext.oStdClasses} object).
 @namespace
 @name DataTable.defaults.classes</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-string">"oClasses"</span>: {},
	
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>All strings that DataTables uses in the user interface that it creates
are defined in this object, allowing you to modified them individually or
completely replace them all as required.
 @namespace
 @name DataTable.defaults.language</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-string">"oLanguage"</span>: {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Strings that are used for WAI-ARIA labels and controls only (these are not
actually visible on the page, but will be read by screenreaders, and thus
must be internationalised as well).
 @namespace
 @name DataTable.defaults.language.aria</p></div></div><div class="code"><div class="wrapper">			<span class="hljs-string">"oAria"</span>: {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>ARIA label that is added to the table headers when the column may be
sorted ascending by activing the column (click or return when focused).
Note that the column header is prefixed to this string.
 @type string
 @default : activate to sort column ascending</p>
<p> @dtopt Language
 @name DataTable.defaults.language.aria.sortAscending</p>
<p> @example
   $(document).ready( function() {
     $(&#39;#example&#39;).dataTable( {
       &quot;language&quot;: {
         &quot;aria&quot;: {
           &quot;sortAscending&quot;: &quot; - click/return to sort ascending&quot;
         }
       }
     } );
   } );</p></div></div><div class="code"><div class="wrapper">				<span class="hljs-string">"sSortAscending"</span>: <span class="hljs-string">": activate to sort column ascending"</span>,
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>ARIA label that is added to the table headers when the column may be
sorted descending by activing the column (click or return when focused).
Note that the column header is prefixed to this string.
 @type string
 @default : activate to sort column ascending</p>
<p> @dtopt Language
 @name DataTable.defaults.language.aria.sortDescending</p>
<p> @example
   $(document).ready( function() {
     $(&#39;#example&#39;).dataTable( {
       &quot;language&quot;: {
         &quot;aria&quot;: {
           &quot;sortDescending&quot;: &quot; - click/return to sort descending&quot;
         }
       }
     } );
   } );</p></div></div><div class="code"><div class="wrapper">				<span class="hljs-string">"sSortDescending"</span>: <span class="hljs-string">": activate to sort column descending"</span>
			},
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Pagination string used by DataTables for the built-in pagination
control types.
 @namespace
 @name DataTable.defaults.language.paginate</p></div></div><div class="code"><div class="wrapper">			<span class="hljs-string">"oPaginate"</span>: {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Text to use when using the &#39;full_numbers&#39; type of pagination for the
button to take the user to the first page.
 @type string
 @default First</p>
<p> @dtopt Language
 @name DataTable.defaults.language.paginate.first</p>
<p> @example
   $(document).ready( function() {
     $(&#39;#example&#39;).dataTable( {
       &quot;language&quot;: {
         &quot;paginate&quot;: {
           &quot;first&quot;: &quot;First page&quot;
         }
       }
     } );
   } );</p></div></div><div class="code"><div class="wrapper">				<span class="hljs-string">"sFirst"</span>: <span class="hljs-string">"First"</span>,
	
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Text to use when using the &#39;full_numbers&#39; type of pagination for the
button to take the user to the last page.
 @type string
 @default Last</p>
<p> @dtopt Language
 @name DataTable.defaults.language.paginate.last</p>
<p> @example
   $(document).ready( function() {
     $(&#39;#example&#39;).dataTable( {
       &quot;language&quot;: {
         &quot;paginate&quot;: {
           &quot;last&quot;: &quot;Last page&quot;
         }
       }
     } );
   } );</p></div></div><div class="code"><div class="wrapper">				<span class="hljs-string">"sLast"</span>: <span class="hljs-string">"Last"</span>,
	
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Text to use for the &#39;next&#39; pagination button (to take the user to the
next page).
 @type string
 @default Next</p>
<p> @dtopt Language
 @name DataTable.defaults.language.paginate.next</p>
<p> @example
   $(document).ready( function() {
     $(&#39;#example&#39;).dataTable( {
       &quot;language&quot;: {
         &quot;paginate&quot;: {
           &quot;next&quot;: &quot;Next page&quot;
         }
       }
     } );
   } );</p></div></div><div class="code"><div class="wrapper">				<span class="hljs-string">"sNext"</span>: <span class="hljs-string">"Next"</span>,
	
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Text to use for the &#39;previous&#39; pagination button (to take the user to
the previous page).
 @type string
 @default Previous</p>
<p> @dtopt Language
 @name DataTable.defaults.language.paginate.previous</p>
<p> @example
   $(document).ready( function() {
     $(&#39;#example&#39;).dataTable( {
       &quot;language&quot;: {
         &quot;paginate&quot;: {
           &quot;previous&quot;: &quot;Previous page&quot;
         }
       }
     } );
   } );</p></div></div><div class="code"><div class="wrapper">				<span class="hljs-string">"sPrevious"</span>: <span class="hljs-string">"Previous"</span>
			},
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>This string is shown in preference to <code>zeroRecords</code> when the table is
empty of data (regardless of filtering). Note that this is an optional
parameter - if it is not given, the value of <code>zeroRecords</code> will be used
instead (either the default or given value).
 @type string
 @default No data available in table</p>
<p> @dtopt Language
 @name DataTable.defaults.language.emptyTable</p>
<p> @example
   $(document).ready( function() {
     $(&#39;#example&#39;).dataTable( {
       &quot;language&quot;: {
         &quot;emptyTable&quot;: &quot;No data available in table&quot;
       }
     } );
   } );</p></div></div><div class="code"><div class="wrapper">			<span class="hljs-string">"sEmptyTable"</span>: <span class="hljs-string">"No data available in table"</span>,
	
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>This string gives information to the end user about the information
that is current on display on the page. The following tokens can be
used in the string and will be dynamically replaced as the table
display updates. This tokens can be placed anywhere in the string, or
removed as needed by the language requires:</p>
<ul>
<li><code>\_START\_</code> - Display index of the first record on the current page</li>
<li><code>\_END\_</code> - Display index of the last record on the current page</li>
<li><code>\_TOTAL\_</code> - Number of records in the table after filtering</li>
<li><code>\_MAX\_</code> - Number of records in the table without filtering</li>
<li><code>\_PAGE\_</code> - Current page number</li>
<li><p><code>\_PAGES\_</code> - Total number of pages of data in the table</p>
<p>@type string
@default Showing <em>START</em> to <em>END</em> of <em>TOTAL</em> entries</p>
<p>@dtopt Language
@name DataTable.defaults.language.info</p>
<p>@example
 $(document).ready( function() {
   $(&#39;#example&#39;).dataTable( {</p>
<pre><code> &quot;language&quot;: {
   &quot;info&quot;: &quot;Showing page _PAGE_ of _PAGES_&quot;
 }</code></pre>
<p>   } );
 } );</p>
</li>
</ul></div></div><div class="code"><div class="wrapper">			<span class="hljs-string">"sInfo"</span>: <span class="hljs-string">"Showing _START_ to _END_ of _TOTAL_ entries"</span>,
	
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Display information string for when the table is empty. Typically the
format of this string should match <code>info</code>.
 @type string
 @default Showing 0 to 0 of 0 entries</p>
<p> @dtopt Language
 @name DataTable.defaults.language.infoEmpty</p>
<p> @example
   $(document).ready( function() {
     $(&#39;#example&#39;).dataTable( {
       &quot;language&quot;: {
         &quot;infoEmpty&quot;: &quot;No entries to show&quot;
       }
     } );
   } );</p></div></div><div class="code"><div class="wrapper">			<span class="hljs-string">"sInfoEmpty"</span>: <span class="hljs-string">"Showing 0 to 0 of 0 entries"</span>,
	
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>When a user filters the information in a table, this string is appended
to the information (<code>info</code>) to give an idea of how strong the filtering
is. The variable <em>MAX</em> is dynamically updated.
 @type string
 @default (filtered from <em>MAX</em> total entries)</p>
<p> @dtopt Language
 @name DataTable.defaults.language.infoFiltered</p>
<p> @example
   $(document).ready( function() {
     $(&#39;#example&#39;).dataTable( {
       &quot;language&quot;: {
         &quot;infoFiltered&quot;: &quot; - filtering from <em>MAX</em> records&quot;
       }
     } );
   } );</p></div></div><div class="code"><div class="wrapper">			<span class="hljs-string">"sInfoFiltered"</span>: <span class="hljs-string">"(filtered from _MAX_ total entries)"</span>,
	
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>If can be useful to append extra information to the info string at times,
and this variable does exactly that. This information will be appended to
the <code>info</code> (<code>infoEmpty</code> and <code>infoFiltered</code> in whatever combination they are
being used) at all times.
 @type string
 @default <i>Empty string</i></p>
<p> @dtopt Language
 @name DataTable.defaults.language.infoPostFix</p>
<p> @example
   $(document).ready( function() {
     $(&#39;#example&#39;).dataTable( {
       &quot;language&quot;: {
         &quot;infoPostFix&quot;: &quot;All records shown are derived from real information.&quot;
       }
     } );
   } );</p></div></div><div class="code"><div class="wrapper">			<span class="hljs-string">"sInfoPostFix"</span>: <span class="hljs-string">""</span>,
	
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>This decimal place operator is a little different from the other
language options since DataTables doesn&#39;t output floating point
numbers, so it won&#39;t ever use this for display of a number. Rather,
what this parameter does is modify the sort methods of the table so
that numbers which are in a format which has a character other than
a period (<code>.</code>) as a decimal place will be sorted numerically.</p>
<p>Note that numbers with different decimal places cannot be shown in
the same table and still be sortable, the table must be consistent.
However, multiple different tables on the page can use different
decimal place characters.
 @type string
 @default </p>
<p> @dtopt Language
 @name DataTable.defaults.language.decimal</p>
<p> @example
   $(document).ready( function() {
     $(&#39;#example&#39;).dataTable( {
       &quot;language&quot;: {
         &quot;decimal&quot;: &quot;,&quot;
         &quot;thousands&quot;: &quot;.&quot;
       }
     } );
   } );</p></div></div><div class="code"><div class="wrapper">			<span class="hljs-string">"sDecimal"</span>: <span class="hljs-string">""</span>,
	
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>DataTables has a build in number formatter (<code>formatNumber</code>) which is
used to format large numbers that are used in the table information.
By default a comma is used, but this can be trivially changed to any
character you wish with this parameter.
 @type string
 @default ,</p>
<p> @dtopt Language
 @name DataTable.defaults.language.thousands</p>
<p> @example
   $(document).ready( function() {
     $(&#39;#example&#39;).dataTable( {
       &quot;language&quot;: {
         &quot;thousands&quot;: &quot;&#39;&quot;
       }
     } );
   } );</p></div></div><div class="code"><div class="wrapper">			<span class="hljs-string">"sThousands"</span>: <span class="hljs-string">","</span>,
	
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Detail the action that will be taken when the drop down menu for the
pagination length option is changed. The &#39;<em>MENU</em>&#39; variable is replaced
with a default select list of 10, 25, 50 and 100, and can be replaced
with a custom select box if required.
 @type string
 @default Show <em>MENU</em> entries</p>
<p> @dtopt Language
 @name DataTable.defaults.language.lengthMenu</p>
<p> @example
   // Language change only
   $(document).ready( function() {
     $(&#39;#example&#39;).dataTable( {
       &quot;language&quot;: {
         &quot;lengthMenu&quot;: &quot;Display <em>MENU</em> records&quot;
       }
     } );
   } );</p>
<p> @example
   // Language and options change
   $(document).ready( function() {
     $(&#39;#example&#39;).dataTable( {
       &quot;language&quot;: {
         &quot;lengthMenu&quot;: &#39;Display <select>&#39;+
           &#39;<option value="10">10</option>&#39;+
           &#39;<option value="20">20</option>&#39;+
           &#39;<option value="30">30</option>&#39;+
           &#39;<option value="40">40</option>&#39;+
           &#39;<option value="50">50</option>&#39;+
           &#39;<option value="-1">All</option>&#39;+
           &#39;</select> records&#39;
       }
     } );
   } );</p></div></div><div class="code"><div class="wrapper">			<span class="hljs-string">"sLengthMenu"</span>: <span class="hljs-string">"Show _MENU_ entries"</span>,
	
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>When using Ajax sourced data and during the first draw when DataTables is
gathering the data, this message is shown in an empty row in the table to
indicate to the end user the the data is being loaded. Note that this
parameter is not used when loading data by server-side processing, just
Ajax sourced data with client-side processing.
 @type string
 @default Loading...</p>
<p> @dtopt Language
 @name DataTable.defaults.language.loadingRecords</p>
<p> @example
   $(document).ready( function() {
     $(&#39;#example&#39;).dataTable( {
       &quot;language&quot;: {
         &quot;loadingRecords&quot;: &quot;Please wait - loading...&quot;
       }
     } );
   } );</p></div></div><div class="code"><div class="wrapper">			<span class="hljs-string">"sLoadingRecords"</span>: <span class="hljs-string">"Loading..."</span>,
	
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Text which is displayed when the table is processing a user action
(usually a sort command or similar).
 @type string
 @default Processing...</p>
<p> @dtopt Language
 @name DataTable.defaults.language.processing</p>
<p> @example
   $(document).ready( function() {
     $(&#39;#example&#39;).dataTable( {
       &quot;language&quot;: {
         &quot;processing&quot;: &quot;DataTables is currently busy&quot;
       }
     } );
   } );</p></div></div><div class="code"><div class="wrapper">			<span class="hljs-string">"sProcessing"</span>: <span class="hljs-string">"Processing..."</span>,
	
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Details the actions that will be taken when the user types into the
filtering input text box. The variable &quot;<em>INPUT</em>&quot;, if used in the string,
is replaced with the HTML text box for the filtering input allowing
control over where it appears in the string. If &quot;<em>INPUT</em>&quot; is not given
then the input box is appended to the string automatically.
 @type string
 @default Search:</p>
<p> @dtopt Language
 @name DataTable.defaults.language.search</p>
<p> @example
   // Input text box will be appended at the end automatically
   $(document).ready( function() {
     $(&#39;#example&#39;).dataTable( {
       &quot;language&quot;: {
         &quot;search&quot;: &quot;Filter records:&quot;
       }
     } );
   } );</p>
<p> @example
   // Specify where the filter should appear
   $(document).ready( function() {
     $(&#39;#example&#39;).dataTable( {
       &quot;language&quot;: {
         &quot;search&quot;: &quot;Apply filter <em>INPUT</em> to table&quot;
       }
     } );
   } );</p></div></div><div class="code"><div class="wrapper">			<span class="hljs-string">"sSearch"</span>: <span class="hljs-string">"&lt;span class='hidden-xs'&gt;Filter &lt;/span&gt;"</span>,
	
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Assign a <code>placeholder</code> attribute to the search <code>input</code> element
 @type string
 @default </p>
<p> @dtopt Language
 @name DataTable.defaults.language.searchPlaceholder</p></div></div><div class="code"><div class="wrapper">			<span class="hljs-string">"sSearchPlaceholder"</span>: <span class="hljs-string">" "</span>,
	
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>All of the language information can be stored in a file on the
server-side, which DataTables will look up if this parameter is passed.
It must store the URL of the language file, which is in a JSON format,
and the object has the same properties as the oLanguage object in the
initialiser object (i.e. the above parameters). Please refer to one of
the example language files to see how this works in action.
 @type string
 @default <i>Empty string - i.e. disabled</i></p>
<p> @dtopt Language
 @name DataTable.defaults.language.url</p>
<p> @example
   $(document).ready( function() {
     $(&#39;#example&#39;).dataTable( {
       &quot;language&quot;: {
         &quot;url&quot;: &quot;<a href="http://www.sprymedia.co.uk/dataTables/lang.txt">http://www.sprymedia.co.uk/dataTables/lang.txt</a>&quot;
       }
     } );
   } );</p></div></div><div class="code"><div class="wrapper">			<span class="hljs-string">"sUrl"</span>: <span class="hljs-string">""</span>,
	
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Text shown inside the table records when the is no information to be
displayed after filtering. <code>emptyTable</code> is shown when there is simply no
information in the table at all (regardless of filtering).
 @type string
 @default No matching records found</p>
<p> @dtopt Language
 @name DataTable.defaults.language.zeroRecords</p>
<p> @example
   $(document).ready( function() {
     $(&#39;#example&#39;).dataTable( {
       &quot;language&quot;: {
         &quot;zeroRecords&quot;: &quot;No records to display&quot;
       }
     } );
   } );</p></div></div><div class="code"><div class="wrapper">			<span class="hljs-string">"sZeroRecords"</span>: <span class="hljs-string">"No matching records found"</span>
		},
	
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>This parameter allows you to have define the global filtering state at
initialisation time. As an object the <code>search</code> parameter must be
defined, but all other parameters are optional. When <code>regex</code> is true,
the search string will be treated as a regular expression, when false
(default) it will be treated as a straight string. When <code>smart</code>
DataTables will use it&#39;s smart filtering methods (to word match at
any point in the data), when false this will not be done.
 @namespace
 @extends DataTable.models.oSearch</p>
<p> @dtopt Options
 @name DataTable.defaults.search</p>
<p> @example
   $(document).ready( function() {
     $(&#39;#example&#39;).dataTable( {
       &quot;search&quot;: {&quot;search&quot;: &quot;Initial search&quot;}
     } );
   } )</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-string">"oSearch"</span>: $.extend( {}, DataTable.models.oSearch ),
	
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p><strong>Deprecated</strong> The functionality provided by this parameter has now been
superseded by that provided through <code>ajax</code>, which should be used instead.</p>
<p>By default DataTables will look for the property <code>data</code> (or <code>aaData</code> for
compatibility with DataTables 1.9-) when obtaining data from an Ajax
source or for server-side processing - this parameter allows that
property to be changed. You can use Javascript dotted object notation to
get a data source for multiple levels of nesting.
 @type string
 @default data</p>
<p> @dtopt Options
 @dtopt Server-side
 @name DataTable.defaults.ajaxDataProp</p>
<p> @deprecated 1.10. Please use <code>ajax</code> for this functionality now.</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-string">"sAjaxDataProp"</span>: <span class="hljs-string">"data"</span>,
	
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p><strong>Deprecated</strong> The functionality provided by this parameter has now been
superseded by that provided through <code>ajax</code>, which should be used instead.</p>
<p>You can instruct DataTables to load data from an external
source using this parameter (use aData if you want to pass data in you
already have). Simply provide a url a JSON object can be obtained from.
 @type string
 @default null</p>
<p> @dtopt Options
 @dtopt Server-side
 @name DataTable.defaults.ajaxSource</p>
<p> @deprecated 1.10. Please use <code>ajax</code> for this functionality now.</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-string">"sAjaxSource"</span>: <span class="hljs-literal">null</span>,
	
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>This initialisation variable allows you to specify exactly where in the
DOM you want DataTables to inject the various controls it adds to the page
(for example you might want the pagination controls at the top of the
table). DIV elements (with or without a custom class) can also be added to
aid styling. The follow syntax is used:
  <ul>
    <li>The following options are allowed:
      <ul>
        <li>&#39;l&#39; - Length changing</li>
        <li>&#39;f&#39; - Filtering input</li>
        <li>&#39;t&#39; - The table!</li>
        <li>&#39;i&#39; - Information</li>
        <li>&#39;p&#39; - Pagination</li>
        <li>&#39;r&#39; - pRocessing</li>
      </ul>
    </li>
    <li>The following constants are allowed:
      <ul>
        <li>&#39;H&#39; - jQueryUI theme &quot;header&quot; classes (&#39;fg-toolbar ui-widget-header ui-corner-tl ui-corner-tr ui-helper-clearfix&#39;)</li>
        <li>&#39;F&#39; - jQueryUI theme &quot;footer&quot; classes (&#39;fg-toolbar ui-widget-header ui-corner-bl ui-corner-br ui-helper-clearfix&#39;)</li>
      </ul>
    </li>
    <li>The following syntax is expected:
      <ul>
        <li>&#39;&lt;&#39; and &#39;&gt;&#39; - div elements</li>
        <li>&#39;&lt;&quot;class&quot; and &#39;&gt;&#39; - div with a class</li>
        <li>&#39;&lt;&quot;#id&quot; and &#39;&gt;&#39; - div with an ID</li>
      </ul>
    </li>
    <li>Examples:
      <ul>
        <li>&#39;&lt;&quot;wrapper&quot;flipt&gt;&#39;</li>
        <li>&#39;&lt;lf&lt;t&gt;ip&gt;&#39;</li>
      </ul>
    </li>
  </ul>
 @type string
 @default lfrtip <i>(when <code>jQueryUI</code> is false)</i> <b>or</b>
   &lt;&quot;H&quot;lfr&gt;t&lt;&quot;F&quot;ip&gt; <i>(when <code>jQueryUI</code> is true)</i></p>
<p> @dtopt Options
 @name DataTable.defaults.dom</p>
<p> @example
   $(document).ready( function() {
     $(&#39;#example&#39;).dataTable( {
       &quot;dom&quot;: &#39;&lt;&quot;top&quot;i&gt;rt&lt;&quot;bottom&quot;flp&gt;&lt;&quot;clear&quot;&gt;&#39;
     } );
   } );</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-string">"sDom"</span>: <span class="hljs-string">"lfrtip"</span>,
	
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>DataTables features four different built-in options for the buttons to
display for pagination control:</p>
<ul>
<li><code>simple</code> - &#39;Previous&#39; and &#39;Next&#39; buttons only</li>
<li>&#39;simple_numbers` - &#39;Previous&#39; and &#39;Next&#39; buttons, plus page numbers</li>
<li><code>full</code> - &#39;First&#39;, &#39;Previous&#39;, &#39;Next&#39; and &#39;Last&#39; buttons</li>
<li><code>full_numbers</code> - &#39;First&#39;, &#39;Previous&#39;, &#39;Next&#39; and &#39;Last&#39; buttons, plus
page numbers</li>
</ul>
<p>Further methods can be added using {@link DataTable.ext.oPagination}.
 @type string
 @default simple_numbers</p>
<p> @dtopt Options
 @name DataTable.defaults.pagingType</p>
<p> @example
   $(document).ready( function() {
     $(&#39;#example&#39;).dataTable( {
       &quot;pagingType&quot;: &quot;full_numbers&quot;
     } );
   } )</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-string">"sPaginationType"</span>: <span class="hljs-string">"simple_numbers"</span>,
	
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Enable horizontal scrolling. When a table is too wide to fit into a
certain layout, or you have a large number of columns in the table, you
can enable x-scrolling to show the table in a viewport, which can be
scrolled. This property can be <code>true</code> which will allow the table to
scroll horizontally when needed, or any CSS unit, or a number (in which
case it will be treated as a pixel measurement). Setting as simply <code>true</code>
is recommended.
 @type boolean|string
 @default <i>blank string - i.e. disabled</i></p>
<p> @dtopt Features
 @name DataTable.defaults.scrollX</p>
<p> @example
   $(document).ready( function() {
     $(&#39;#example&#39;).dataTable( {
       &quot;scrollX&quot;: true,
       &quot;scrollCollapse&quot;: true
     } );
   } );</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-string">"sScrollX"</span>: <span class="hljs-string">""</span>,
	
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>This property can be used to force a DataTable to use more width than it
might otherwise do when x-scrolling is enabled. For example if you have a
table which requires to be well spaced, this parameter is useful for
&quot;over-sizing&quot; the table, and thus forcing scrolling. This property can by
any CSS unit, or a number (in which case it will be treated as a pixel
measurement).
 @type string
 @default <i>blank string - i.e. disabled</i></p>
<p> @dtopt Options
 @name DataTable.defaults.scrollXInner</p>
<p> @example
   $(document).ready( function() {
     $(&#39;#example&#39;).dataTable( {
       &quot;scrollX&quot;: &quot;100%&quot;,
       &quot;scrollXInner&quot;: &quot;110%&quot;
     } );
   } );</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-string">"sScrollXInner"</span>: <span class="hljs-string">""</span>,
	
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Enable vertical scrolling. Vertical scrolling will constrain the DataTable
to the given height, and enable scrolling for any data which overflows the
current viewport. This can be used as an alternative to paging to display
a lot of data in a small area (although paging and scrolling can both be
enabled at the same time). This property can be any CSS unit, or a number
(in which case it will be treated as a pixel measurement).
 @type string
 @default <i>blank string - i.e. disabled</i></p>
<p> @dtopt Features
 @name DataTable.defaults.scrollY</p>
<p> @example
   $(document).ready( function() {
     $(&#39;#example&#39;).dataTable( {
       &quot;scrollY&quot;: &quot;200px&quot;,
       &quot;paginate&quot;: false
     } );
   } );</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-string">"sScrollY"</span>: <span class="hljs-string">""</span>,
	
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p><strong>Deprecated</strong> The functionality provided by this parameter has now been
superseded by that provided through <code>ajax</code>, which should be used instead.</p>
<p>Set the HTTP method that is used to make the Ajax call for server-side
processing or Ajax sourced data.
 @type string
 @default GET</p>
<p> @dtopt Options
 @dtopt Server-side
 @name DataTable.defaults.serverMethod</p>
<p> @deprecated 1.10. Please use <code>ajax</code> for this functionality now.</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-string">"sServerMethod"</span>: <span class="hljs-string">"GET"</span>,
	
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>DataTables makes use of renderers when displaying HTML elements for
a table. These renderers can be added or modified by plug-ins to
generate suitable mark-up for a site. For example the Bootstrap
integration plug-in for DataTables uses a paging button renderer to
display pagination buttons in the mark-up required by Bootstrap.</p>
<p>For further information about the renderers available see
DataTable.ext.renderer
 @type string|object
 @default null</p>
<p> @name DataTable.defaults.renderer</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-string">"renderer"</span>: <span class="hljs-literal">null</span>
	};
	
	_fnHungarianMap( DataTable.defaults );
	
	
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Developer note - See note in model.defaults.js about the use of Hungarian
notation and camel case.</p></div></div><div class="code"><div class="wrapper">	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Column options that can be given to DataTables at initialisation time.
 @namespace</p></div></div><div class="code"><div class="wrapper">	DataTable.defaults.column = {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Define which column(s) an order will occur on for this column. This
allows a column&#39;s ordering to take multiple columns into account when
doing a sort or use the data from a different column. For example first
name / last name columns make sense to do a multi-column sort over the
two columns.
 @type array|int
 @default null <i>Takes the value of the column index automatically</i></p>
<p> @name DataTable.defaults.column.orderData
 @dtopt Columns</p>
<p> @example
   // Using <code>columnDefs</code>
   $(document).ready( function() {
     $(&#39;#example&#39;).dataTable( {
       &quot;columnDefs&quot;: [
         { &quot;orderData&quot;: [ 0, 1 ], &quot;targets&quot;: [ 0 ] },
         { &quot;orderData&quot;: [ 1, 0 ], &quot;targets&quot;: [ 1 ] },
         { &quot;orderData&quot;: 2, &quot;targets&quot;: [ 2 ] }
       ]
     } );
   } );</p>
<p> @example
   // Using <code>columns</code>
   $(document).ready( function() {
     $(&#39;#example&#39;).dataTable( {
       &quot;columns&quot;: [
         { &quot;orderData&quot;: [ 0, 1 ] },
         { &quot;orderData&quot;: [ 1, 0 ] },
         { &quot;orderData&quot;: 2 },
         null,
         null
       ]
     } );
   } );</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-string">"aDataSort"</span>: <span class="hljs-literal">null</span>,
		<span class="hljs-string">"iDataSort"</span>: -<span class="hljs-number">1</span>,
	
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>You can control the default ordering direction, and even alter the
behaviour of the sort handler (i.e. only allow ascending ordering etc)
using this parameter.
 @type array
 @default [ &#39;asc&#39;, &#39;desc&#39; ]</p>
<p> @name DataTable.defaults.column.orderSequence
 @dtopt Columns</p>
<p> @example
   // Using <code>columnDefs</code>
   $(document).ready( function() {
     $(&#39;#example&#39;).dataTable( {
       &quot;columnDefs&quot;: [
         { &quot;orderSequence&quot;: [ &quot;asc&quot; ], &quot;targets&quot;: [ 1 ] },
         { &quot;orderSequence&quot;: [ &quot;desc&quot;, &quot;asc&quot;, &quot;asc&quot; ], &quot;targets&quot;: [ 2 ] },
         { &quot;orderSequence&quot;: [ &quot;desc&quot; ], &quot;targets&quot;: [ 3 ] }
       ]
     } );
   } );</p>
<p> @example
   // Using <code>columns</code>
   $(document).ready( function() {
     $(&#39;#example&#39;).dataTable( {
       &quot;columns&quot;: [
         null,
         { &quot;orderSequence&quot;: [ &quot;asc&quot; ] },
         { &quot;orderSequence&quot;: [ &quot;desc&quot;, &quot;asc&quot;, &quot;asc&quot; ] },
         { &quot;orderSequence&quot;: [ &quot;desc&quot; ] },
         null
       ]
     } );
   } );</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-string">"asSorting"</span>: [ <span class="hljs-string">'asc'</span>, <span class="hljs-string">'desc'</span> ],
	
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Enable or disable filtering on the data in this column.
 @type boolean
 @default true</p>
<p> @name DataTable.defaults.column.searchable
 @dtopt Columns</p>
<p> @example
   // Using <code>columnDefs</code>
   $(document).ready( function() {
     $(&#39;#example&#39;).dataTable( {
       &quot;columnDefs&quot;: [
         { &quot;searchable&quot;: false, &quot;targets&quot;: [ 0 ] }
       ] } );
   } );</p>
<p> @example
   // Using <code>columns</code>
   $(document).ready( function() {
     $(&#39;#example&#39;).dataTable( {
       &quot;columns&quot;: [
         { &quot;searchable&quot;: false },
         null,
         null,
         null,
         null
       ] } );
   } );</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-string">"bSearchable"</span>: <span class="hljs-literal">true</span>,
	
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Enable or disable ordering on this column.
 @type boolean
 @default true</p>
<p> @name DataTable.defaults.column.orderable
 @dtopt Columns</p>
<p> @example
   // Using <code>columnDefs</code>
   $(document).ready( function() {
     $(&#39;#example&#39;).dataTable( {
       &quot;columnDefs&quot;: [
         { &quot;orderable&quot;: false, &quot;targets&quot;: [ 0 ] }
       ] } );
   } );</p>
<p> @example
   // Using <code>columns</code>
   $(document).ready( function() {
     $(&#39;#example&#39;).dataTable( {
       &quot;columns&quot;: [
         { &quot;orderable&quot;: false },
         null,
         null,
         null,
         null
       ] } );
   } );</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-string">"bSortable"</span>: <span class="hljs-literal">true</span>,
	
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Enable or disable the display of this column.
 @type boolean
 @default true</p>
<p> @name DataTable.defaults.column.visible
 @dtopt Columns</p>
<p> @example
   // Using <code>columnDefs</code>
   $(document).ready( function() {
     $(&#39;#example&#39;).dataTable( {
       &quot;columnDefs&quot;: [
         { &quot;visible&quot;: false, &quot;targets&quot;: [ 0 ] }
       ] } );
   } );</p>
<p> @example
   // Using <code>columns</code>
   $(document).ready( function() {
     $(&#39;#example&#39;).dataTable( {
       &quot;columns&quot;: [
         { &quot;visible&quot;: false },
         null,
         null,
         null,
         null
       ] } );
   } );</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-string">"bVisible"</span>: <span class="hljs-literal">true</span>,
	
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Developer definable function that is called whenever a cell is created (Ajax source,
etc) or processed for input (DOM source). This can be used as a compliment to mRender
allowing you to modify the DOM element (add background colour for example) when the
element is available.
 @type function
 @param {element} td The TD node that has been created
 @param {*} cellData The Data for the cell
 @param {array|object} rowData The data for the whole row
 @param {int} row The row index for the aoData data store
 @param {int} col The column index for aoColumns</p>
<p> @name DataTable.defaults.column.createdCell
 @dtopt Columns</p>
<p> @example
   $(document).ready( function() {
     $(&#39;#example&#39;).dataTable( {
       &quot;columnDefs&quot;: [ {
         &quot;targets&quot;: [3],
         &quot;createdCell&quot;: function (td, cellData, rowData, row, col) {
           if ( cellData == &quot;1.7&quot; ) {
             $(td).css(&#39;color&#39;, &#39;blue&#39;)
           }
         }
       } ]
     });
   } );</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-string">"fnCreatedCell"</span>: <span class="hljs-literal">null</span>,
	
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>This parameter has been replaced by <code>data</code> in DataTables to ensure naming
consistency. <code>dataProp</code> can still be used, as there is backwards
compatibility in DataTables for this option, but it is strongly
recommended that you use <code>data</code> in preference to <code>dataProp</code>.
 @name DataTable.defaults.column.dataProp</p></div></div><div class="code"><div class="wrapper">	
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>This property can be used to read data from any data source property,
including deeply nested objects / properties. <code>data</code> can be given in a
number of different ways which effect its behaviour:</p>
<ul>
<li><code>integer</code> - treated as an array index for the data source. This is the
default that DataTables uses (incrementally increased for each column).</li>
<li><code>string</code> - read an object property from the data source. There are
three &#39;special&#39; options that can be used in the string to alter how
DataTables reads the data from the source object:<ul>
<li><code>.</code> - Dotted Javascript notation. Just as you use a <code>.</code> in
Javascript to read from nested objects, so to can the options
specified in <code>data</code>. For example: <code>browser.version</code> or
<code>browser.name</code>. If your object parameter name contains a period, use
<code>\\</code> to escape it - i.e. <code>first\\.name</code>.</li>
<li><code>[]</code> - Array notation. DataTables can automatically combine data
from and array source, joining the data with the characters provided
between the two brackets. For example: <code>name[, ]</code> would provide a
comma-space separated list from the source array. If no characters
are provided between the brackets, the original array source is
returned.</li>
<li><code>()</code> - Function notation. Adding <code>()</code> to the end of a parameter will
execute a function of the name given. For example: <code>browser()</code> for a
simple function on the data source, <code>browser.version()</code> for a
function in a nested property or even <code>browser().version</code> to get an
object property if the function called returns an object. Note that
function notation is recommended for use in <code>render</code> rather than
<code>data</code> as it is much simpler to use as a renderer.</li>
</ul>
</li>
<li><code>null</code> - use the original data source for the row rather than plucking
data directly from it. This action has effects on two other
initialisation options:<ul>
<li><code>defaultContent</code> - When null is given as the <code>data</code> option and
<code>defaultContent</code> is specified for the column, the value defined by
<code>defaultContent</code> will be used for the cell.</li>
<li><code>render</code> - When null is used for the <code>data</code> option and the <code>render</code>
option is specified for the column, the whole data source for the
row is used for the renderer.</li>
</ul>
</li>
<li><code>function</code> - the function given will be executed whenever DataTables
needs to set or get the data for a cell in the column. The function
takes three parameters:<ul>
<li>Parameters:<ul>
<li><code>{array|object}</code> The data source for the row</li>
<li><code>{string}</code> The type call data requested - this will be &#39;set&#39; when
setting data or &#39;filter&#39;, &#39;display&#39;, &#39;type&#39;, &#39;sort&#39; or undefined
when gathering data. Note that when <code>undefined</code> is given for the
type DataTables expects to get the raw data for the object back&lt;</li>
<li><code>{*}</code> Data to set when the second parameter is &#39;set&#39;.</li>
</ul>
</li>
<li>Return:<ul>
<li>The return value from the function is not required when &#39;set&#39; is
the type of call, but otherwise the return is what will be used
for the data requested.</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>Note that <code>data</code> is a getter and setter option. If you just require
formatting of data for output, you will likely want to use <code>render</code> which
is simply a getter and thus simpler to use.</p>
<p>Note that prior to DataTables 1.9.2 <code>data</code> was called <code>mDataProp</code>. The
name change reflects the flexibility of this property and is consistent
with the naming of mRender. If &#39;mDataProp&#39; is given, then it will still
be used by DataTables, as it automatically maps the old name to the new
if required.</p>
<p> @type string|int|function|null
 @default null <i>Use automatically calculated column index</i></p>
<p> @name DataTable.defaults.column.data
 @dtopt Columns</p>
<p> @example
   // Read table data from objects
   // JSON structure for each row:
   //   {
   //      &quot;engine&quot;: {value},
   //      &quot;browser&quot;: {value},
   //      &quot;platform&quot;: {value},
   //      &quot;version&quot;: {value},
   //      &quot;grade&quot;: {value}
   //   }
   $(document).ready( function() {
     $(&#39;#example&#39;).dataTable( {
       &quot;ajaxSource&quot;: &quot;sources/objects.txt&quot;,
       &quot;columns&quot;: [
         { &quot;data&quot;: &quot;engine&quot; },
         { &quot;data&quot;: &quot;browser&quot; },
         { &quot;data&quot;: &quot;platform&quot; },
         { &quot;data&quot;: &quot;version&quot; },
         { &quot;data&quot;: &quot;grade&quot; }
       ]
     } );
   } );</p>
<p> @example
   // Read information from deeply nested objects
   // JSON structure for each row:
   //   {
   //      &quot;engine&quot;: {value},
   //      &quot;browser&quot;: {value},
   //      &quot;platform&quot;: {
   //         &quot;inner&quot;: {value}
   //      },
   //      &quot;details&quot;: [
   //         {value}, {value}
   //      ]
   //   }
   $(document).ready( function() {
     $(&#39;#example&#39;).dataTable( {
       &quot;ajaxSource&quot;: &quot;sources/deep.txt&quot;,
       &quot;columns&quot;: [
         { &quot;data&quot;: &quot;engine&quot; },
         { &quot;data&quot;: &quot;browser&quot; },
         { &quot;data&quot;: &quot;platform.inner&quot; },
         { &quot;data&quot;: &quot;platform.details.0&quot; },
         { &quot;data&quot;: &quot;platform.details.1&quot; }
       ]
     } );
   } );</p>
<p> @example
   // Using <code>data</code> as a function to provide different information for
   // sorting, filtering and display. In this case, currency (price)
   $(document).ready( function() {
     $(&#39;#example&#39;).dataTable( {
       &quot;columnDefs&quot;: [ {
         &quot;targets&quot;: [ 0 ],
         &quot;data&quot;: function ( source, type, val ) {
           if (type === &#39;set&#39;) {
             source.price = val;
             // Store the computed dislay and filter values for efficiency
             source.price_display = val==&quot;&quot; ? &quot;&quot; : &quot;$&quot;+numberFormat(val);
             source.price_filter  = val==&quot;&quot; ? &quot;&quot; : &quot;$&quot;+numberFormat(val)+&quot; &quot;+val;
             return;
           }
           else if (type === &#39;display&#39;) {
             return source.price_display;
           }
           else if (type === &#39;filter&#39;) {
             return source.price_filter;
           }
           // &#39;sort&#39;, &#39;type&#39; and undefined all just use the integer
           return source.price;
         }
       } ]
     } );
   } );</p>
<p> @example
   // Using default content
   $(document).ready( function() {
     $(&#39;#example&#39;).dataTable( {
       &quot;columnDefs&quot;: [ {
         &quot;targets&quot;: [ 0 ],
         &quot;data&quot;: null,
         &quot;defaultContent&quot;: &quot;Click to edit&quot;
       } ]
     } );
   } );</p>
<p> @example
   // Using array notation - outputting a list from an array
   $(document).ready( function() {
     $(&#39;#example&#39;).dataTable( {
       &quot;columnDefs&quot;: [ {
         &quot;targets&quot;: [ 0 ],
         &quot;data&quot;: &quot;name[, ]&quot;
       } ]
     } );
   } );</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-string">"mData"</span>: <span class="hljs-literal">null</span>,
	
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>This property is the rendering partner to <code>data</code> and it is suggested that
when you want to manipulate data for display (including filtering,
sorting etc) without altering the underlying data for the table, use this
property. <code>render</code> can be considered to be the the read only companion to
<code>data</code> which is read / write (then as such more complex). Like <code>data</code>
this option can be given in a number of different ways to effect its
behaviour:</p>
<ul>
<li><code>integer</code> - treated as an array index for the data source. This is the
default that DataTables uses (incrementally increased for each column).</li>
<li><code>string</code> - read an object property from the data source. There are
three &#39;special&#39; options that can be used in the string to alter how
DataTables reads the data from the source object:<ul>
<li><code>.</code> - Dotted Javascript notation. Just as you use a <code>.</code> in
Javascript to read from nested objects, so to can the options
specified in <code>data</code>. For example: <code>browser.version</code> or
<code>browser.name</code>. If your object parameter name contains a period, use
<code>\\</code> to escape it - i.e. <code>first\\.name</code>.</li>
<li><code>[]</code> - Array notation. DataTables can automatically combine data
from and array source, joining the data with the characters provided
between the two brackets. For example: <code>name[, ]</code> would provide a
comma-space separated list from the source array. If no characters
are provided between the brackets, the original array source is
returned.</li>
<li><code>()</code> - Function notation. Adding <code>()</code> to the end of a parameter will
execute a function of the name given. For example: <code>browser()</code> for a
simple function on the data source, <code>browser.version()</code> for a
function in a nested property or even <code>browser().version</code> to get an
object property if the function called returns an object.</li>
</ul>
</li>
<li><code>object</code> - use different data for the different data types requested by
DataTables (&#39;filter&#39;, &#39;display&#39;, &#39;type&#39; or &#39;sort&#39;). The property names
of the object is the data type the property refers to and the value can
defined using an integer, string or function using the same rules as
<code>render</code> normally does. Note that an <code>_</code> option <em>must</em> be specified.
This is the default value to use if you haven&#39;t specified a value for
the data type requested by DataTables.</li>
<li><p><code>function</code> - the function given will be executed whenever DataTables
needs to set or get the data for a cell in the column. The function
takes three parameters:</p>
<ul>
<li>Parameters:<ul>
<li>{array|object} The data source for the row (based on <code>data</code>)</li>
<li>{string} The type call data requested - this will be &#39;filter&#39;,
&#39;display&#39;, &#39;type&#39; or &#39;sort&#39;.</li>
<li>{array|object} The full data source for the row (not based on
<code>data</code>)</li>
</ul>
</li>
<li>Return:<ul>
<li>The return value from the function is what will be used for the
data requested.</li>
</ul>
</li>
</ul>
<p>@type string|int|function|object|null
@default null Use the data source value.</p>
<p>@name DataTable.defaults.column.render
@dtopt Columns</p>
<p>@example
 // Create a comma separated list from an array of objects
 $(document).ready( function() {
   $(&#39;#example&#39;).dataTable( {</p>
<pre><code> &quot;ajaxSource&quot;: &quot;sources/deep.txt&quot;,
 &quot;columns&quot;: [
   { &quot;data&quot;: &quot;engine&quot; },
   { &quot;data&quot;: &quot;browser&quot; },
   {
     &quot;data&quot;: &quot;platform&quot;,
     &quot;render&quot;: &quot;[, ].name&quot;
   }
 ]</code></pre>
<p>   } );
 } );</p>
<p>@example
 // Execute a function to obtain data
 $(document).ready( function() {
   $(&#39;#example&#39;).dataTable( {</p>
<pre><code> &quot;columnDefs&quot;: [ {
   &quot;targets&quot;: [ 0 ],
   &quot;data&quot;: null, // Use the full data source object for the renderer&#39;s source
   &quot;render&quot;: &quot;browserName()&quot;
 } ]</code></pre>
<p>   } );
 } );</p>
<p>@example
 // As an object, extracting different data for the different types
 // This would be used with a data source such as:
 //   { &quot;phone&quot;: 5552368, &quot;phone_filter&quot;: &quot;5552368 555-2368&quot;, &quot;phone_display&quot;: &quot;555-2368&quot; }
 // Here the <code>phone</code> integer is used for sorting and type detection, while <code>phone_filter</code>
 // (which has both forms) is used for filtering for if a user inputs either format, while
 // the formatted phone number is the one that is shown in the table.
 $(document).ready( function() {
   $(&#39;#example&#39;).dataTable( {</p>
<pre><code> &quot;columnDefs&quot;: [ {
   &quot;targets&quot;: [ 0 ],
   &quot;data&quot;: null, // Use the full data source object for the renderer&#39;s source
   &quot;render&quot;: {
     &quot;_&quot;: &quot;phone&quot;,
     &quot;filter&quot;: &quot;phone_filter&quot;,
     &quot;display&quot;: &quot;phone_display&quot;
   }
 } ]</code></pre>
<p>   } );
 } );</p>
<p>@example
 // Use as a function to create a link from the data source
 $(document).ready( function() {
   $(&#39;#example&#39;).dataTable( {</p>
<pre><code> &quot;columnDefs&quot;: [ {
   &quot;targets&quot;: [ 0 ],
   &quot;data&quot;: &quot;download_link&quot;,
   &quot;render&quot;: function ( data, type, full ) {
     return &#39;&lt;a href=&quot;&#39;+data+&#39;&quot;&gt;Download&lt;/a&gt;&#39;;
   }
 } ]</code></pre>
<p>   } );
 } );</p>
</li>
</ul></div></div><div class="code"><div class="wrapper">		<span class="hljs-string">"mRender"</span>: <span class="hljs-literal">null</span>,
	
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Change the cell type created for the column - either TD cells or TH cells. This
can be useful as TH cells have semantic meaning in the table body, allowing them
to act as a header for a row (you may wish to add scope=&#39;row&#39; to the TH elements).
 @type string
 @default td</p>
<p> @name DataTable.defaults.column.cellType
 @dtopt Columns</p>
<p> @example
   // Make the first column use TH cells
   $(document).ready( function() {
     $(&#39;#example&#39;).dataTable( {
       &quot;columnDefs&quot;: [ {
         &quot;targets&quot;: [ 0 ],
         &quot;cellType&quot;: &quot;th&quot;
       } ]
     } );
   } );</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-string">"sCellType"</span>: <span class="hljs-string">"td"</span>,
	
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Class to give to each cell in this column.
 @type string
 @default <i>Empty string</i></p>
<p> @name DataTable.defaults.column.class
 @dtopt Columns</p>
<p> @example
   // Using <code>columnDefs</code>
   $(document).ready( function() {
     $(&#39;#example&#39;).dataTable( {
       &quot;columnDefs&quot;: [
         { &quot;class&quot;: &quot;my_class&quot;, &quot;targets&quot;: [ 0 ] }
       ]
     } );
   } );</p>
<p> @example
   // Using <code>columns</code>
   $(document).ready( function() {
     $(&#39;#example&#39;).dataTable( {
       &quot;columns&quot;: [
         { &quot;class&quot;: &quot;my_class&quot; },
         null,
         null,
         null,
         null
       ]
     } );
   } );</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-string">"sClass"</span>: <span class="hljs-string">""</span>,
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>When DataTables calculates the column widths to assign to each column,
it finds the longest string in each column and then constructs a
temporary table and reads the widths from that. The problem with this
is that &quot;mmm&quot; is much wider then &quot;iiii&quot;, but the latter is a longer
string - thus the calculation can go wrong (doing it properly and putting
it into an DOM object and measuring that is horribly(!) slow). Thus as
a &quot;work around&quot; we provide this option. It will append its value to the
text that is found to be the longest string for the column - i.e. padding.
Generally you shouldn&#39;t need this!
 @type string
 @default <i>Empty string<i></p>
<p> @name DataTable.defaults.column.contentPadding
 @dtopt Columns</p>
<p> @example
   // Using <code>columns</code>
   $(document).ready( function() {
     $(&#39;#example&#39;).dataTable( {
       &quot;columns&quot;: [
         null,
         null,
         null,
         {
           &quot;contentPadding&quot;: &quot;mmm&quot;
         }
       ]
     } );
   } );</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-string">"sContentPadding"</span>: <span class="hljs-string">""</span>,
	
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Allows a default value to be given for a column&#39;s data, and will be used
whenever a null data source is encountered (this can be because <code>data</code>
is set to null, or because the data source itself is null).
 @type string
 @default null</p>
<p> @name DataTable.defaults.column.defaultContent
 @dtopt Columns</p>
<p> @example
   // Using <code>columnDefs</code>
   $(document).ready( function() {
     $(&#39;#example&#39;).dataTable( {
       &quot;columnDefs&quot;: [
         {
           &quot;data&quot;: null,
           &quot;defaultContent&quot;: &quot;Edit&quot;,
           &quot;targets&quot;: [ -1 ]
         }
       ]
     } );
   } );</p>
<p> @example
   // Using <code>columns</code>
   $(document).ready( function() {
     $(&#39;#example&#39;).dataTable( {
       &quot;columns&quot;: [
         null,
         null,
         null,
         {
           &quot;data&quot;: null,
           &quot;defaultContent&quot;: &quot;Edit&quot;
         }
       ]
     } );
   } );</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-string">"sDefaultContent"</span>: <span class="hljs-literal">null</span>,
	
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>This parameter is only used in DataTables&#39; server-side processing. It can
be exceptionally useful to know what columns are being displayed on the
client side, and to map these to database fields. When defined, the names
also allow DataTables to reorder information from the server if it comes
back in an unexpected order (i.e. if you switch your columns around on the
client-side, your server-side code does not also need updating).
 @type string
 @default <i>Empty string</i></p>
<p> @name DataTable.defaults.column.name
 @dtopt Columns</p>
<p> @example
   // Using <code>columnDefs</code>
   $(document).ready( function() {
     $(&#39;#example&#39;).dataTable( {
       &quot;columnDefs&quot;: [
         { &quot;name&quot;: &quot;engine&quot;, &quot;targets&quot;: [ 0 ] },
         { &quot;name&quot;: &quot;browser&quot;, &quot;targets&quot;: [ 1 ] },
         { &quot;name&quot;: &quot;platform&quot;, &quot;targets&quot;: [ 2 ] },
         { &quot;name&quot;: &quot;version&quot;, &quot;targets&quot;: [ 3 ] },
         { &quot;name&quot;: &quot;grade&quot;, &quot;targets&quot;: [ 4 ] }
       ]
     } );
   } );</p>
<p> @example
   // Using <code>columns</code>
   $(document).ready( function() {
     $(&#39;#example&#39;).dataTable( {
       &quot;columns&quot;: [
         { &quot;name&quot;: &quot;engine&quot; },
         { &quot;name&quot;: &quot;browser&quot; },
         { &quot;name&quot;: &quot;platform&quot; },
         { &quot;name&quot;: &quot;version&quot; },
         { &quot;name&quot;: &quot;grade&quot; }
       ]
     } );
   } );</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-string">"sName"</span>: <span class="hljs-string">""</span>,
	
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Defines a data source type for the ordering which can be used to read
real-time information from the table (updating the internally cached
version) prior to ordering. This allows ordering to occur on user
editable elements such as form inputs.
 @type string
 @default std</p>
<p> @name DataTable.defaults.column.orderDataType
 @dtopt Columns</p>
<p> @example
   // Using <code>columnDefs</code>
   $(document).ready( function() {
     $(&#39;#example&#39;).dataTable( {
       &quot;columnDefs&quot;: [
         { &quot;orderDataType&quot;: &quot;dom-text&quot;, &quot;targets&quot;: [ 2, 3 ] },
         { &quot;type&quot;: &quot;numeric&quot;, &quot;targets&quot;: [ 3 ] },
         { &quot;orderDataType&quot;: &quot;dom-select&quot;, &quot;targets&quot;: [ 4 ] },
         { &quot;orderDataType&quot;: &quot;dom-checkbox&quot;, &quot;targets&quot;: [ 5 ] }
       ]
     } );
   } );</p>
<p> @example
   // Using <code>columns</code>
   $(document).ready( function() {
     $(&#39;#example&#39;).dataTable( {
       &quot;columns&quot;: [
         null,
         null,
         { &quot;orderDataType&quot;: &quot;dom-text&quot; },
         { &quot;orderDataType&quot;: &quot;dom-text&quot;, &quot;type&quot;: &quot;numeric&quot; },
         { &quot;orderDataType&quot;: &quot;dom-select&quot; },
         { &quot;orderDataType&quot;: &quot;dom-checkbox&quot; }
       ]
     } );
   } );</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-string">"sSortDataType"</span>: <span class="hljs-string">"std"</span>,
	
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>The title of this column.
 @type string
 @default null <i>Derived from the &#39;TH&#39; value for this column in the
   original HTML table.</i></p>
<p> @name DataTable.defaults.column.title
 @dtopt Columns</p>
<p> @example
   // Using <code>columnDefs</code>
   $(document).ready( function() {
     $(&#39;#example&#39;).dataTable( {
       &quot;columnDefs&quot;: [
         { &quot;title&quot;: &quot;My column title&quot;, &quot;targets&quot;: [ 0 ] }
       ]
     } );
   } );</p>
<p> @example
   // Using <code>columns</code>
   $(document).ready( function() {
     $(&#39;#example&#39;).dataTable( {
       &quot;columns&quot;: [
         { &quot;title&quot;: &quot;My column title&quot; },
         null,
         null,
         null,
         null
       ]
     } );
   } );</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-string">"sTitle"</span>: <span class="hljs-literal">null</span>,
	
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>The type allows you to specify how the data for this column will be
ordered. Four types (string, numeric, date and html (which will strip
HTML tags before ordering)) are currently available. Note that only date
formats understood by Javascript&#39;s Date() object will be accepted as type
date. For example: &quot;Mar 26, 2008 5:03 PM&quot;. May take the values: &#39;string&#39;,
&#39;numeric&#39;, &#39;date&#39; or &#39;html&#39; (by default). Further types can be adding
through plug-ins.
 @type string
 @default null <i>Auto-detected from raw data</i></p>
<p> @name DataTable.defaults.column.type
 @dtopt Columns</p>
<p> @example
   // Using <code>columnDefs</code>
   $(document).ready( function() {
     $(&#39;#example&#39;).dataTable( {
       &quot;columnDefs&quot;: [
         { &quot;type&quot;: &quot;html&quot;, &quot;targets&quot;: [ 0 ] }
       ]
     } );
   } );</p>
<p> @example
   // Using <code>columns</code>
   $(document).ready( function() {
     $(&#39;#example&#39;).dataTable( {
       &quot;columns&quot;: [
         { &quot;type&quot;: &quot;html&quot; },
         null,
         null,
         null,
         null
       ]
     } );
   } );</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-string">"sType"</span>: <span class="hljs-literal">null</span>,
	
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Defining the width of the column, this parameter may take any CSS value
(3em, 20px etc). DataTables applies &#39;smart&#39; widths to columns which have not
been given a specific width through this interface ensuring that the table
remains readable.
 @type string
 @default null <i>Automatic</i></p>
<p> @name DataTable.defaults.column.width
 @dtopt Columns</p>
<p> @example
   // Using <code>columnDefs</code>
   $(document).ready( function() {
     $(&#39;#example&#39;).dataTable( {
       &quot;columnDefs&quot;: [
         { &quot;width&quot;: &quot;20%&quot;, &quot;targets&quot;: [ 0 ] }
       ]
     } );
   } );</p>
<p> @example
   // Using <code>columns</code>
   $(document).ready( function() {
     $(&#39;#example&#39;).dataTable( {
       &quot;columns&quot;: [
         { &quot;width&quot;: &quot;20%&quot; },
         null,
         null,
         null,
         null
       ]
     } );
   } );</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-string">"sWidth"</span>: <span class="hljs-literal">null</span>
	};
	
	_fnHungarianMap( DataTable.defaults.column );
	
	
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>DataTables settings object - this holds all the information needed for a
given table, including configuration, data and current application of the
table options. DataTables does not have a single instance for each DataTable
with the settings attached to that instance, but rather instances of the
DataTable &quot;class&quot; are created on-the-fly as needed (typically by a
$().dataTable() call) and the settings object is then applied to that
instance.</p>
<p>Note that this object is related to {@link DataTable.defaults} but this
one is the internal data store for DataTables&#39;s cache of columns. It should
NOT be manipulated outside of DataTables. Any configuration should be done
through the initialisation options.
 @namespace
 @todo Really should attach the settings object to individual instances so we
   don&#39;t need to create new instances on each $().dataTable() call (if the
   table already exists). It would also save passing oSettings around and
   into every single function. However, this is a very significant
   architecture change for DataTables and will almost certainly break
   backwards compatibility with older installations. This is something that
   will be done in 2.0.</p></div></div><div class="code"><div class="wrapper">	DataTable.models.oSettings = {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Primary features of DataTables and their enablement state.
 @namespace</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-string">"oFeatures"</span>: {
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Flag to say if DataTables should automatically try to calculate the
optimum table and columns widths (true) or not (false).
Note that this parameter will be set by the initialisation routine. To
set a default use {@link DataTable.defaults}.
 @type boolean</p></div></div><div class="code"><div class="wrapper">			<span class="hljs-string">"bAutoWidth"</span>: <span class="hljs-literal">null</span>,
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Delay the creation of TR and TD elements until they are actually
needed by a driven page draw. This can give a significant speed
increase for Ajax source and Javascript source data, but makes no
difference at all fro DOM and server-side processing tables.
Note that this parameter will be set by the initialisation routine. To
set a default use {@link DataTable.defaults}.
 @type boolean</p></div></div><div class="code"><div class="wrapper">			<span class="hljs-string">"bDeferRender"</span>: <span class="hljs-literal">null</span>,
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Enable filtering on the table or not. Note that if this is disabled
then there is no filtering at all on the table, including fnFilter.
To just remove the filtering input use sDom and remove the &#39;f&#39; option.
Note that this parameter will be set by the initialisation routine. To
set a default use {@link DataTable.defaults}.
 @type boolean</p></div></div><div class="code"><div class="wrapper">			<span class="hljs-string">"bFilter"</span>: <span class="hljs-literal">null</span>,
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Table information element (the &#39;Showing x of y records&#39; div) enable
flag.
Note that this parameter will be set by the initialisation routine. To
set a default use {@link DataTable.defaults}.
 @type boolean</p></div></div><div class="code"><div class="wrapper">			<span class="hljs-string">"bInfo"</span>: <span class="hljs-literal">null</span>,
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Present a user control allowing the end user to change the page size
when pagination is enabled.
Note that this parameter will be set by the initialisation routine. To
set a default use {@link DataTable.defaults}.
 @type boolean</p></div></div><div class="code"><div class="wrapper">			<span class="hljs-string">"bLengthChange"</span>: <span class="hljs-literal">null</span>,
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Pagination enabled or not. Note that if this is disabled then length
changing must also be disabled.
Note that this parameter will be set by the initialisation routine. To
set a default use {@link DataTable.defaults}.
 @type boolean</p></div></div><div class="code"><div class="wrapper">			<span class="hljs-string">"bPaginate"</span>: <span class="hljs-literal">null</span>,
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Processing indicator enable flag whenever DataTables is enacting a
user request - typically an Ajax request for server-side processing.
Note that this parameter will be set by the initialisation routine. To
set a default use {@link DataTable.defaults}.
 @type boolean</p></div></div><div class="code"><div class="wrapper">			<span class="hljs-string">"bProcessing"</span>: <span class="hljs-literal">null</span>,
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Server-side processing enabled flag - when enabled DataTables will
get all data from the server for every draw - there is no filtering,
sorting or paging done on the client-side.
Note that this parameter will be set by the initialisation routine. To
set a default use {@link DataTable.defaults}.
 @type boolean</p></div></div><div class="code"><div class="wrapper">			<span class="hljs-string">"bServerSide"</span>: <span class="hljs-literal">null</span>,
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Sorting enablement flag.
Note that this parameter will be set by the initialisation routine. To
set a default use {@link DataTable.defaults}.
 @type boolean</p></div></div><div class="code"><div class="wrapper">			<span class="hljs-string">"bSort"</span>: <span class="hljs-literal">null</span>,
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Multi-column sorting
Note that this parameter will be set by the initialisation routine. To
set a default use {@link DataTable.defaults}.
 @type boolean</p></div></div><div class="code"><div class="wrapper">			<span class="hljs-string">"bSortMulti"</span>: <span class="hljs-literal">null</span>,
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Apply a class to the columns which are being sorted to provide a
visual highlight or not. This can slow things down when enabled since
there is a lot of DOM interaction.
Note that this parameter will be set by the initialisation routine. To
set a default use {@link DataTable.defaults}.
 @type boolean</p></div></div><div class="code"><div class="wrapper">			<span class="hljs-string">"bSortClasses"</span>: <span class="hljs-literal">null</span>,
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>State saving enablement flag.
Note that this parameter will be set by the initialisation routine. To
set a default use {@link DataTable.defaults}.
 @type boolean</p></div></div><div class="code"><div class="wrapper">			<span class="hljs-string">"bStateSave"</span>: <span class="hljs-literal">null</span>
		},
	
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Scrolling settings for a table.
 @namespace</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-string">"oScroll"</span>: {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>When the table is shorter in height than sScrollY, collapse the
table container down to the height of the table (when true).
Note that this parameter will be set by the initialisation routine. To
set a default use {@link DataTable.defaults}.
 @type boolean</p></div></div><div class="code"><div class="wrapper">			<span class="hljs-string">"bCollapse"</span>: <span class="hljs-literal">null</span>,
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Width of the scrollbar for the web-browser&#39;s platform. Calculated
during table initialisation.
 @type int
 @default 0</p></div></div><div class="code"><div class="wrapper">			<span class="hljs-string">"iBarWidth"</span>: <span class="hljs-number">0</span>,
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Viewport width for horizontal scrolling. Horizontal scrolling is
disabled if an empty string.
Note that this parameter will be set by the initialisation routine. To
set a default use {@link DataTable.defaults}.
 @type string</p></div></div><div class="code"><div class="wrapper">			<span class="hljs-string">"sX"</span>: <span class="hljs-literal">null</span>,
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Width to expand the table to when using x-scrolling. Typically you
should not need to use this.
Note that this parameter will be set by the initialisation routine. To
set a default use {@link DataTable.defaults}.
 @type string
 @deprecated</p></div></div><div class="code"><div class="wrapper">			<span class="hljs-string">"sXInner"</span>: <span class="hljs-literal">null</span>,
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Viewport height for vertical scrolling. Vertical scrolling is disabled
if an empty string.
Note that this parameter will be set by the initialisation routine. To
set a default use {@link DataTable.defaults}.
 @type string</p></div></div><div class="code"><div class="wrapper">			<span class="hljs-string">"sY"</span>: <span class="hljs-literal">null</span>
		},
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Language information for the table.
 @namespace
 @extends DataTable.defaults.oLanguage</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-string">"oLanguage"</span>: {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Information callback function. See
{@link DataTable.defaults.fnInfoCallback}
 @type function
 @default null</p></div></div><div class="code"><div class="wrapper">			<span class="hljs-string">"fnInfoCallback"</span>: <span class="hljs-literal">null</span>
		},
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Browser support parameters
 @namespace</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-string">"oBrowser"</span>: {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Indicate if the browser incorrectly calculates width:100% inside a
scrolling element (IE6/7)
 @type boolean
 @default false</p></div></div><div class="code"><div class="wrapper">			<span class="hljs-string">"bScrollOversize"</span>: <span class="hljs-literal">false</span>,
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Determine if the vertical scrollbar is on the right or left of the
scrolling container - needed for rtl language layout, although not
all browsers move the scrollbar (Safari).
 @type boolean
 @default false</p></div></div><div class="code"><div class="wrapper">			<span class="hljs-string">"bScrollbarLeft"</span>: <span class="hljs-literal">false</span>
		},
	
	
		<span class="hljs-string">"ajax"</span>: <span class="hljs-literal">null</span>,
	
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Array referencing the nodes which are used for the features. The
parameters of this object match what is allowed by sDom - i.e.
  <ul>
    <li>&#39;l&#39; - Length changing</li>
    <li>&#39;f&#39; - Filtering input</li>
    <li>&#39;t&#39; - The table!</li>
    <li>&#39;i&#39; - Information</li>
    <li>&#39;p&#39; - Pagination</li>
    <li>&#39;r&#39; - pRocessing</li>
  </ul>
 @type array
 @default []</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-string">"aanFeatures"</span>: [],
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Store data information - see {@link DataTable.models.oRow} for detailed
information.
 @type array
 @default []</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-string">"aoData"</span>: [],
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Array of indexes which are in the current display (after filtering etc)
 @type array
 @default []</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-string">"aiDisplay"</span>: [],
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Array of indexes for display - no filtering
 @type array
 @default []</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-string">"aiDisplayMaster"</span>: [],
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Store information about each column that is in use
 @type array
 @default []</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-string">"aoColumns"</span>: [],
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Store information about the table&#39;s header
 @type array
 @default []</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-string">"aoHeader"</span>: [],
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Store information about the table&#39;s footer
 @type array
 @default []</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-string">"aoFooter"</span>: [],
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Store the applied global search information in case we want to force a
research or compare the old search to a new one.
Note that this parameter will be set by the initialisation routine. To
set a default use {@link DataTable.defaults}.
 @namespace
 @extends DataTable.models.oSearch</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-string">"oPreviousSearch"</span>: {},
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Store the applied search for each column - see
{@link DataTable.models.oSearch} for the format that is used for the
filtering information for each column.
 @type array
 @default []</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-string">"aoPreSearchCols"</span>: [],
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Sorting that is applied to the table. Note that the inner arrays are
used in the following manner:</p>
<p><ul>
  <li>Index 0 - column number</li>
  <li>Index 1 - current sorting direction</li>
</ul>
Note that this parameter will be set by the initialisation routine. To
set a default use {@link DataTable.defaults}.
 @type array
 @todo These inner arrays should really be objects</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-string">"aaSorting"</span>: <span class="hljs-literal">null</span>,
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Sorting that is always applied to the table (i.e. prefixed in front of
aaSorting).
Note that this parameter will be set by the initialisation routine. To
set a default use {@link DataTable.defaults}.
 @type array
 @default []</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-string">"aaSortingFixed"</span>: [],
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Classes to use for the striping of a table.
Note that this parameter will be set by the initialisation routine. To
set a default use {@link DataTable.defaults}.
 @type array
 @default []</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-string">"asStripeClasses"</span>: <span class="hljs-literal">null</span>,
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>If restoring a table - we should restore its striping classes as well
 @type array
 @default []</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-string">"asDestroyStripes"</span>: [],
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>If restoring a table - we should restore its width
 @type int
 @default 0</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-string">"sDestroyWidth"</span>: <span class="hljs-number">0</span>,
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Callback functions array for every time a row is inserted (i.e. on a draw).
 @type array
 @default []</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-string">"aoRowCallback"</span>: [],
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Callback functions for the header on each draw.
 @type array
 @default []</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-string">"aoHeaderCallback"</span>: [],
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Callback function for the footer on each draw.
 @type array
 @default []</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-string">"aoFooterCallback"</span>: [],
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Array of callback functions for draw callback functions
 @type array
 @default []</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-string">"aoDrawCallback"</span>: [],
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Array of callback functions for row created function
 @type array
 @default []</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-string">"aoRowCreatedCallback"</span>: [],
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Callback functions for just before the table is redrawn. A return of
false will be used to cancel the draw.
 @type array
 @default []</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-string">"aoPreDrawCallback"</span>: [],
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Callback functions for when the table has been initialised.
 @type array
 @default []</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-string">"aoInitComplete"</span>: [],
	
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Callbacks for modifying the settings to be stored for state saving, prior to
saving state.
 @type array
 @default []</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-string">"aoStateSaveParams"</span>: [],
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Callbacks for modifying the settings that have been stored for state saving
prior to using the stored values to restore the state.
 @type array
 @default []</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-string">"aoStateLoadParams"</span>: [],
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Callbacks for operating on the settings object once the saved state has been
loaded
 @type array
 @default []</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-string">"aoStateLoaded"</span>: [],
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Cache the table ID for quick access
 @type string
 @default <i>Empty string</i></p></div></div><div class="code"><div class="wrapper">		<span class="hljs-string">"sTableId"</span>: <span class="hljs-string">""</span>,
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>The TABLE node for the main table
 @type node
 @default null</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-string">"nTable"</span>: <span class="hljs-literal">null</span>,
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Permanent ref to the thead element
 @type node
 @default null</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-string">"nTHead"</span>: <span class="hljs-literal">null</span>,
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Permanent ref to the tfoot element - if it exists
 @type node
 @default null</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-string">"nTFoot"</span>: <span class="hljs-literal">null</span>,
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Permanent ref to the tbody element
 @type node
 @default null</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-string">"nTBody"</span>: <span class="hljs-literal">null</span>,
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Cache the wrapper node (contains all DataTables controlled elements)
 @type node
 @default null</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-string">"nTableWrapper"</span>: <span class="hljs-literal">null</span>,
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Indicate if when using server-side processing the loading of data
should be deferred until the second draw.
Note that this parameter will be set by the initialisation routine. To
set a default use {@link DataTable.defaults}.
 @type boolean
 @default false</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-string">"bDeferLoading"</span>: <span class="hljs-literal">false</span>,
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Indicate if all required information has been read in
 @type boolean
 @default false</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-string">"bInitialised"</span>: <span class="hljs-literal">false</span>,
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Information about open rows. Each object in the array has the parameters
&#39;nTr&#39; and &#39;nParent&#39;
 @type array
 @default []</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-string">"aoOpenRows"</span>: [],
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Dictate the positioning of DataTables&#39; control elements - see
{@link DataTable.model.oInit.sDom}.
Note that this parameter will be set by the initialisation routine. To
set a default use {@link DataTable.defaults}.
 @type string
 @default null</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-string">"sDom"</span>: <span class="hljs-literal">null</span>,
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Which type of pagination should be used.
Note that this parameter will be set by the initialisation routine. To
set a default use {@link DataTable.defaults}.
 @type string
 @default two_button</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-string">"sPaginationType"</span>: <span class="hljs-string">"two_button"</span>,
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>The state duration (for <code>stateSave</code>) in seconds.
Note that this parameter will be set by the initialisation routine. To
set a default use {@link DataTable.defaults}.
 @type int
 @default 0</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-string">"iStateDuration"</span>: <span class="hljs-number">0</span>,
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Array of callback functions for state saving. Each array element is an
object with the following parameters:
  <ul>
    <li>function:fn - function to call. Takes two parameters, oSettings
      and the JSON string to save that has been thus far created. Returns
      a JSON string to be inserted into a json object
      (i.e. &#39;&quot;param&quot;: [ 0, 1, 2]&#39;)</li>
    <li>string:sName - name of callback</li>
  </ul>
 @type array
 @default []</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-string">"aoStateSave"</span>: [],
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Array of callback functions for state loading. Each array element is an
object with the following parameters:
  <ul>
    <li>function:fn - function to call. Takes two parameters, oSettings
      and the object stored. May return false to cancel state loading</li>
    <li>string:sName - name of callback</li>
  </ul>
 @type array
 @default []</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-string">"aoStateLoad"</span>: [],
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>State that was saved. Useful for back reference
 @type object
 @default null</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-string">"oSavedState"</span>: <span class="hljs-literal">null</span>,
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>State that was loaded. Useful for back reference
 @type object
 @default null</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-string">"oLoadedState"</span>: <span class="hljs-literal">null</span>,
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Source url for AJAX data for the table.
Note that this parameter will be set by the initialisation routine. To
set a default use {@link DataTable.defaults}.
 @type string
 @default null</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-string">"sAjaxSource"</span>: <span class="hljs-literal">null</span>,
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Property from a given object from which to read the table data from. This
can be an empty string (when not server-side processing), in which case
it is  assumed an an array is given directly.
Note that this parameter will be set by the initialisation routine. To
set a default use {@link DataTable.defaults}.
 @type string</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-string">"sAjaxDataProp"</span>: <span class="hljs-literal">null</span>,
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Note if draw should be blocked while getting data
 @type boolean
 @default true</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-string">"bAjaxDataGet"</span>: <span class="hljs-literal">true</span>,
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>The last jQuery XHR object that was used for server-side data gathering.
This can be used for working with the XHR information in one of the
callbacks
 @type object
 @default null</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-string">"jqXHR"</span>: <span class="hljs-literal">null</span>,
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>JSON returned from the server in the last Ajax request
 @type object
 @default undefined</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-string">"json"</span>: <span class="hljs-literal">undefined</span>,
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Data submitted as part of the last Ajax request
 @type object
 @default undefined</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-string">"oAjaxData"</span>: <span class="hljs-literal">undefined</span>,
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Function to get the server-side data.
Note that this parameter will be set by the initialisation routine. To
set a default use {@link DataTable.defaults}.
 @type function</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-string">"fnServerData"</span>: <span class="hljs-literal">null</span>,
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Functions which are called prior to sending an Ajax request so extra
parameters can easily be sent to the server
 @type array
 @default []</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-string">"aoServerParams"</span>: [],
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Send the XHR HTTP method - GET or POST (could be PUT or DELETE if
required).
Note that this parameter will be set by the initialisation routine. To
set a default use {@link DataTable.defaults}.
 @type string</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-string">"sServerMethod"</span>: <span class="hljs-literal">null</span>,
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Format numbers for display.
Note that this parameter will be set by the initialisation routine. To
set a default use {@link DataTable.defaults}.
 @type function</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-string">"fnFormatNumber"</span>: <span class="hljs-literal">null</span>,
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>List of options that can be used for the user selectable length menu.
Note that this parameter will be set by the initialisation routine. To
set a default use {@link DataTable.defaults}.
 @type array
 @default []</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-string">"aLengthMenu"</span>: <span class="hljs-literal">null</span>,
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Counter for the draws that the table does. Also used as a tracker for
server-side processing
 @type int
 @default 0</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-string">"iDraw"</span>: <span class="hljs-number">0</span>,
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Indicate if a redraw is being done - useful for Ajax
 @type boolean
 @default false</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-string">"bDrawing"</span>: <span class="hljs-literal">false</span>,
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Draw index (iDraw) of the last error when parsing the returned data
 @type int
 @default -1</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-string">"iDrawError"</span>: -<span class="hljs-number">1</span>,
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Paging display length
 @type int
 @default 10</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-string">"_iDisplayLength"</span>: <span class="hljs-number">50</span>,
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Paging start point - aiDisplay index
 @type int
 @default 0</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-string">"_iDisplayStart"</span>: <span class="hljs-number">0</span>,
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Server-side processing - number of records in the result set
(i.e. before filtering), Use fnRecordsTotal rather than
this property to get the value of the number of records, regardless of
the server-side processing setting.
 @type int
 @default 0
 @private</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-string">"_iRecordsTotal"</span>: <span class="hljs-number">0</span>,
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Server-side processing - number of records in the current display set
(i.e. after filtering). Use fnRecordsDisplay rather than
this property to get the value of the number of records, regardless of
the server-side processing setting.
 @type boolean
 @default 0
 @private</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-string">"_iRecordsDisplay"</span>: <span class="hljs-number">0</span>,
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Flag to indicate if jQuery UI marking and classes should be used.
Note that this parameter will be set by the initialisation routine. To
set a default use {@link DataTable.defaults}.
 @type boolean</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-string">"bJUI"</span>: <span class="hljs-literal">null</span>,
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>The classes to use for the table
 @type object
 @default {}</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-string">"oClasses"</span>: {},
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Flag attached to the settings object so you can check in the draw
callback if filtering has been done in the draw. Deprecated in favour of
events.
 @type boolean
 @default false
 @deprecated</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-string">"bFiltered"</span>: <span class="hljs-literal">false</span>,
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Flag attached to the settings object so you can check in the draw
callback if sorting has been done in the draw. Deprecated in favour of
events.
 @type boolean
 @default false
 @deprecated</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-string">"bSorted"</span>: <span class="hljs-literal">false</span>,
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Indicate that if multiple rows are in the header and there is more than
one unique cell per column, if the top one (true) or bottom one (false)
should be used for sorting / title by DataTables.
Note that this parameter will be set by the initialisation routine. To
set a default use {@link DataTable.defaults}.
 @type boolean</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-string">"bSortCellsTop"</span>: <span class="hljs-literal">null</span>,
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Initialisation object that is used for the table
 @type object
 @default null</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-string">"oInit"</span>: <span class="hljs-literal">null</span>,
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Destroy callback functions - for plug-ins to attach themselves to the
destroy so they can clean up markup and events.
 @type array
 @default []</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-string">"aoDestroyCallback"</span>: [],
	
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Get the number of records in the current record set, before filtering
 @type function</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-string">"fnRecordsTotal"</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span>
		{</span>
			<span class="hljs-keyword">return</span> _fnDataSource( <span class="hljs-keyword">this</span> ) == <span class="hljs-string">'ssp'</span> ?
				<span class="hljs-keyword">this</span>._iRecordsTotal * <span class="hljs-number">1</span> :
				<span class="hljs-keyword">this</span>.aiDisplayMaster.length;
		},
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Get the number of records in the current record set, after filtering
 @type function</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-string">"fnRecordsDisplay"</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span>
		{</span>
			<span class="hljs-keyword">return</span> _fnDataSource( <span class="hljs-keyword">this</span> ) == <span class="hljs-string">'ssp'</span> ?
				<span class="hljs-keyword">this</span>._iRecordsDisplay * <span class="hljs-number">1</span> :
				<span class="hljs-keyword">this</span>.aiDisplay.length;
		},
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Get the display end point - aiDisplay index
 @type function</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-string">"fnDisplayEnd"</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span>
		{</span>
			<span class="hljs-keyword">var</span>
				len      = <span class="hljs-keyword">this</span>._iDisplayLength,
				start    = <span class="hljs-keyword">this</span>._iDisplayStart,
				calc     = start + len,
				records  = <span class="hljs-keyword">this</span>.aiDisplay.length,
				features = <span class="hljs-keyword">this</span>.oFeatures,
				paginate = features.bPaginate;
	
			<span class="hljs-keyword">if</span> ( features.bServerSide ) {
				<span class="hljs-keyword">return</span> paginate === <span class="hljs-literal">false</span> || len === -<span class="hljs-number">1</span> ?
					start + records :
					<span class="hljs-built_in">Math</span>.min( start+len, <span class="hljs-keyword">this</span>._iRecordsDisplay );
			}
			<span class="hljs-keyword">else</span> {
				<span class="hljs-keyword">return</span> ! paginate || calc&gt;records || len===-<span class="hljs-number">1</span> ?
					records :
					calc;
			}
		},
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>The DataTables object for this table
 @type object
 @default null</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-string">"oInstance"</span>: <span class="hljs-literal">null</span>,
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Unique identifier for each instance of the DataTables object. If there
is an ID on the table node, then it takes that value, otherwise an
incrementing internal counter is used.
 @type string
 @default null</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-string">"sInstance"</span>: <span class="hljs-literal">null</span>,
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>tabindex attribute value that is added to DataTables control elements, allowing
keyboard navigation of the table and its controls.</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-string">"iTabIndex"</span>: <span class="hljs-number">0</span>,
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>DIV container for the footer scrolling table if scrolling</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-string">"nScrollHead"</span>: <span class="hljs-literal">null</span>,
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>DIV container for the footer scrolling table if scrolling</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-string">"nScrollFoot"</span>: <span class="hljs-literal">null</span>,
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Last applied sort
 @type array
 @default []</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-string">"aLastSort"</span>: [],
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Stored plug-in instances
 @type object
 @default {}</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-string">"oPlugins"</span>: {}
	};</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Extension object for DataTables that is used to provide all extension
options.</p>
<p>Note that the <code>DataTable.ext</code> object is available through
<code>jQuery.fn.dataTable.ext</code> where it may be accessed and manipulated. It is
also aliased to <code>jQuery.fn.dataTableExt</code> for historic reasons.
 @namespace
 @extends DataTable.models.ext</p></div></div><div class="code"><div class="wrapper">	
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>DataTables extensions</p>
<p>This namespace acts as a collection area for plug-ins that can be used to
extend DataTables capabilities. Indeed many of the build in methods
use this method to provide their own capabilities (sorting methods for
example).</p>
<p>Note that this namespace is aliased to <code>jQuery.fn.dataTableExt</code> for legacy
reasons</p>
<p> @namespace</p></div></div><div class="code"><div class="wrapper">	DataTable.ext = _ext = {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Element class names</p>
<p> @type object
 @default {}</p></div></div><div class="code"><div class="wrapper">		classes: {},
	
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Error reporting.</p>
<p>How should DataTables report an error. Can take the value &#39;alert&#39; or
&#39;throw&#39;</p>
<p> @type string
 @default alert</p></div></div><div class="code"><div class="wrapper">		errMode: <span class="hljs-string">"alert"</span>,
	
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Feature plug-ins.</p>
<p>This is an array of objects which describe the feature plug-ins that are
available to DataTables. These feature plug-ins are then available for
use through the <code>dom</code> initialisation option.</p>
<p>Each feature plug-in is described by an object which must have the
following properties:</p>
<ul>
<li><code>fnInit</code> - function that is used to initialise the plug-in,</li>
<li><code>cFeature</code> - a character so the feature can be enabled by the <code>dom</code>
instillation option. This is case sensitive.</li>
</ul>
<p>The <code>fnInit</code> function has the following input parameters:</p>
<ol>
<li><code>{object}</code> DataTables settings object: see
{@link DataTable.models.oSettings}</li>
</ol>
<p>And the following return is expected:</p>
<ul>
<li><p>{node|null} The element which contains your feature. Note that the
return may also be void if your plug-in does not require to inject any
DOM elements into DataTables control (<code>dom</code>) - for example this might
be useful when developing a plug-in which allows table control via
keyboard entry</p>
<p>@type array</p>
<p>@example
 $.fn.dataTable.ext.features.push( {
   &quot;fnInit&quot;: function( oSettings ) {</p>
<pre><code> return new TableTools( { &quot;oDTSettings&quot;: oSettings } );</code></pre>
<p>   },
   &quot;cFeature&quot;: &quot;T&quot;
 } );</p>
</li>
</ul></div></div><div class="code"><div class="wrapper">		feature: [],
	
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Row searching.</p>
<p>This method of searching is complimentary to the default type based
searching, and a lot more comprehensive as it allows you complete control
over the searching logic. Each element in this array is a function
(parameters described below) that is called for every row in the table,
and your logic decides if it should be included in the searching data set
or not.</p>
<p>Searching functions have the following input parameters:</p>
<ol>
<li><code>{object}</code> DataTables settings object: see
{@link DataTable.models.oSettings}</li>
<li><code>{array|object}</code> Data for the row to be processed (same as the
original format that was passed in as the data source, or an array
from a DOM data source</li>
<li><code>{int}</code> Row index ({@link DataTable.models.oSettings.aoData}), which
can be useful to retrieve the <code>TR</code> element if you need DOM interaction.</li>
</ol>
<p>And the following return is expected:</p>
<ul>
<li>{boolean} Include the row in the searched result set (true) or not
(false)</li>
</ul>
<p>Note that as with the main search ability in DataTables, technically this
is &quot;filtering&quot;, since it is subtractive. However, for consistency in
naming we call it searching here.</p>
<p> @type array
 @default []</p>
<p> @example
   // The following example shows custom search being applied to the
   // fourth column (i.e. the data[3] index) based on two input values
   // from the end-user, matching the data in a certain range.
   $.fn.dataTable.ext.search.push(
     function( settings, data, dataIndex ) {
       var min = document.getElementById(&#39;min&#39;).value <em> 1;
       var max = document.getElementById(&#39;max&#39;).value </em> 1;
       var version = data[3] == &quot;-&quot; ? 0 : data[3]*1;</p>
<pre><code>   if ( min == &quot;&quot; &amp;&amp; max == &quot;&quot; ) {
     return true;
   }
   else if ( min == &quot;&quot; &amp;&amp; version &lt; max ) {
     return true;
   }
   else if ( min &lt; version &amp;&amp; &quot;&quot; == max ) {
     return true;
   }
   else if ( min &lt; version &amp;&amp; version &lt; max ) {
     return true;
   }
   return false;
 }</code></pre>
<p>   );</p></div></div><div class="code"><div class="wrapper">		search: [],
	
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Internal functions, exposed for used in plug-ins.</p>
<p>Please note that you should not need to use the internal methods for
anything other than a plug-in (and even then, try to avoid if possible).
The internal function may change between releases.</p>
<p> @type object
 @default {}</p></div></div><div class="code"><div class="wrapper">		internal: {},
	
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Legacy configuration options. Enable and disable legacy options that
are available in DataTables.</p>
<p> @type object</p></div></div><div class="code"><div class="wrapper">		legacy: {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Enable / disable DataTables 1.9 compatible server-side processing
requests</p>
<p> @type boolean
 @default null</p></div></div><div class="code"><div class="wrapper">			ajax: <span class="hljs-literal">null</span>
		},
	
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Pagination plug-in methods.</p>
<p>Each entry in this object is a function and defines which buttons should
be shown by the pagination rendering method that is used for the table:
{@link DataTable.ext.renderer.pageButton}. The renderer addresses how the
buttons are displayed in the document, while the functions here tell it
what buttons to display. This is done by returning an array of button
descriptions (what each button will do).</p>
<p>Pagination types (the four built in options and any additional plug-in
options defined here) can be used through the <code>paginationType</code>
initialisation parameter.</p>
<p>The functions defined take two parameters:</p>
<ol>
<li><code>{int} page</code> The current page index</li>
<li><code>{int} pages</code> The number of pages in the table</li>
</ol>
<p>Each function is expected to return an array where each element of the
array can be one of:</p>
<ul>
<li><code>first</code> - Jump to first page when activated</li>
<li><code>last</code> - Jump to last page when activated</li>
<li><code>previous</code> - Show previous page when activated</li>
<li><code>next</code> - Show next page when activated</li>
<li><code>{int}</code> - Show page of the index given</li>
<li><code>{array}</code> - A nested array containing the above elements to add a
containing &#39;DIV&#39; element (might be useful for styling).</li>
</ul>
<p>Note that DataTables v1.9- used this object slightly differently whereby
an object with two functions would be defined for each plug-in. That
ability is still supported by DataTables 1.10+ to provide backwards
compatibility, but this option of use is now decremented and no longer
documented in DataTables 1.10+.</p>
<p> @type object
 @default {}</p>
<p> @example
   // Show previous, next and current page buttons only
   $.fn.dataTableExt.oPagination.current = function ( page, pages ) {
     return [ &#39;previous&#39;, page, &#39;next&#39; ];
   };</p></div></div><div class="code"><div class="wrapper">		pager: {},
	
	
		renderer: {
			pageButton: {},
			header: {}
		},
	
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Ordering plug-ins - custom data source</p>
<p>The extension options for ordering of data available here is complimentary
to the default type based ordering that DataTables typically uses. It
allows much greater control over the the data that is being used to
order a column, but is necessarily therefore more complex.</p>
<p>This type of ordering is useful if you want to do ordering based on data
live from the DOM (for example the contents of an &#39;input&#39; element) rather
than just the static string that DataTables knows of.</p>
<p>The way these plug-ins work is that you create an array of the values you
wish to be ordering for the column in question and then return that
array. The data in the array much be in the index order of the rows in
the table (not the currently ordering order!). Which order data gathering
function is run here depends on the <code>dt-init columns.orderDataType</code>
parameter that is used for the column (if any).</p>
<p>The functions defined take two parameters:</p>
<ol>
<li><code>{object}</code> DataTables settings object: see
{@link DataTable.models.oSettings}</li>
<li><code>{int}</code> Target column index</li>
</ol>
<p>Each function is expected to return an array:</p>
<ul>
<li><p><code>{array}</code> Data for the column to be ordering upon</p>
<p>@type array</p>
<p>@example
 // Ordering using <code>input</code> node values
 $.fn.dataTable.ext.order[&#39;dom-text&#39;] = function  ( settings, col )
 {
   return this.api().column( col, {order:&#39;index&#39;} ).nodes().map( function ( td, i ) {</p>
<pre><code> return $(&#39;input&#39;, td).val();</code></pre>
<p>   } );
 }</p>
</li>
</ul></div></div><div class="code"><div class="wrapper">		order: {},
	
	</div></div></div><div class="segment"><div class="comments doc-section"><div class="wrapper"><p><span class='doc-section-header'> namespace</span></p>
<p>Type based plug-ins.</p>
<p>Each column in DataTables has a type assigned to it, either by automatic
detection or by direct assignment using the <code>type</code> option for the column.
The type of a column will effect how it is ordering and search (plug-ins
can also make use of the column type if required).</p></div></div><div class="code"><div class="wrapper">		type: {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Type detection functions.</p>
<p>The functions defined in this object are used to automatically detect
a column&#39;s type, making initialisation of DataTables super easy, even
when complex data is in the table.</p>
<p>The functions defined take two parameters:</p>
<ol>
<li><code>{*}</code> Data from the column cell to be analysed</li>
<li><code>{settings}</code> DataTables settings object. This can be used to
perform context specific type detection - for example detection
based on language settings such as using a comma for a decimal
place. Generally speaking the options from the settings will not
be required</li>
</ol>
<p>Each function is expected to return:</p>
<ul>
<li><p><code>{string|null}</code> Data type detected, or null if unknown (and thus
pass it on to the other type detection functions.</p>
<p>@type array</p>
<p>@example
 // Currency type detection plug-in:
 $.fn.dataTable.ext.type.detect.push(
   function ( data, settings ) {</p>
<pre><code> // Check the numeric part
 if ( ! $.isNumeric( data.substring(1) ) ) {
   return null;
 }

 // Check prefixed by currency
 if ( data.charAt(0) == &#39;$&#39; || data.charAt(0) == &#39;&amp;pound;&#39; ) {
   return &#39;currency&#39;;
 }
 return null;</code></pre>
<p>   }
 );</p>
</li>
</ul></div></div><div class="code"><div class="wrapper">			detect: [],
	
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Type based search formatting.</p>
<p>The type based searching functions can be used to pre-format the
data to be search on. For example, it can be used to strip HTML
tags or to de-format telephone numbers for numeric only searching.</p>
<p>Note that is a search is not defined for a column of a given type,
no search formatting will be performed.</p>
<p>Pre-processing of searching data plug-ins - When you assign the sType
for a column (or have it automatically detected for you by DataTables
or a type detection plug-in), you will typically be using this for
custom sorting, but it can also be used to provide custom searching
by allowing you to pre-processing the data and returning the data in
the format that should be searched upon. This is done by adding
functions this object with a parameter name which matches the sType
for that target column. This is the corollary of <i>afnSortData</i>
for searching data.</p>
<p>The functions defined take a single parameter:</p>
<ol>
<li><code>{*}</code> Data from the column cell to be prepared for searching</li>
</ol>
<p>Each function is expected to return:</p>
<ul>
<li><p><code>{string|null}</code> Formatted string that will be used for the searching.</p>
<p>@type object
@default {}</p>
<p>@example
 $.fn.dataTable.ext.type.search[&#39;title-numeric&#39;] = function ( d ) {
   return d.replace(/\n/g,&quot; &quot;).replace( /&lt;.*?&gt;/g, &quot;&quot; );
 }</p>
</li>
</ul></div></div><div class="code"><div class="wrapper">			search: {},
	
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Type based ordering.</p>
<p>The column type tells DataTables what ordering to apply to the table
when a column is sorted upon. The order for each type that is defined,
is defined by the functions available in this object.</p>
<p>Each ordering option can be described by three properties added to
this object:</p>
<ul>
<li><code>{type}-pre</code> - Pre-formatting function</li>
<li><code>{type}-asc</code> - Ascending order function</li>
<li><code>{type}-desc</code> - Descending order function</li>
</ul>
<p>All three can be used together, only <code>{type}-pre</code> or only
<code>{type}-asc</code> and <code>{type}-desc</code> together. It is generally recommended
that only <code>{type}-pre</code> is used, as this provides the optimal
implementation in terms of speed, although the others are provided
for compatibility with existing Javascript sort functions.</p>
<p><code>{type}-pre</code>: Functions defined take a single parameter:</p>
<ol>
<li><code>{*}</code> Data from the column cell to be prepared for ordering</li>
</ol>
<p>And return:</p>
<ul>
<li><code>{*}</code> Data to be sorted upon</li>
</ul>
<p><code>{type}-asc</code> and <code>{type}-desc</code>: Functions are typical Javascript sort
functions, taking two parameters:</p>
<ol>
<li><code>{*}</code> Data to compare to the second parameter</li>
<li><code>{*}</code> Data to compare to the first parameter</li>
</ol>
<p>And returning:</p>
<ul>
<li><p><code>{*}</code> Ordering match: &lt;0 if first parameter should be sorted lower
than the second parameter, ===0 if the two parameters are equal and</p>
<blockquote>
<p>0 if the first parameter should be sorted height than the second
parameter.</p>
</blockquote>
<p>@type object
@default {}</p>
<p>@example
 // Numeric ordering of formatted numbers with a pre-formatter
 $.extend( $.fn.dataTable.ext.type.order, {
   &quot;string-pre&quot;: function(x) {</p>
<pre><code> a = (a === &quot;-&quot; || a === &quot;&quot;) ? 0 : a.replace( /[^\d\-\.]/g, &quot;&quot; );
 return parseFloat( a );</code></pre>
<p>   }
 } );</p>
<p>@example
 // Case-sensitive string ordering, with no pre-formatting method
 $.extend( $.fn.dataTable.ext.order, {
   &quot;string-case-asc&quot;: function(x,y) {</p>
<pre><code> return ((x &lt; y) ? -1 : ((x &gt; y) ? 1 : 0));</code></pre>
<p>   },
   &quot;string-case-desc&quot;: function(x,y) {</p>
<pre><code> return ((x &lt; y) ? 1 : ((x &gt; y) ? -1 : 0));</code></pre>
<p>   }
 } );</p>
</li>
</ul></div></div><div class="code"><div class="wrapper">			order: {}
		},
	</div></div></div><div class="segment"><div class="comments doc-section doc-section-private"><div class="wrapper"><p><span class='doc-section-header'>Private of type <em>int</em></span></p>
<p>Unique DataTables instance counter</p></div></div><div class="code"><div class="wrapper">		_unique: <span class="hljs-number">0</span>,
	
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Depreciated
The following properties are retained for backwards compatiblity only.
The should not be used in new projects and will be removed in a future
version</p></div></div><div class="code"><div class="wrapper">	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Version check function.
 @type function
 @depreciated Since 1.10</p></div></div><div class="code"><div class="wrapper">		fnVersionCheck: DataTable.fnVersionCheck,
	
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Index for what &#39;this&#39; index API functions should use
 @type int
 @deprecated Since v1.10</p></div></div><div class="code"><div class="wrapper">		iApiIndex: <span class="hljs-number">0</span>,
	
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>jQuery UI class container
 @type object
 @deprecated Since v1.10</p></div></div><div class="code"><div class="wrapper">		oJUIClasses: {},
	
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Software version
 @type string
 @deprecated Since v1.10</p></div></div><div class="code"><div class="wrapper">		sVersion: DataTable.version
	};
	
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Backwards compatibility. Alias to pre 1.10 Hungarian notation counter parts</p></div></div><div class="code"><div class="wrapper">	$.extend( _ext, {
		afnFiltering: _ext.search,
		aTypes:       _ext.type.detect,
		ofnSearch:    _ext.type.search,
		oSort:        _ext.type.order,
		afnSortData:  _ext.order,
		aoFeatures:   _ext.feature,
		oApi:         _ext.internal,
		oStdClasses:  _ext.classes,
		oPagination:  _ext.pager
	} );
	
	
	$.extend( DataTable.ext.classes, {
		<span class="hljs-string">"sTable"</span>: <span class="hljs-string">"dataTable"</span>,
		<span class="hljs-string">"sNoFooter"</span>: <span class="hljs-string">"no-footer"</span>,
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Paging buttons </p></div></div><div class="code"><div class="wrapper">		<span class="hljs-string">"sPageButton"</span>: <span class="hljs-string">"paginate_button"</span>,
		<span class="hljs-string">"sPageButtonActive"</span>: <span class="hljs-string">"current"</span>,
		<span class="hljs-string">"sPageButtonDisabled"</span>: <span class="hljs-string">"disabled"</span>,
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Striping classes </p></div></div><div class="code"><div class="wrapper">		<span class="hljs-string">"sStripeOdd"</span>: <span class="hljs-string">"odd"</span>,
		<span class="hljs-string">"sStripeEven"</span>: <span class="hljs-string">"even"</span>,
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Empty row </p></div></div><div class="code"><div class="wrapper">		<span class="hljs-string">"sRowEmpty"</span>: <span class="hljs-string">"dataTables_empty"</span>,
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Features </p></div></div><div class="code"><div class="wrapper">		<span class="hljs-string">"sWrapper"</span>: <span class="hljs-string">"dataTables_wrapper"</span>,
		<span class="hljs-string">"sFilter"</span>: <span class="hljs-string">"dataTables_filter"</span>,
		<span class="hljs-string">"sInfo"</span>: <span class="hljs-string">"dataTables_info"</span>,
		<span class="hljs-string">"sPaging"</span>: <span class="hljs-string">"dataTables_paginate paging_"</span>, <span class="hljs-comment">/* Note that the type is postfixed */</span>
		<span class="hljs-string">"sLength"</span>: <span class="hljs-string">"dataTables_length"</span>,
		<span class="hljs-string">"sProcessing"</span>: <span class="hljs-string">"dataTables_processing"</span>,
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Sorting </p></div></div><div class="code"><div class="wrapper">		<span class="hljs-string">"sSortAsc"</span>: <span class="hljs-string">"sorting_asc"</span>,
		<span class="hljs-string">"sSortDesc"</span>: <span class="hljs-string">"sorting_desc"</span>,
		<span class="hljs-string">"sSortable"</span>: <span class="hljs-string">"sorting"</span>, <span class="hljs-comment">/* Sortable in both directions */</span>
		<span class="hljs-string">"sSortableAsc"</span>: <span class="hljs-string">"sorting_asc_disabled"</span>,
		<span class="hljs-string">"sSortableDesc"</span>: <span class="hljs-string">"sorting_desc_disabled"</span>,
		<span class="hljs-string">"sSortableNone"</span>: <span class="hljs-string">"sorting_disabled"</span>,
		<span class="hljs-string">"sSortColumn"</span>: <span class="hljs-string">"sorting_"</span>, <span class="hljs-comment">/* Note that an int is postfixed for the sorting order */</span>
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Filtering </p></div></div><div class="code"><div class="wrapper">		<span class="hljs-string">"sFilterInput"</span>: <span class="hljs-string">""</span>,
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Page length </p></div></div><div class="code"><div class="wrapper">		<span class="hljs-string">"sLengthSelect"</span>: <span class="hljs-string">""</span>,
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Scrolling </p></div></div><div class="code"><div class="wrapper">		<span class="hljs-string">"sScrollWrapper"</span>: <span class="hljs-string">"dataTables_scroll"</span>,
		<span class="hljs-string">"sScrollHead"</span>: <span class="hljs-string">"dataTables_scrollHead"</span>,
		<span class="hljs-string">"sScrollHeadInner"</span>: <span class="hljs-string">"dataTables_scrollHeadInner"</span>,
		<span class="hljs-string">"sScrollBody"</span>: <span class="hljs-string">"dataTables_scrollBody"</span>,
		<span class="hljs-string">"sScrollFoot"</span>: <span class="hljs-string">"dataTables_scrollFoot"</span>,
		<span class="hljs-string">"sScrollFootInner"</span>: <span class="hljs-string">"dataTables_scrollFootInner"</span>,
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Misc </p></div></div><div class="code"><div class="wrapper">		<span class="hljs-string">"sHeaderTH"</span>: <span class="hljs-string">""</span>,
		<span class="hljs-string">"sFooterTH"</span>: <span class="hljs-string">""</span>,
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Deprecated</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-string">"sSortJUIAsc"</span>: <span class="hljs-string">""</span>,
		<span class="hljs-string">"sSortJUIDesc"</span>: <span class="hljs-string">""</span>,
		<span class="hljs-string">"sSortJUI"</span>: <span class="hljs-string">""</span>,
		<span class="hljs-string">"sSortJUIAscAllowed"</span>: <span class="hljs-string">""</span>,
		<span class="hljs-string">"sSortJUIDescAllowed"</span>: <span class="hljs-string">""</span>,
		<span class="hljs-string">"sSortJUIWrapper"</span>: <span class="hljs-string">""</span>,
		<span class="hljs-string">"sSortIcon"</span>: <span class="hljs-string">""</span>,
		<span class="hljs-string">"sJUIHeader"</span>: <span class="hljs-string">""</span>,
		<span class="hljs-string">"sJUIFooter"</span>: <span class="hljs-string">""</span>
	} );
	
	
	(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Reused strings for better compression. Closure compiler appears to have a
weird edge case where it is trying to expand strings rather than use the
variable version. This results in about 200 bytes being added, for very
little preference benefit since it this run on script load only.</p></div></div><div class="code"><div class="wrapper">	<span class="hljs-keyword">var</span> _empty = <span class="hljs-string">''</span>;
	_empty = <span class="hljs-string">''</span>;
	
	<span class="hljs-keyword">var</span> _stateDefault = _empty + <span class="hljs-string">'ui-state-default'</span>;
	<span class="hljs-keyword">var</span> _sortIcon     = _empty + <span class="hljs-string">'css_right ui-icon ui-icon-'</span>;
	<span class="hljs-keyword">var</span> _headerFooter = _empty + <span class="hljs-string">'fg-toolbar ui-toolbar ui-widget-header ui-helper-clearfix'</span>;
	
	$.extend( DataTable.ext.oJUIClasses, DataTable.ext.classes, {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Full numbers paging buttons </p></div></div><div class="code"><div class="wrapper">		<span class="hljs-string">"sPageButton"</span>:         <span class="hljs-string">"fg-button ui-button "</span>+_stateDefault,
		<span class="hljs-string">"sPageButtonActive"</span>:   <span class="hljs-string">"ui-state-disabled"</span>,
		<span class="hljs-string">"sPageButtonDisabled"</span>: <span class="hljs-string">"ui-state-disabled"</span>,
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Features </p></div></div><div class="code"><div class="wrapper">		<span class="hljs-string">"sPaging"</span>: <span class="hljs-string">"dataTables_paginate fg-buttonset ui-buttonset fg-buttonset-multi "</span>+
			<span class="hljs-string">"ui-buttonset-multi paging_"</span>, <span class="hljs-comment">/* Note that the type is postfixed */</span>
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Sorting </p></div></div><div class="code"><div class="wrapper">		<span class="hljs-string">"sSortAsc"</span>:            _stateDefault+<span class="hljs-string">" sorting_asc"</span>,
		<span class="hljs-string">"sSortDesc"</span>:           _stateDefault+<span class="hljs-string">" sorting_desc"</span>,
		<span class="hljs-string">"sSortable"</span>:           _stateDefault+<span class="hljs-string">" sorting"</span>,
		<span class="hljs-string">"sSortableAsc"</span>:        _stateDefault+<span class="hljs-string">" sorting_asc_disabled"</span>,
		<span class="hljs-string">"sSortableDesc"</span>:       _stateDefault+<span class="hljs-string">" sorting_desc_disabled"</span>,
		<span class="hljs-string">"sSortableNone"</span>:       _stateDefault+<span class="hljs-string">" sorting_disabled"</span>,
		<span class="hljs-string">"sSortJUIAsc"</span>:         _sortIcon+<span class="hljs-string">"triangle-1-n"</span>,
		<span class="hljs-string">"sSortJUIDesc"</span>:        _sortIcon+<span class="hljs-string">"triangle-1-s"</span>,
		<span class="hljs-string">"sSortJUI"</span>:            _sortIcon+<span class="hljs-string">"carat-2-n-s"</span>,
		<span class="hljs-string">"sSortJUIAscAllowed"</span>:  _sortIcon+<span class="hljs-string">"carat-1-n"</span>,
		<span class="hljs-string">"sSortJUIDescAllowed"</span>: _sortIcon+<span class="hljs-string">"carat-1-s"</span>,
		<span class="hljs-string">"sSortJUIWrapper"</span>:     <span class="hljs-string">"DataTables_sort_wrapper"</span>,
		<span class="hljs-string">"sSortIcon"</span>:           <span class="hljs-string">"DataTables_sort_icon"</span>,
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Scrolling </p></div></div><div class="code"><div class="wrapper">		<span class="hljs-string">"sScrollHead"</span>: <span class="hljs-string">"dataTables_scrollHead "</span>+_stateDefault,
		<span class="hljs-string">"sScrollFoot"</span>: <span class="hljs-string">"dataTables_scrollFoot "</span>+_stateDefault,
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Misc </p></div></div><div class="code"><div class="wrapper">		<span class="hljs-string">"sHeaderTH"</span>:  _stateDefault,
		<span class="hljs-string">"sFooterTH"</span>:  _stateDefault,
		<span class="hljs-string">"sJUIHeader"</span>: _headerFooter+<span class="hljs-string">" ui-corner-tl ui-corner-tr"</span>,
		<span class="hljs-string">"sJUIFooter"</span>: _headerFooter+<span class="hljs-string">" ui-corner-bl ui-corner-br"</span>
	} );
	
	}());
	
	
	
	<span class="hljs-keyword">var</span> extPagination = DataTable.ext.pager;
	
	<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_numbers</span> <span class="hljs-params">( page, pages )</span> {</span>
		<span class="hljs-keyword">var</span>
			numbers = [],
			buttons = extPagination.numbers_length,
			half = <span class="hljs-built_in">Math</span>.floor( buttons / <span class="hljs-number">2</span> ),
			i = <span class="hljs-number">1</span>;
	
		<span class="hljs-keyword">if</span> ( pages &lt;= buttons ) {
			numbers = _range( <span class="hljs-number">0</span>, pages );
		}
		<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( page &lt;= half ) {
			numbers = _range( <span class="hljs-number">0</span>, buttons-<span class="hljs-number">2</span> );
			numbers.push( <span class="hljs-string">'ellipsis'</span> );
			numbers.push( pages-<span class="hljs-number">1</span> );
		}
		<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( page &gt;= pages - <span class="hljs-number">1</span> - half ) {
			numbers = _range( pages-(buttons-<span class="hljs-number">2</span>), pages );
			numbers.splice( <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-string">'ellipsis'</span> ); <span class="hljs-comment">// no unshift in ie6</span>
			numbers.splice( <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span> );
		}
		<span class="hljs-keyword">else</span> {
			numbers = _range( page-<span class="hljs-number">1</span>, page+<span class="hljs-number">2</span> );
			numbers.push( <span class="hljs-string">'ellipsis'</span> );
			numbers.push( pages-<span class="hljs-number">1</span> );
			numbers.splice( <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-string">'ellipsis'</span> );
			numbers.splice( <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span> );
		}
	
		numbers.DT_el = <span class="hljs-string">'span'</span>;
		<span class="hljs-keyword">return</span> numbers;
	}
	
	
	$.extend( extPagination, {
		simple: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">( page, pages )</span> {</span>
			<span class="hljs-keyword">return</span> [ <span class="hljs-string">'previous'</span>, <span class="hljs-string">'next'</span> ];
		},
	
		full: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">( page, pages )</span> {</span>
			<span class="hljs-keyword">return</span> [  <span class="hljs-string">'first'</span>, <span class="hljs-string">'previous'</span>, <span class="hljs-string">'next'</span>, <span class="hljs-string">'last'</span> ];
		},
	
		simple_numbers: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">( page, pages )</span> {</span>
			<span class="hljs-keyword">return</span> [ <span class="hljs-string">'previous'</span>, _numbers(page, pages), <span class="hljs-string">'next'</span> ];
		},
	
		full_numbers: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">( page, pages )</span> {</span>
			<span class="hljs-keyword">return</span> [ <span class="hljs-string">'first'</span>, <span class="hljs-string">'previous'</span>, _numbers(page, pages), <span class="hljs-string">'next'</span>, <span class="hljs-string">'last'</span> ];
		},
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>For testing and plug-ins to use</p></div></div><div class="code"><div class="wrapper">		_numbers: _numbers,
		numbers_length: <span class="hljs-number">7</span>
	} );
	
	
	$.extend( <span class="hljs-literal">true</span>, DataTable.ext.renderer, {
		pageButton: {
			_: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">( settings, host, idx, buttons, page, pages )</span> {</span>
				<span class="hljs-keyword">var</span> classes = settings.oClasses;
				<span class="hljs-keyword">var</span> lang = settings.oLanguage.oPaginate;
				<span class="hljs-keyword">var</span> btnDisplay, btnClass, counter=<span class="hljs-number">0</span>;
	
				<span class="hljs-keyword">var</span> attach = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( container, buttons )</span> {</span>
					<span class="hljs-keyword">var</span> i, ien, node, button;
					<span class="hljs-keyword">var</span> clickHandler = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">( e )</span> {</span>
						_fnPageChange( settings, e.data.action, <span class="hljs-literal">true</span> );
					};
	
					<span class="hljs-keyword">for</span> ( i=<span class="hljs-number">0</span>, ien=buttons.length ; i&lt;ien ; i++ ) {
						button = buttons[i];
	
						<span class="hljs-keyword">if</span> ( $.isArray( button ) ) {
							<span class="hljs-keyword">var</span> inner = $( <span class="hljs-string">'&lt;'</span>+(button.DT_el || <span class="hljs-string">'div'</span>)+<span class="hljs-string">'/&gt;'</span> )
								.appendTo( container );
							attach( inner, button );
						}
						<span class="hljs-keyword">else</span> {
							btnDisplay = <span class="hljs-string">''</span>;
							btnClass = <span class="hljs-string">''</span>;
	
							<span class="hljs-keyword">switch</span> ( button ) {
								<span class="hljs-keyword">case</span> <span class="hljs-string">'ellipsis'</span>:
									container.append(<span class="hljs-string">'&lt;span&gt;&amp;hellip;&lt;/span&gt;'</span>);
									<span class="hljs-keyword">break</span>;
	
								<span class="hljs-keyword">case</span> <span class="hljs-string">'first'</span>:
									btnDisplay = lang.sFirst;
									btnClass = button + (page &gt; <span class="hljs-number">0</span> ?
										<span class="hljs-string">''</span> : <span class="hljs-string">' '</span>+classes.sPageButtonDisabled);
									<span class="hljs-keyword">break</span>;
	
								<span class="hljs-keyword">case</span> <span class="hljs-string">'previous'</span>:
									btnDisplay = lang.sPrevious;
									btnClass = button + (page &gt; <span class="hljs-number">0</span> ?
										<span class="hljs-string">''</span> : <span class="hljs-string">' '</span>+classes.sPageButtonDisabled);
									<span class="hljs-keyword">break</span>;
	
								<span class="hljs-keyword">case</span> <span class="hljs-string">'next'</span>:
									btnDisplay = lang.sNext;
									btnClass = button + (page &lt; pages-<span class="hljs-number">1</span> ?
										<span class="hljs-string">''</span> : <span class="hljs-string">' '</span>+classes.sPageButtonDisabled);
									<span class="hljs-keyword">break</span>;
	
								<span class="hljs-keyword">case</span> <span class="hljs-string">'last'</span>:
									btnDisplay = lang.sLast;
									btnClass = button + (page &lt; pages-<span class="hljs-number">1</span> ?
										<span class="hljs-string">''</span> : <span class="hljs-string">' '</span>+classes.sPageButtonDisabled);
									<span class="hljs-keyword">break</span>;
	
								<span class="hljs-keyword">default</span>:
									btnDisplay = button + <span class="hljs-number">1</span>;
									btnClass = page === button ?
										classes.sPageButtonActive : <span class="hljs-string">''</span>;
									<span class="hljs-keyword">break</span>;
							}
	
							<span class="hljs-keyword">if</span> ( btnDisplay ) {
								node = $(<span class="hljs-string">'&lt;a&gt;'</span>, {
										<span class="hljs-string">'class'</span>: classes.sPageButton+<span class="hljs-string">' '</span>+btnClass,
										<span class="hljs-string">'aria-controls'</span>: settings.sTableId,
										<span class="hljs-string">'data-dt-idx'</span>: counter,
										<span class="hljs-string">'tabindex'</span>: settings.iTabIndex,
										<span class="hljs-string">'id'</span>: idx === <span class="hljs-number">0</span> &amp;&amp; <span class="hljs-keyword">typeof</span> button === <span class="hljs-string">'string'</span> ?
											settings.sTableId +<span class="hljs-string">'_'</span>+ button :
											<span class="hljs-literal">null</span>
									} )
									.html( btnDisplay )
									.appendTo( container );
	
								_fnBindAction(
									node, {action: button}, clickHandler
								);
	
								counter++;
							}
						}
					}
				};
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>IE9 throws an &#39;unknown error&#39; if document.activeElement is used
inside an iframe or frame. Try / catch the error. Not good for
accessibility, but neither are frames.</p></div></div><div class="code"><div class="wrapper">				<span class="hljs-keyword">try</span> {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Because this approach is destroying and recreating the paging
elements, focus is lost on the select button which is bad for
accessibility. So we want to restore focus once the draw has
completed</p></div></div><div class="code"><div class="wrapper">					<span class="hljs-keyword">var</span> activeEl = $(document.activeElement).data(<span class="hljs-string">'dt-idx'</span>);
	
					attach( $(host).empty(), buttons );
	
					<span class="hljs-keyword">if</span> ( activeEl !== <span class="hljs-literal">null</span> ) {
						$(host).find( <span class="hljs-string">'[data-dt-idx='</span>+activeEl+<span class="hljs-string">']'</span> ).focus();
					}
				}
				<span class="hljs-keyword">catch</span> (e) {}
			}
		}
	} );
	
	
	
	<span class="hljs-keyword">var</span> __numericReplace = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">( d, decimalPlace, re1, re2 )</span> {</span>
		<span class="hljs-keyword">if</span> ( !d || d === <span class="hljs-string">'-'</span> ) {
			<span class="hljs-keyword">return</span> -<span class="hljs-literal">Infinity</span>;
		}
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>If a decimal place other than <code>.</code> is used, it needs to be given to the
function so we can detect it and replace with a <code>.</code> which is the only
decimal place Javascript recognises - it is not locale aware.</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-keyword">if</span> ( decimalPlace ) {
			d = _numToDecimal( d, decimalPlace );
		}
	
		<span class="hljs-keyword">if</span> ( d.replace ) {
			<span class="hljs-keyword">if</span> ( re1 ) {
				d = d.replace( re1, <span class="hljs-string">''</span> );
			}
	
			<span class="hljs-keyword">if</span> ( re2 ) {
				d = d.replace( re2, <span class="hljs-string">''</span> );
			}
		}
	
		<span class="hljs-keyword">return</span> d * <span class="hljs-number">1</span>;
	};
	
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Add the numeric &#39;deformatting&#39; functions for sorting. This is done in a
function to provide an easy ability for the language options to add
additional methods if a non-period decimal place is used.</p></div></div><div class="code"><div class="wrapper">	<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_addNumericSort</span> <span class="hljs-params">( decimalPlace )</span> {</span>
		$.each(
			{</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Plain numbers</p></div></div><div class="code"><div class="wrapper">				<span class="hljs-string">"num"</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">( d )</span> {</span>
					<span class="hljs-keyword">return</span> __numericReplace( d, decimalPlace );
				},
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Formatted numbers</p></div></div><div class="code"><div class="wrapper">				<span class="hljs-string">"num-fmt"</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">( d )</span> {</span>
					<span class="hljs-keyword">return</span> __numericReplace( d, decimalPlace, _re_formatted_numeric );
				},
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>HTML numeric</p></div></div><div class="code"><div class="wrapper">				<span class="hljs-string">"html-num"</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">( d )</span> {</span>
					<span class="hljs-keyword">return</span> __numericReplace( d, decimalPlace, _re_html );
				},
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>HTML numeric, formatted</p></div></div><div class="code"><div class="wrapper">				<span class="hljs-string">"html-num-fmt"</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">( d )</span> {</span>
					<span class="hljs-keyword">return</span> __numericReplace( d, decimalPlace, _re_html, _re_formatted_numeric );
				}
			},
			<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">( key, fn )</span> {</span>
				_ext.type.order[ key+decimalPlace+<span class="hljs-string">'-pre'</span> ] = fn;
			}
		);
	}
	
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Default sort methods</p></div></div><div class="code"><div class="wrapper">	$.extend( _ext.type.order, {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Dates</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-string">"date-pre"</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">( d )</span> {</span>
			<span class="hljs-keyword">return</span> <span class="hljs-built_in">Date</span>.parse( d ) || <span class="hljs-number">0</span>;
		},
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>html</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-string">"html-pre"</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">( a )</span> {</span>
			<span class="hljs-keyword">return</span> _empty(a) ?
				<span class="hljs-string">''</span> :
				a.replace ?
					a.replace( <span class="hljs-regexp">/&lt;.*?&gt;/g</span>, <span class="hljs-string">""</span> ).toLowerCase() :
					a+<span class="hljs-string">''</span>;
		},
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>string</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-string">"string-pre"</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">( a )</span> {</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>This is a little complex, but faster than always calling toString,
<a href="http://jsperf.com/tostring-v-check">http://jsperf.com/tostring-v-check</a></p></div></div><div class="code"><div class="wrapper">			<span class="hljs-keyword">return</span> _empty(a) ?
				<span class="hljs-string">''</span> :
				<span class="hljs-keyword">typeof</span> a === <span class="hljs-string">'string'</span> ?
					a.toLowerCase() :
					! a.toString ?
						<span class="hljs-string">''</span> :
						a.toString();
		},
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>string-asc and -desc are retained only for compatibility with the old
sort methods</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-string">"string-asc"</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">( x, y )</span> {</span>
			<span class="hljs-keyword">return</span> ((x &lt; y) ? -<span class="hljs-number">1</span> : ((x &gt; y) ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>));
		},
	
		<span class="hljs-string">"string-desc"</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">( x, y )</span> {</span>
			<span class="hljs-keyword">return</span> ((x &lt; y) ? <span class="hljs-number">1</span> : ((x &gt; y) ? -<span class="hljs-number">1</span> : <span class="hljs-number">0</span>));
		}
	} );
	
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Numeric sorting types - order doesn&#39;t matter here</p></div></div><div class="code"><div class="wrapper">	_addNumericSort( <span class="hljs-string">''</span> );
	
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Built in type detection. See model.ext.aTypes for information about
what is required from this methods.</p></div></div><div class="code"><div class="wrapper">	$.extend( DataTable.ext.type.detect, [</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Plain numbers - first since V8 detects some plain numbers as dates
e.g. Date.parse(&#39;55&#39;) (but not all, e.g. Date.parse(&#39;22&#39;)...).</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">( d, settings )</span>
		{</span>
			<span class="hljs-keyword">var</span> decimal = settings.oLanguage.sDecimal;
			<span class="hljs-keyword">return</span> _isNumber( d, decimal ) ? <span class="hljs-string">'num'</span>+decimal : <span class="hljs-literal">null</span>;
		},
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Dates (only those recognised by the browser&#39;s Date.parse)</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">( d, settings )</span>
		{</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>V8 will remove any unknown characters at the start and end of the
expression, leading to false matches such as <code>$245.12</code> or <code>10%</code> being
a valid date. See forum thread 18941 for detail.</p></div></div><div class="code"><div class="wrapper">			<span class="hljs-keyword">if</span> ( d &amp;&amp; ( ! _re_date_start.test(d) || ! _re_date_end.test(d) ) ) {
				<span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
			}
			<span class="hljs-keyword">var</span> parsed = <span class="hljs-built_in">Date</span>.parse(d);
			<span class="hljs-keyword">return</span> (parsed !== <span class="hljs-literal">null</span> &amp;&amp; !<span class="hljs-built_in">isNaN</span>(parsed)) || _empty(d) ? <span class="hljs-string">'date'</span> : <span class="hljs-literal">null</span>;
		},
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Formatted numbers</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">( d, settings )</span>
		{</span>
			<span class="hljs-keyword">var</span> decimal = settings.oLanguage.sDecimal;
			<span class="hljs-keyword">return</span> _isNumber( d, decimal, <span class="hljs-literal">true</span> ) ? <span class="hljs-string">'num-fmt'</span>+decimal : <span class="hljs-literal">null</span>;
		},
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>HTML numeric</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">( d, settings )</span>
		{</span>
			<span class="hljs-keyword">var</span> decimal = settings.oLanguage.sDecimal;
			<span class="hljs-keyword">return</span> _htmlNumeric( d, decimal ) ? <span class="hljs-string">'html-num'</span>+decimal : <span class="hljs-literal">null</span>;
		},
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>HTML numeric, formatted</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">( d, settings )</span>
		{</span>
			<span class="hljs-keyword">var</span> decimal = settings.oLanguage.sDecimal;
			<span class="hljs-keyword">return</span> _htmlNumeric( d, decimal, <span class="hljs-literal">true</span> ) ? <span class="hljs-string">'html-num-fmt'</span>+decimal : <span class="hljs-literal">null</span>;
		},
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>HTML (this is strict checking - there must be html)</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">( d, settings )</span>
		{</span>
			<span class="hljs-keyword">return</span> _empty( d ) || (<span class="hljs-keyword">typeof</span> d === <span class="hljs-string">'string'</span> &amp;&amp; d.indexOf(<span class="hljs-string">'&lt;'</span>) !== -<span class="hljs-number">1</span>) ?
				<span class="hljs-string">'html'</span> : <span class="hljs-literal">null</span>;
		}
	] );
	
	
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Filter formatting functions. See model.ext.ofnSearch for information about
what is required from these methods.</p></div></div><div class="code"><div class="wrapper">	
	
	$.extend( DataTable.ext.type.search, {
		html: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">( data )</span> {</span>
			<span class="hljs-keyword">return</span> _empty(data) ?
				data :
				<span class="hljs-keyword">typeof</span> data === <span class="hljs-string">'string'</span> ?
					data
						.replace( _re_new_lines, <span class="hljs-string">" "</span> )
						.replace( _re_html, <span class="hljs-string">""</span> ) :
					<span class="hljs-string">''</span>;
		},
	
		string: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">( data )</span> {</span>
			<span class="hljs-keyword">return</span> _empty(data) ?
				data :
				<span class="hljs-keyword">typeof</span> data === <span class="hljs-string">'string'</span> ?
					data.replace( _re_new_lines, <span class="hljs-string">" "</span> ) :
					data;
		}
	} );
	
	
	
	$.extend( <span class="hljs-literal">true</span>, DataTable.ext.renderer, {
		header: {
			_: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">( settings, cell, column, classes )</span> {</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>No additional mark-up required
Attach a sort listener to update on sort - note that using the
<code>DT</code> namespace will allow the event to be removed automatically
on destroy, while the <code>dt</code> namespaced event is the one we are
listening for</p></div></div><div class="code"><div class="wrapper">				$(settings.nTable).on( <span class="hljs-string">'order.dt.DT'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">( e, ctx, sorting, columns )</span> {</span>
					<span class="hljs-keyword">if</span> ( settings !== ctx ) { <span class="hljs-comment">// need to check this this is the host</span>
						<span class="hljs-keyword">return</span>;               <span class="hljs-comment">// table, not a nested one</span>
					}
	
					<span class="hljs-keyword">var</span> colIdx = column.idx;
	
					cell
						.removeClass(
							column.sSortingClass +<span class="hljs-string">' '</span>+
							classes.sSortAsc +<span class="hljs-string">' '</span>+
							classes.sSortDesc
						)
						.addClass( columns[ colIdx ] == <span class="hljs-string">'asc'</span> ?
							classes.sSortAsc : columns[ colIdx ] == <span class="hljs-string">'desc'</span> ?
								classes.sSortDesc :
								column.sSortingClass
						);
				} );
			},
	
			jqueryui: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">( settings, cell, column, classes )</span> {</span>
				<span class="hljs-keyword">var</span> colIdx = column.idx;
	
				$(<span class="hljs-string">'&lt;div/&gt;'</span>)
					.addClass( classes.sSortJUIWrapper )
					.append( cell.contents() )
					.append( $(<span class="hljs-string">'&lt;span/&gt;'</span>)
						.addClass( classes.sSortIcon+<span class="hljs-string">' '</span>+column.sSortingClassJUI )
					)
					.appendTo( cell );
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Attach a sort listener to update on sort</p></div></div><div class="code"><div class="wrapper">				$(settings.nTable).on( <span class="hljs-string">'order.dt.DT'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">( e, ctx, sorting, columns )</span> {</span>
					<span class="hljs-keyword">if</span> ( settings !== ctx ) {
						<span class="hljs-keyword">return</span>;
					}
	
					cell
						.removeClass( classes.sSortAsc +<span class="hljs-string">" "</span>+classes.sSortDesc )
						.addClass( columns[ colIdx ] == <span class="hljs-string">'asc'</span> ?
							classes.sSortAsc : columns[ colIdx ] == <span class="hljs-string">'desc'</span> ?
								classes.sSortDesc :
								column.sSortingClass
						);
	
					cell
						.find( <span class="hljs-string">'span.'</span>+classes.sSortIcon )
						.removeClass(
							classes.sSortJUIAsc +<span class="hljs-string">" "</span>+
							classes.sSortJUIDesc +<span class="hljs-string">" "</span>+
							classes.sSortJUI +<span class="hljs-string">" "</span>+
							classes.sSortJUIAscAllowed +<span class="hljs-string">" "</span>+
							classes.sSortJUIDescAllowed
						)
						.addClass( columns[ colIdx ] == <span class="hljs-string">'asc'</span> ?
							classes.sSortJUIAsc : columns[ colIdx ] == <span class="hljs-string">'desc'</span> ?
								classes.sSortJUIDesc :
								column.sSortingClassJUI
						);
				} );
			}
		}
	} );
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Public helper functions. These aren&#39;t used internally by DataTables, or
called by any of the options passed into DataTables, but they can be used
externally by developers working with DataTables. They are helper functions
to make working with DataTables a little bit easier.</p></div></div><div class="code"><div class="wrapper">	</div></div></div><div class="segment"><div class="comments doc-section"><div class="wrapper"><p><span class='doc-section-header'> namespace</span></p>
<p>Helpers for <code>columns.render</code>.</p>
<p>The options defined here can be used with the <code>columns.render</code> initialisation
option to provide a display renderer. The following functions are defined:</p>
<ul>
<li><code>number</code> - Will format numeric data (defined by <code>columns.data</code>) for
display, retaining the original unformatted data for sorting and filtering.
It takes 4 parameters:<ul>
<li><code>string</code> - Thousands grouping separator</li>
<li><code>string</code> - Decimal point indicator</li>
<li><code>integer</code> - Number of decimal points to show</li>
<li><code>string</code> (optional) - Prefix.</li>
</ul>
</li>
</ul>
<p>Example:</p>
<pre><code>// Column definition using the number renderer
{
  data: &quot;salary&quot;,
  render: $.fn.dataTable.render.number( &#39;\&#39;&#39;, &#39;.&#39;, 0, &#39; )
}</code></pre></div></div><div class="code"><div class="wrapper">	DataTable.render = {
		number: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">( thousands, decimal, precision, prefix )</span> {</span>
			<span class="hljs-keyword">return</span> {
				display: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">( d )</span> {</span>
					<span class="hljs-keyword">var</span> negative = d &lt; <span class="hljs-number">0</span> ? <span class="hljs-string">'-'</span> : <span class="hljs-string">''</span>;
					d = <span class="hljs-built_in">Math</span>.abs( <span class="hljs-built_in">parseFloat</span>( d ) );
	
					<span class="hljs-keyword">var</span> intPart = <span class="hljs-built_in">parseInt</span>( d, <span class="hljs-number">10</span> );
					<span class="hljs-keyword">var</span> floatPart = precision ?
						decimal+(d - intPart).toFixed( precision ).substring( <span class="hljs-number">2</span> ):
						<span class="hljs-string">''</span>;
	
					<span class="hljs-keyword">return</span> negative + (prefix||<span class="hljs-string">''</span>) +
						intPart.toString().replace(
							<span class="hljs-regexp">/\B(?=(\d{3})+(?!\d))/g</span>, thousands
						) +
						floatPart;
				}
			};
		}
	};
	
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>This is really a good bit rubbish this method of exposing the internal methods
publicly... - To be fixed in 2.0 using methods on the prototype</p></div></div><div class="code"><div class="wrapper">	
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Create a wrapper function for exporting an internal functions to an external API.
 @param {string} fn API function name
 @returns {function} wrapped function
 @memberof DataTable#internal</p></div></div><div class="code"><div class="wrapper">	<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_fnExternApiFunc</span> <span class="hljs-params">(fn)</span>
	{</span>
		<span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>
			<span class="hljs-keyword">var</span> args = [_fnSettingsFromNode( <span class="hljs-keyword">this</span>[DataTable.ext.iApiIndex] )].concat(
				<span class="hljs-built_in">Array</span>.prototype.slice.call(<span class="hljs-built_in">arguments</span>)
			);
			<span class="hljs-keyword">return</span> DataTable.ext.internal[fn].apply( <span class="hljs-keyword">this</span>, args );
		};
	}
	
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Reference to internal functions for use by plug-in developers. Note that
these methods are references to internal functions and are considered to be
private. If you use these methods, be aware that they are liable to change
between versions.
 @namespace</p></div></div><div class="code"><div class="wrapper">	$.extend( DataTable.ext.internal, {
		_fnExternApiFunc: _fnExternApiFunc,
		_fnBuildAjax: _fnBuildAjax,
		_fnAjaxUpdate: _fnAjaxUpdate,
		_fnAjaxParameters: _fnAjaxParameters,
		_fnAjaxUpdateDraw: _fnAjaxUpdateDraw,
		_fnAjaxDataSrc: _fnAjaxDataSrc,
		_fnAddColumn: _fnAddColumn,
		_fnColumnOptions: _fnColumnOptions,
		_fnAdjustColumnSizing: _fnAdjustColumnSizing,
		_fnVisibleToColumnIndex: _fnVisibleToColumnIndex,
		_fnColumnIndexToVisible: _fnColumnIndexToVisible,
		_fnVisbleColumns: _fnVisbleColumns,
		_fnGetColumns: _fnGetColumns,
		_fnColumnTypes: _fnColumnTypes,
		_fnApplyColumnDefs: _fnApplyColumnDefs,
		_fnHungarianMap: _fnHungarianMap,
		_fnCamelToHungarian: _fnCamelToHungarian,
		_fnLanguageCompat: _fnLanguageCompat,
		_fnBrowserDetect: _fnBrowserDetect,
		_fnAddData: _fnAddData,
		_fnAddTr: _fnAddTr,
		_fnNodeToDataIndex: _fnNodeToDataIndex,
		_fnNodeToColumnIndex: _fnNodeToColumnIndex,
		_fnGetCellData: _fnGetCellData,
		_fnSetCellData: _fnSetCellData,
		_fnSplitObjNotation: _fnSplitObjNotation,
		_fnGetObjectDataFn: _fnGetObjectDataFn,
		_fnSetObjectDataFn: _fnSetObjectDataFn,
		_fnGetDataMaster: _fnGetDataMaster,
		_fnClearTable: _fnClearTable,
		_fnDeleteIndex: _fnDeleteIndex,
		_fnInvalidateRow: _fnInvalidateRow,
		_fnGetRowElements: _fnGetRowElements,
		_fnCreateTr: _fnCreateTr,
		_fnBuildHead: _fnBuildHead,
		_fnDrawHead: _fnDrawHead,
		_fnDraw: _fnDraw,
		_fnReDraw: _fnReDraw,
		_fnAddOptionsHtml: _fnAddOptionsHtml,
		_fnDetectHeader: _fnDetectHeader,
		_fnGetUniqueThs: _fnGetUniqueThs,
		_fnFeatureHtmlFilter: _fnFeatureHtmlFilter,
		_fnFilterComplete: _fnFilterComplete,
		_fnFilterCustom: _fnFilterCustom,
		_fnFilterColumn: _fnFilterColumn,
		_fnFilter: _fnFilter,
		_fnFilterCreateSearch: _fnFilterCreateSearch,
		_fnEscapeRegex: _fnEscapeRegex,
		_fnFilterData: _fnFilterData,
		_fnFeatureHtmlInfo: _fnFeatureHtmlInfo,
		_fnUpdateInfo: _fnUpdateInfo,
		_fnInfoMacros: _fnInfoMacros,
		_fnInitialise: _fnInitialise,
		_fnInitComplete: _fnInitComplete,
		_fnLengthChange: _fnLengthChange,
		_fnFeatureHtmlLength: _fnFeatureHtmlLength,
		_fnFeatureHtmlPaginate: _fnFeatureHtmlPaginate,
		_fnPageChange: _fnPageChange,
		_fnFeatureHtmlProcessing: _fnFeatureHtmlProcessing,
		_fnProcessingDisplay: _fnProcessingDisplay,
		_fnFeatureHtmlTable: _fnFeatureHtmlTable,
		_fnScrollDraw: _fnScrollDraw,
		_fnApplyToChildren: _fnApplyToChildren,
		_fnCalculateColumnWidths: _fnCalculateColumnWidths,
		_fnThrottle: _fnThrottle,
		_fnConvertToWidth: _fnConvertToWidth,
		_fnScrollingWidthAdjust: _fnScrollingWidthAdjust,
		_fnGetWidestNode: _fnGetWidestNode,
		_fnGetMaxLenString: _fnGetMaxLenString,
		_fnStringToCss: _fnStringToCss,
		_fnScrollBarWidth: _fnScrollBarWidth,
		_fnSortFlatten: _fnSortFlatten,
		_fnSort: _fnSort,
		_fnSortAria: _fnSortAria,
		_fnSortListener: _fnSortListener,
		_fnSortAttachListener: _fnSortAttachListener,
		_fnSortingClasses: _fnSortingClasses,
		_fnSortData: _fnSortData,
		_fnSaveState: _fnSaveState,
		_fnLoadState: _fnLoadState,
		_fnSettingsFromNode: _fnSettingsFromNode,
		_fnLog: _fnLog,
		_fnMap: _fnMap,
		_fnBindAction: _fnBindAction,
		_fnCallbackReg: _fnCallbackReg,
		_fnCallbackFire: _fnCallbackFire,
		_fnLengthOverflow: _fnLengthOverflow,
		_fnRenderer: _fnRenderer,
		_fnDataSource: _fnDataSource,
		_fnRowAttributes: _fnRowAttributes,
		_fnCalculateEnd: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>} <span class="hljs-comment">// Used by a lot of plug-ins, but redundant</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>in 1.10, so this dead-end function is
added to prevent errors</p></div></div><div class="code"><div class="wrapper">	} );
	</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>jQuery access</p></div></div><div class="code"><div class="wrapper">	$.fn.dataTable = DataTable;</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Legacy aliases</p></div></div><div class="code"><div class="wrapper">	$.fn.dataTableSettings = DataTable.settings;
	$.fn.dataTableExt = DataTable.ext;</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>With a capital <code>D</code> we return a DataTables API instance rather than a
jQuery object</p></div></div><div class="code"><div class="wrapper">	$.fn.DataTable = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">( opts )</span> {</span>
		<span class="hljs-keyword">return</span> $(<span class="hljs-keyword">this</span>).dataTable( opts ).api();
	};</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>All properties that are available to $.fn.dataTable should also be
available on $.fn.DataTable</p></div></div><div class="code"><div class="wrapper">	$.each( DataTable, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">( prop, val )</span> {</span>
		$.fn.DataTable[ prop ] = val;
	} );</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Information about events fired by DataTables - for documentation.
Draw event, fired whenever the table is redrawn on the page, at the same
point as fnDrawCallback. This may be useful for binding events or
performing calculations when the table is altered at all.
 @name DataTable#draw.dt
 @event
 @param {event} e jQuery event object
 @param {object} o DataTables settings object {@link DataTable.models.oSettings}</p></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Search event, fired when the searching applied to the table (using the
built-in global search, or column filters) is altered.
 @name DataTable#search.dt
 @event
 @param {event} e jQuery event object
 @param {object} o DataTables settings object {@link DataTable.models.oSettings}</p></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Page change event, fired when the paging of the table is altered.
 @name DataTable#page.dt
 @event
 @param {event} e jQuery event object
 @param {object} o DataTables settings object {@link DataTable.models.oSettings}</p></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Order event, fired when the ordering applied to the table is altered.
 @name DataTable#order.dt
 @event
 @param {event} e jQuery event object
 @param {object} o DataTables settings object {@link DataTable.models.oSettings}</p></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>DataTables initialisation complete event, fired when the table is fully
drawn, including Ajax data loaded, if Ajax data is required.
 @name DataTable#init.dt
 @event
 @param {event} e jQuery event object
 @param {object} oSettings DataTables settings object
 @param {object} json The JSON object request from the server - only
   present if client-side Ajax sourced data is used</li></ol></p></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>State save event, fired when the table has changed state a new state save
is required. This event allows modification of the state saving object
prior to actually doing the save, including addition or other state
properties (for plug-ins) or modification of a DataTables core property.
 @name DataTable#stateSaveParams.dt
 @event
 @param {event} e jQuery event object
 @param {object} oSettings DataTables settings object
 @param {object} json The state information to be saved</p></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>State load event, fired when the table is loading state from the stored
data, but prior to the settings object being modified by the saved state</p>
<ul>
<li>allowing modification of the saved state is required or loading of
state for a plug-in.
@name DataTable#stateLoadParams.dt
@event
@param {event} e jQuery event object
@param {object} oSettings DataTables settings object
@param {object} json The saved state information</li>
</ul></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>State loaded event, fired when state has been loaded from stored data and
the settings object has been modified by the loaded data.
 @name DataTable#stateLoaded.dt
 @event
 @param {event} e jQuery event object
 @param {object} oSettings DataTables settings object
 @param {object} json The saved state information</p></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Processing event, fired when DataTables is doing some kind of processing
(be it, order, searcg or anything else). It can be used to indicate to
the end user that there is something happening, or that something has
finished.
 @name DataTable#processing.dt
 @event
 @param {event} e jQuery event object
 @param {object} oSettings DataTables settings object
 @param {boolean} bShow Flag for if DataTables is doing processing or not</p></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Ajax (XHR) event, fired whenever an Ajax request is completed from a
request to made to the server for new data. This event is called before
DataTables processed the returned data, so it can also be used to pre-
process the data returned from the server, if needed.</p>
<p>Note that this trigger is called in <code>fnServerData</code>, if you override
<code>fnServerData</code> and which to use this event, you need to trigger it in you
success function.
 @name DataTable#xhr.dt
 @event
 @param {event} e jQuery event object
 @param {object} o DataTables settings object {@link DataTable.models.oSettings}
 @param {object} json JSON returned from the server</p>
<p> @example
    // Use a custom property returned from the server in another DOM element
    $(&#39;#table&#39;).dataTable().on(&#39;xhr.dt&#39;, function (e, settings, json) {
      $(&#39;#status&#39;).html( json.status );
    } );</p>
<p> @example
    // Pre-process the data returned from the server
    $(&#39;#table&#39;).dataTable().on(&#39;xhr.dt&#39;, function (e, settings, json) {
      for ( var i=0, ien=json.aaData.length ; i&lt;ien ; i++ ) {
        json.aaData[i].sum = json.aaData[i].one + json.aaData[i].two;
      }
      // Note no return - manipulate the data directly in the JSON object.
    } );</p></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Destroy event, fired when the DataTable is destroyed by calling fnDestroy
or passing the bDestroy:true parameter in the initialisation object. This
can be used to remove bound events, added DOM nodes, etc.
 @name DataTable#destroy.dt
 @event
 @param {event} e jQuery event object
 @param {object} o DataTables settings object {@link DataTable.models.oSettings}</p></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Page length change event, fired when number of records to show on each
page (the length) is changed.
 @name DataTable#length.dt
 @event
 @param {event} e jQuery event object
 @param {object} o DataTables settings object {@link DataTable.models.oSettings}
 @param {integer} len New length</p></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Column sizing has changed.
 @name DataTable#column-sizing.dt
 @event
 @param {event} e jQuery event object
 @param {object} o DataTables settings object {@link DataTable.models.oSettings}</p></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Column visibility has changed.
 @name DataTable#column-visibility.dt
 @event
 @param {event} e jQuery event object
 @param {object} o DataTables settings object {@link DataTable.models.oSettings}
 @param {int} column Column index
 @param {bool} vis <code>false</code> if column now hidden, or <code>true</code> if visible</p></div></div><div class="code"><div class="wrapper">	<span class="hljs-keyword">return</span> $.fn.dataTable;
}));

}(window, document));</div></div></div></div></body></html>