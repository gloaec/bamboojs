<!DOCTYPE html><html lang="en"><head><title>assets/scripts/vendor/backbone_stickit</title></head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0"><meta name="groc-relative-root" content="../../../"><meta name="groc-document-path" content="assets/scripts/vendor/backbone_stickit"><meta name="groc-project-path" content="assets/scripts/vendor/backbone_stickit.js"><link rel="stylesheet" type="text/css" media="all" href="../../../assets/style.css"><script type="text/javascript" src="../../../assets/behavior.js"></script><body><div id="meta"><div class="file-path">assets/scripts/vendor/backbone_stickit.js</div></div><div id="document"><div class="segment"><div class="comments "><div class="wrapper"><p>backbone.stickit - v0.6.3
The MIT License
Copyright (c) 2012 The New York Times, CMS Group, Matthew DeLambo <a href="&#x6d;&#x61;&#105;&#108;&#116;&#x6f;&#58;&#x64;&#101;&#x6c;&#97;&#x6d;&#98;&#111;&#64;&#103;&#x6d;&#x61;&#105;&#x6c;&#46;&#99;&#x6f;&#x6d;">&#x64;&#101;&#x6c;&#97;&#x6d;&#98;&#111;&#64;&#103;&#x6d;&#x61;&#105;&#x6c;&#46;&#99;&#x6f;&#x6d;</a> </p></div></div><div class="code"><div class="wrapper">(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">($)</span> {</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h2 id="backbonestickit-namespace">Backbone.Stickit Namespace</h2></div></div></div><div class="segment"><div class="code"><div class="wrapper">  Backbone.Stickit = {

    _handlers: [],

    addHandler: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(handlers)</span> {</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Fill-in default values.</p></div></div><div class="code"><div class="wrapper">      handlers = _.map(_.flatten([handlers]), <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(handler)</span> {</span>
        <span class="hljs-keyword">return</span> _.extend({
          updateModel: <span class="hljs-literal">true</span>,
          updateView: <span class="hljs-literal">true</span>,
          updateMethod: <span class="hljs-string">'text'</span>
        }, handler);
      });
      <span class="hljs-keyword">this</span>._handlers = <span class="hljs-keyword">this</span>._handlers.concat(handlers);
    }
  };</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h2 id="backboneview-mixins">Backbone.View Mixins</h2></div></div></div><div class="segment"><div class="code"><div class="wrapper">  _.extend(Backbone.View.prototype, {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Collection of model event bindings.
  [{model,event,fn}, ...]</p></div></div><div class="code"><div class="wrapper">    _modelBindings: <span class="hljs-literal">null</span>,</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Unbind the model and event bindings from <code>this._modelBindings</code> and
<code>this.$el</code>. If the optional <code>model</code> parameter is defined, then only
delete bindings for the given <code>model</code> and its corresponding view events.</p></div></div><div class="code"><div class="wrapper">    unstickit: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(model)</span> {</span>
      _.each(<span class="hljs-keyword">this</span>._modelBindings, _.bind(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(binding, i)</span> {</span>
        <span class="hljs-keyword">if</span> (model &amp;&amp; binding.model !== model) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        binding.model.off(binding.event, binding.fn);
        <span class="hljs-keyword">delete</span> <span class="hljs-keyword">this</span>._modelBindings[i];
      }, <span class="hljs-keyword">this</span>));
      <span class="hljs-keyword">this</span>._modelBindings = _.compact(<span class="hljs-keyword">this</span>._modelBindings);

      <span class="hljs-keyword">this</span>.$el.off(<span class="hljs-string">'.stickit'</span> + (model ? <span class="hljs-string">'.'</span> + model.cid : <span class="hljs-string">''</span>));
    },</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Using <code>this.bindings</code> configuration or the <code>optionalBindingsConfig</code>, binds <code>this.model</code>
or the <code>optionalModel</code> to elements in the view.</p></div></div><div class="code"><div class="wrapper">    stickit: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(optionalModel, optionalBindingsConfig)</span> {</span>
      <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>,
        model = optionalModel || <span class="hljs-keyword">this</span>.model,
        namespace = <span class="hljs-string">'.stickit.'</span> + model.cid,
        bindings = optionalBindingsConfig || <span class="hljs-keyword">this</span>.bindings || {};

      <span class="hljs-keyword">this</span>._modelBindings || (<span class="hljs-keyword">this</span>._modelBindings = []);
      <span class="hljs-keyword">this</span>.unstickit(model);</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Iterate through the selectors in the bindings configuration and configure
the various options for each field.</p></div></div><div class="code"><div class="wrapper">      _.each(_.keys(bindings), <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(selector)</span> {</span>
        <span class="hljs-keyword">var</span> $el, options, modelAttr, config,
          binding = bindings[selector] || {},
          bindKey = _.uniqueId();</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Support &#39;:el&#39; selector - special case selector for the view managed delegate.</p></div></div><div class="code"><div class="wrapper">        <span class="hljs-keyword">if</span> (selector != <span class="hljs-string">':el'</span>) $el = self.$(selector);
        <span class="hljs-keyword">else</span> {
          $el = self.$el;
          selector = <span class="hljs-string">''</span>;
        }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Fail fast if the selector didn&#39;t match an element.</p></div></div><div class="code"><div class="wrapper">        <span class="hljs-keyword">if</span> (!$el.length) <span class="hljs-keyword">return</span>;</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Allow shorthand setting of model attributes - <code>&#39;selector&#39;:&#39;observe&#39;</code>.</p></div></div><div class="code"><div class="wrapper">        <span class="hljs-keyword">if</span> (_.isString(binding)) binding = {observe:binding};

        config = getConfiguration($el, binding);

        modelAttr = config.observe;</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Create the model set options with a unique <code>bindKey</code> so that we
can avoid double-binding in the <code>change:attribute</code> event handler.</p></div></div><div class="code"><div class="wrapper">        options = _.extend({bindKey:bindKey}, config.setOptions || {});

        initializeAttributes(self, $el, config, model, modelAttr);

        initializeVisible(self, $el, config, model, modelAttr);

        <span class="hljs-keyword">if</span> (modelAttr) {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Setup one-way, form element to model, bindings.</p></div></div><div class="code"><div class="wrapper">          _.each(config.events || [], <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(type)</span> {</span>
            <span class="hljs-keyword">var</span> event = type + namespace;
            <span class="hljs-keyword">var</span> method = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(event)</span> {</span>
              <span class="hljs-keyword">var</span> val = config.getVal.call(self, $el, event, config);</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Don&#39;t update the model if false is returned from the <code>updateModel</code> configuration.</p></div></div><div class="code"><div class="wrapper">              <span class="hljs-keyword">if</span> (evaluateBoolean(self, config.updateModel, val, config))
                setAttr(model, modelAttr, val, options, self, config);
            };
            <span class="hljs-keyword">if</span> (selector === <span class="hljs-string">''</span>) self.$el.on(event, method);
            <span class="hljs-keyword">else</span> self.$el.on(event, selector, method);
          });</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Setup a <code>change:modelAttr</code> observer to keep the view element in sync.
<code>modelAttr</code> may be an array of attributes or a single string value.</p></div></div><div class="code"><div class="wrapper">          _.each(_.flatten([modelAttr]), <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(attr)</span> {</span>
            observeModelEvent(model, self, <span class="hljs-string">'change:'</span>+attr, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(model, val, options)</span> {</span>
              <span class="hljs-keyword">if</span> (options == <span class="hljs-literal">null</span> || options.bindKey != bindKey)
                updateViewBindEl(self, $el, config, getAttr(model, modelAttr, config, self), model);
            });
          });

          updateViewBindEl(self, $el, config, getAttr(model, modelAttr, config, self), model, <span class="hljs-literal">true</span>);
        }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>After each binding is setup, call the <code>initialize</code> callback.</p></div></div><div class="code"><div class="wrapper">        applyViewFn(self, config.initialize, $el, model, config);
      });</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Wrap <code>view.remove</code> to unbind stickit model and dom events.</p></div></div><div class="code"><div class="wrapper">      <span class="hljs-keyword">this</span>.remove = _.wrap(<span class="hljs-keyword">this</span>.remove, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(oldRemove)</span> {</span>
        self.unstickit();
        <span class="hljs-keyword">if</span> (oldRemove) oldRemove.call(self);
      });
    }
  });</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h2 id="helpers">Helpers</h2></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Evaluates the given <code>path</code> (in object/dot-notation) relative to the given
<code>obj</code>. If the path is null/undefined, then the given <code>obj</code> is returned.</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-keyword">var</span> evaluatePath = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(obj, path)</span> {</span>
    <span class="hljs-keyword">var</span> parts = (path || <span class="hljs-string">''</span>).split(<span class="hljs-string">'.'</span>);
    <span class="hljs-keyword">var</span> result = _.reduce(parts, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(memo, i)</span> {</span> <span class="hljs-keyword">return</span> memo[i]; }, obj);
    <span class="hljs-keyword">return</span> result == <span class="hljs-literal">null</span> ? obj : result;
  };</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>If the given <code>fn</code> is a string, then view[fn] is called, otherwise it is
a function that should be executed.</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-keyword">var</span> applyViewFn = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(view, fn)</span> {</span>
    <span class="hljs-keyword">if</span> (fn) <span class="hljs-keyword">return</span> (_.isString(fn) ? view[fn] : fn).apply(view, _.toArray(<span class="hljs-built_in">arguments</span>).slice(<span class="hljs-number">2</span>));
  };

  <span class="hljs-keyword">var</span> getSelectedOption = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">($select)</span> {</span> <span class="hljs-keyword">return</span> $select.find(<span class="hljs-string">'option'</span>).not(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span>{</span> <span class="hljs-keyword">return</span> !<span class="hljs-keyword">this</span>.selected; }); };</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Given a function, string (view function reference), or a boolean
value, returns the truthy result. Any other types evaluate as false.</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-keyword">var</span> evaluateBoolean = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(view, reference)</span> {</span>
    <span class="hljs-keyword">if</span> (_.isBoolean(reference)) <span class="hljs-keyword">return</span> reference;
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (_.isFunction(reference) || _.isString(reference))
      <span class="hljs-keyword">return</span> applyViewFn.apply(<span class="hljs-keyword">this</span>, _.toArray(<span class="hljs-built_in">arguments</span>));
    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
  };</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Setup a model event binding with the given function, and track the event
in the view&#39;s _modelBindings.</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-keyword">var</span> observeModelEvent = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(model, view, event, fn)</span> {</span>
    model.on(event, fn, view);
    view._modelBindings.push({model:model, event:event, fn:fn});
  };</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Prepares the given <code>val</code>ue and sets it into the <code>model</code>.</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-keyword">var</span> setAttr = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(model, attr, val, options, context, config)</span> {</span>
    <span class="hljs-keyword">if</span> (config.onSet) val = applyViewFn(context, config.onSet, val, config);
    model.set(attr, val, options);
  };</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Returns the given <code>attr</code>&#39;s value from the <code>model</code>, escaping and
formatting if necessary. If <code>attr</code> is an array, then an array of
respective values will be returned.</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-keyword">var</span> getAttr = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(model, attr, config, context)</span> {</span>
    <span class="hljs-keyword">var</span> val, retrieveVal = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(field)</span> {</span>
      <span class="hljs-keyword">var</span> retrieved = config.escape ? model.escape(field) : model.get(field);
      <span class="hljs-keyword">return</span> _.isUndefined(retrieved) ? <span class="hljs-string">''</span> : retrieved;
    };
    val = _.isArray(attr) ? _.map(attr, retrieveVal) : retrieveVal(attr);
    <span class="hljs-keyword">return</span> config.onGet ? applyViewFn(context, config.onGet, val, config) : val;
  };</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Find handlers in <code>Backbone.Stickit._handlers</code> with selectors that match
<code>$el</code> and generate a configuration by mixing them in the order that they
were found with the with the givne <code>binding</code>.</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-keyword">var</span> getConfiguration = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">($el, binding)</span> {</span>
    <span class="hljs-keyword">var</span> handlers = [{
      updateModel: <span class="hljs-literal">false</span>,
      updateView: <span class="hljs-literal">true</span>,
      updateMethod: <span class="hljs-string">'text'</span>,
      update: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">($el, val, m, opts)</span> {</span> $el[opts.updateMethod](val); },
      getVal: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">($el, e, opts)</span> {</span> <span class="hljs-keyword">return</span> $el[opts.updateMethod](); }
    }];
    _.each(Backbone.Stickit._handlers, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(handler)</span> {</span>
      <span class="hljs-keyword">if</span> ($el.is(handler.selector)) handlers.push(handler);
    });
    handlers.push(binding);
    <span class="hljs-keyword">var</span> config = _.extend.apply(_, handlers);
    <span class="hljs-keyword">delete</span> config.selector;
    <span class="hljs-keyword">return</span> config;
  };</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Setup the attributes configuration - a list that maps an attribute or
property <code>name</code>, to an <code>observe</code>d model attribute, using an optional
<code>onGet</code> formatter.
    attributes: [{
      name: &#39;attributeOrPropertyName&#39;,
      observe: &#39;modelAttrName&#39;
      onGet: function(modelAttrVal, modelAttrName) { ... }
    }, ...]</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-keyword">var</span> initializeAttributes = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(view, $el, config, model, modelAttr)</span> {</span>
    <span class="hljs-keyword">var</span> props = [<span class="hljs-string">'autofocus'</span>, <span class="hljs-string">'autoplay'</span>, <span class="hljs-string">'async'</span>, <span class="hljs-string">'checked'</span>, <span class="hljs-string">'controls'</span>, <span class="hljs-string">'defer'</span>, <span class="hljs-string">'disabled'</span>, <span class="hljs-string">'hidden'</span>, <span class="hljs-string">'loop'</span>, <span class="hljs-string">'multiple'</span>, <span class="hljs-string">'open'</span>, <span class="hljs-string">'readonly'</span>, <span class="hljs-string">'required'</span>, <span class="hljs-string">'scoped'</span>, <span class="hljs-string">'selected'</span>];

    _.each(config.attributes || [], <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(attrConfig)</span> {</span>
      <span class="hljs-keyword">var</span> lastClass = <span class="hljs-string">''</span>,
        observed = attrConfig.observe || (attrConfig.observe = modelAttr),
        updateAttr = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>
          <span class="hljs-keyword">var</span> updateType = _.indexOf(props, attrConfig.name, <span class="hljs-literal">true</span>) &gt; -<span class="hljs-number">1</span> ? <span class="hljs-string">'prop'</span> : <span class="hljs-string">'attr'</span>,
            val = getAttr(model, observed, attrConfig, view);</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>If it is a class then we need to remove the last value and add the new.</p></div></div><div class="code"><div class="wrapper">          <span class="hljs-keyword">if</span> (attrConfig.name == <span class="hljs-string">'class'</span>) {
            $el.removeClass(lastClass).addClass(val);
            lastClass = val;
          }
          <span class="hljs-keyword">else</span> $el[updateType](attrConfig.name, val);
        };
      _.each(_.flatten([observed]), <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(attr)</span> {</span>
        observeModelEvent(model, view, <span class="hljs-string">'change:'</span> + attr, updateAttr);
      });
      updateAttr();
    });
  };</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>If <code>visible</code> is configured, then the view element will be shown/hidden
based on the truthiness of the modelattr&#39;s value or the result of the
given callback. If a <code>visibleFn</code> is also supplied, then that callback
will be executed to manually handle showing/hiding the view element.
    observe: &#39;isRight&#39;,
    visible: true, // or function(val, options) {}
    visibleFn: function($el, isVisible, options) {} // optional handler</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-keyword">var</span> initializeVisible = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(view, $el, config, model, modelAttr)</span> {</span>
    <span class="hljs-keyword">if</span> (config.visible == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span>;
    <span class="hljs-keyword">var</span> visibleCb = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>
      <span class="hljs-keyword">var</span> visible = config.visible,
          visibleFn = config.visibleFn,
          val = getAttr(model, modelAttr, config, view),
          isVisible = !!val;</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>If <code>visible</code> is a function then it should return a boolean result to show/hide.</p></div></div><div class="code"><div class="wrapper">      <span class="hljs-keyword">if</span> (_.isFunction(visible) || _.isString(visible)) isVisible = applyViewFn(view, visible, val, config);</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Either use the custom <code>visibleFn</code>, if provided, or execute the standard show/hide.</p></div></div><div class="code"><div class="wrapper">      <span class="hljs-keyword">if</span> (visibleFn) applyViewFn(view, visibleFn, $el, isVisible, config);
      <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">if</span> (isVisible) $el.show();
        <span class="hljs-keyword">else</span> $el.hide();
      }
    };
    _.each(_.flatten([modelAttr]), <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(attr)</span> {</span>
      observeModelEvent(model, view, <span class="hljs-string">'change:'</span> + attr, visibleCb);
    });
    visibleCb();
  };</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Update the value of <code>$el</code> using the given configuration and trigger the
<code>afterUpdate</code> callback. This action may be blocked by <code>config.updateView</code>.
    update: function($el, val, model, options) {},  // handler for updating
    updateView: true, // defaults to true
    afterUpdate: function($el, val, options) {} // optional callback</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-keyword">var</span> updateViewBindEl = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(view, $el, config, val, model, isInitializing)</span> {</span>
    <span class="hljs-keyword">if</span> (!evaluateBoolean(view, config.updateView, val, config)) <span class="hljs-keyword">return</span>;
    config.update.call(view, $el, val, model, config);
    <span class="hljs-keyword">if</span> (!isInitializing) applyViewFn(view, config.afterUpdate, $el, val, config);
  };</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h2 id="default-handlers">Default Handlers</h2></div></div></div><div class="segment"><div class="code"><div class="wrapper">  Backbone.Stickit.addHandler([{
    selector: <span class="hljs-string">'[contenteditable="true"]'</span>,
    updateMethod: <span class="hljs-string">'html'</span>,
    events: [<span class="hljs-string">'keyup'</span>, <span class="hljs-string">'change'</span>, <span class="hljs-string">'paste'</span>, <span class="hljs-string">'cut'</span>]
  }, {
    selector: <span class="hljs-string">'input'</span>,
    events: [<span class="hljs-string">'keyup'</span>, <span class="hljs-string">'change'</span>, <span class="hljs-string">'paste'</span>, <span class="hljs-string">'cut'</span>],
    update: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">($el, val)</span> {</span> $el.val(val); },
    getVal: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">($el)</span> {</span>
      <span class="hljs-keyword">var</span> val = $el.val();
      <span class="hljs-keyword">if</span> ($el.is(<span class="hljs-string">'[type="number"]'</span>)) <span class="hljs-keyword">return</span> val == <span class="hljs-literal">null</span> ? val : <span class="hljs-built_in">Number</span>(val);
      <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> val;
    }
  }, {
    selector: <span class="hljs-string">'textarea'</span>,
    events: [<span class="hljs-string">'keyup'</span>, <span class="hljs-string">'change'</span>, <span class="hljs-string">'paste'</span>, <span class="hljs-string">'cut'</span>],
    update: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">($el, val)</span> {</span> $el.val(val); },
    getVal: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">($el)</span> {</span> <span class="hljs-keyword">return</span> $el.val(); }
  }, {
    selector: <span class="hljs-string">'input[type="radio"]'</span>,
    events: [<span class="hljs-string">'change'</span>],
    update: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">($el, val)</span> {</span>
      $el.filter(<span class="hljs-string">'[value="'</span>+val+<span class="hljs-string">'"]'</span>).prop(<span class="hljs-string">'checked'</span>, <span class="hljs-literal">true</span>);
    },
    getVal: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">($el)</span> {</span>
      <span class="hljs-keyword">return</span> $el.filter(<span class="hljs-string">':checked'</span>).val();
    }
  }, {
    selector: <span class="hljs-string">'input[type="checkbox"]'</span>,
    events: [<span class="hljs-string">'change'</span>],
    update: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">($el, val, model, options)</span> {</span>
      <span class="hljs-keyword">if</span> ($el.length &gt; <span class="hljs-number">1</span>) {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>There are multiple checkboxes so we need to go through them and check
any that have value attributes that match what&#39;s in the array of <code>val</code>s.</p></div></div><div class="code"><div class="wrapper">        val || (val = []);
        _.each($el, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(el)</span> {</span>
          <span class="hljs-keyword">if</span> (_.indexOf(val, $(el).val()) &gt; -<span class="hljs-number">1</span>) $(el).prop(<span class="hljs-string">'checked'</span>, <span class="hljs-literal">true</span>);
          <span class="hljs-keyword">else</span> $(el).prop(<span class="hljs-string">'checked'</span>, <span class="hljs-literal">false</span>);
        });
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">if</span> (_.isBoolean(val)) $el.prop(<span class="hljs-string">'checked'</span>, val);
        <span class="hljs-keyword">else</span> $el.prop(<span class="hljs-string">'checked'</span>, val == $el.val());
      }
    },
    getVal: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">($el)</span> {</span>
      <span class="hljs-keyword">var</span> val;
      <span class="hljs-keyword">if</span> ($el.length &gt; <span class="hljs-number">1</span>) {
        val = _.reduce($el, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(memo, el)</span> {</span>
          <span class="hljs-keyword">if</span> ($(el).prop(<span class="hljs-string">'checked'</span>)) memo.push($(el).val());
          <span class="hljs-keyword">return</span> memo;
        }, []);
      } <span class="hljs-keyword">else</span> {
        val = $el.prop(<span class="hljs-string">'checked'</span>);</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>If the checkbox has a value attribute defined, then
use that value. Most browsers use &quot;on&quot; as a default.</p></div></div><div class="code"><div class="wrapper">        <span class="hljs-keyword">var</span> boxval = $el.val();
        <span class="hljs-keyword">if</span> (boxval != <span class="hljs-string">'on'</span> &amp;&amp; boxval != <span class="hljs-literal">null</span>) {
          <span class="hljs-keyword">if</span> (val) val = $el.val();
          <span class="hljs-keyword">else</span> val = <span class="hljs-literal">null</span>;
        }
      }
      <span class="hljs-keyword">return</span> val;
    }
  }, {
    selector: <span class="hljs-string">'select'</span>,
    events: [<span class="hljs-string">'change'</span>],
    update: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">($el, val, model, options)</span> {</span>
      <span class="hljs-keyword">var</span> optList,
        selectConfig = options.selectOptions,
        list = selectConfig &amp;&amp; selectConfig.collection || <span class="hljs-literal">undefined</span>,
        isMultiple = $el.prop(<span class="hljs-string">'multiple'</span>);</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>If there are no <code>selectOptions</code> then we assume that the <code>&lt;select&gt;</code>
is pre-rendered and that we need to generate the collection.</p></div></div><div class="code"><div class="wrapper">      <span class="hljs-keyword">if</span> (!selectConfig) {
        selectConfig = {};
        <span class="hljs-keyword">var</span> getList = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">($el)</span> {</span>
          <span class="hljs-keyword">return</span> $el.find(<span class="hljs-string">'option'</span>).map(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>
            <span class="hljs-keyword">return</span> {value:<span class="hljs-keyword">this</span>.value, label:<span class="hljs-keyword">this</span>.text};
          }).get();
        };
        <span class="hljs-keyword">if</span> ($el.find(<span class="hljs-string">'optgroup'</span>).length) {
          list = {opt_labels:[]};
          _.each($el.find(<span class="hljs-string">'optgroup'</span>), <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(el)</span> {</span>
            <span class="hljs-keyword">var</span> label = $(el).attr(<span class="hljs-string">'label'</span>);
            list.opt_labels.push(label);
            list[label] = getList($(el));
          });
        } <span class="hljs-keyword">else</span> {
          list = getList($el);
        }
      }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Fill in default label and path values.</p></div></div><div class="code"><div class="wrapper">      selectConfig.valuePath = selectConfig.valuePath || <span class="hljs-string">'value'</span>;
      selectConfig.labelPath = selectConfig.labelPath || <span class="hljs-string">'label'</span>;

      <span class="hljs-keyword">var</span> addSelectOptions = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(optList, $el, fieldVal)</span> {</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Add a flag for default option at the beginning of the list.</p></div></div><div class="code"><div class="wrapper">        <span class="hljs-keyword">if</span> (selectConfig.defaultOption) {
          optList = _.clone(optList);
          optList.unshift(<span class="hljs-string">'__default__'</span>);
        }
        _.each(optList, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(obj)</span> {</span>
          <span class="hljs-keyword">var</span> option = $(<span class="hljs-string">'&lt;option/&gt;'</span>), optionVal = obj;

          <span class="hljs-keyword">var</span> fillOption = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(text, val)</span> {</span>
            option.text(text);
            optionVal = val;</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Save the option value as data so that we can reference it later.</p></div></div><div class="code"><div class="wrapper">            option.data(<span class="hljs-string">'stickit_bind_val'</span>, optionVal);
            <span class="hljs-keyword">if</span> (!_.isArray(optionVal) &amp;&amp; !_.isObject(optionVal)) option.val(optionVal);
          };

          <span class="hljs-keyword">if</span> (obj === <span class="hljs-string">'__default__'</span>)
            fillOption(selectConfig.defaultOption.label, selectConfig.defaultOption.value);
          <span class="hljs-keyword">else</span>
            fillOption(evaluatePath(obj, selectConfig.labelPath), evaluatePath(obj, selectConfig.valuePath));</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Determine if this option is selected.</p></div></div><div class="code"><div class="wrapper">          <span class="hljs-keyword">if</span> (!isMultiple &amp;&amp; optionVal != <span class="hljs-literal">null</span> &amp;&amp; fieldVal != <span class="hljs-literal">null</span> &amp;&amp; optionVal == fieldVal || (_.isObject(fieldVal) &amp;&amp; _.isEqual(optionVal, fieldVal)))
            option.prop(<span class="hljs-string">'selected'</span>, <span class="hljs-literal">true</span>);
          <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (isMultiple &amp;&amp; _.isArray(fieldVal)) {
            _.each(fieldVal, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(val)</span> {</span>
              <span class="hljs-keyword">if</span> (_.isObject(val)) val = evaluatePath(val, selectConfig.valuePath);
              <span class="hljs-keyword">if</span> (val == optionVal || (_.isObject(val) &amp;&amp; _.isEqual(optionVal, val)))
                option.prop(<span class="hljs-string">'selected'</span>, <span class="hljs-literal">true</span>);
            });
          }

          $el.append(option);
        });
      };

      $el.html(<span class="hljs-string">''</span>);</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>The <code>list</code> configuration is a function that returns the options list or a string
which represents the path to the list relative to <code>window</code> or the view/<code>this</code>.</p></div></div><div class="code"><div class="wrapper">      <span class="hljs-keyword">var</span> evaluate = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(view, list)</span> {</span>
        <span class="hljs-keyword">var</span> context = window;
        <span class="hljs-keyword">if</span> (list.indexOf(<span class="hljs-string">'this.'</span>) === <span class="hljs-number">0</span>) context = view;
        list = list.replace(<span class="hljs-regexp">/^[a-z]*\.(.+)$/</span>, <span class="hljs-string">'$1'</span>);
        <span class="hljs-keyword">return</span> evaluatePath(context, list);
      };
      <span class="hljs-keyword">if</span> (_.isString(list)) optList = evaluate(<span class="hljs-keyword">this</span>, list);
      <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (_.isFunction(list)) optList = applyViewFn(<span class="hljs-keyword">this</span>, list, $el, options);
      <span class="hljs-keyword">else</span> optList = list;</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Support Backbone.Collection and deserialize.</p></div></div><div class="code"><div class="wrapper">      <span class="hljs-keyword">if</span> (optList <span class="hljs-keyword">instanceof</span> Backbone.Collection) optList = optList.toJSON();

      <span class="hljs-keyword">if</span> (_.isArray(optList)) {
        addSelectOptions(optList, $el, val);
      } <span class="hljs-keyword">else</span> {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>If the optList is an object, then it should be used to define an optgroup. An
optgroup object configuration looks like the following:
    {
      &#39;opt_labels&#39;: [&#39;Looney Tunes&#39;, &#39;Three Stooges&#39;],
      &#39;Looney Tunes&#39;: [{id: 1, name: &#39;Bugs Bunny&#39;}, {id: 2, name: &#39;Donald Duck&#39;}],
      &#39;Three Stooges&#39;: [{id: 3, name : &#39;moe&#39;}, {id: 4, name : &#39;larry&#39;}, {id: 5, name : &#39;curly&#39;}]
    }</p></div></div><div class="code"><div class="wrapper">        _.each(optList.opt_labels, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(label)</span> {</span>
          <span class="hljs-keyword">var</span> $group = $(<span class="hljs-string">'&lt;optgroup/&gt;'</span>).attr(<span class="hljs-string">'label'</span>, label);
          addSelectOptions(optList[label], $group, val);
          $el.append($group);
        });
      }
    },
    getVal: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">($el)</span> {</span>
      <span class="hljs-keyword">var</span> val;
      <span class="hljs-keyword">if</span> ($el.prop(<span class="hljs-string">'multiple'</span>)) {
        val = $(getSelectedOption($el).map(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>
          <span class="hljs-keyword">return</span> $(<span class="hljs-keyword">this</span>).data(<span class="hljs-string">'stickit_bind_val'</span>);
        })).get();
      } <span class="hljs-keyword">else</span> {
        val = getSelectedOption($el).data(<span class="hljs-string">'stickit_bind_val'</span>);
      }
      <span class="hljs-keyword">return</span> val;
    }
  }]);

})(window.jQuery || window.Zepto);</div></div></div></div></body></html>